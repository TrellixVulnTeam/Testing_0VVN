{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n// Do a two-pass walk, first to get the list of packages that need to be\n// bundled, then again to get the actual files and folders.\n// Keep a cache of node_modules content and package.json data, so that the\n// second walk doesn't have to re-do all the same work.\n\nconst bundleWalk = require('npm-bundled')\nconst BundleWalker = bundleWalk.BundleWalker\nconst BundleWalkerSync = bundleWalk.BundleWalkerSync\n\nconst ignoreWalk = require('ignore-walk')\nconst IgnoreWalker = ignoreWalk.Walker\nconst IgnoreWalkerSync = ignoreWalk.WalkerSync\n\nconst rootBuiltinRules = Symbol('root-builtin-rules')\nconst packageNecessaryRules = Symbol('package-necessary-rules')\nconst path = require('path')\n\nconst normalizePackageBin = require('npm-normalize-package-bin')\n\n// Weird side-effect of this: a readme (etc) file will be included\n// if it exists anywhere within a folder with a package.json file.\n// The original intent was only to include these files in the root,\n// but now users in the wild are dependent on that behavior for\n// localized documentation and other use cases.  Adding a `/` to\n// these rules, while tempting and arguably more \"correct\", is a\n// significant change that will break existing use cases.\nconst packageMustHaveFileNames = 'readme|copying|license|licence'\n\nconst packageMustHaves = `@(${packageMustHaveFileNames}){,.*[^~$]}`\nconst packageMustHavesRE = new RegExp(`^(${packageMustHaveFileNames})(\\\\..*[^~$])?$`, 'i')\n\nconst fs = require('fs')\nconst glob = require('glob')\n\nconst defaultRules = [\n  '.npmignore',\n  '.gitignore',\n  '**/.git',\n  '**/.svn',\n  '**/.hg',\n  '**/CVS',\n  '**/.git/**',\n  '**/.svn/**',\n  '**/.hg/**',\n  '**/CVS/**',\n  '/.lock-wscript',\n  '/.wafpickle-*',\n  '/build/config.gypi',\n  'npm-debug.log',\n  '**/.npmrc',\n  '.*.swp',\n  '.DS_Store',\n  '**/.DS_Store/**',\n  '._*',\n  '**/._*/**',\n  '*.orig',\n  '/package-lock.json',\n  '/yarn.lock',\n  '/pnpm-lock.yaml',\n  '/archived-packages/**',\n]\n\n// There may be others, but :?|<> are handled by node-tar\nconst nameIsBadForWindows = file => /\\*/.test(file)\n\n// a decorator that applies our custom rules to an ignore walker\nconst npmWalker = Class => class Walker extends Class {\n  constructor (opt) {\n    opt = opt || {}\n\n    // the order in which rules are applied.\n    opt.ignoreFiles = [\n      rootBuiltinRules,\n      'package.json',\n      '.npmignore',\n      '.gitignore',\n      packageNecessaryRules,\n    ]\n\n    opt.includeEmpty = false\n    opt.path = opt.path || process.cwd()\n\n    // only follow links in the root node_modules folder, because if those\n    // folders are included, it's because they're bundled, and bundles\n    // should include the contents, not the symlinks themselves.\n    // This regexp tests to see that we're either a node_modules folder,\n    // or a @scope within a node_modules folder, in the root's node_modules\n    // hierarchy (ie, not in test/foo/node_modules/ or something).\n    const followRe = /^(?:\\/node_modules\\/(?:@[^/]+\\/[^/]+|[^/]+)\\/)*\\/node_modules(?:\\/@[^/]+)?$/\n    const rootPath = opt.parent ? opt.parent.root : opt.path\n    const followTestPath = opt.path.replace(/\\\\/g, '/').substr(rootPath.length)\n    opt.follow = followRe.test(followTestPath)\n\n    super(opt)\n\n    // ignore a bunch of things by default at the root level.\n    // also ignore anything in the main project node_modules hierarchy,\n    // except bundled dependencies\n    if (this.isProject) {\n      this.bundled = opt.bundled || []\n      this.bundledScopes = Array.from(new Set(\n        this.bundled.filter(f => /^@/.test(f))\n          .map(f => f.split('/')[0])))\n      const rules = defaultRules.join('\\n') + '\\n'\n      this.packageJsonCache = this.parent ? this.parent.packageJsonCache\n        : (opt.packageJsonCache || new Map())\n      super.onReadIgnoreFile(rootBuiltinRules, rules, _ => _)\n    } else {\n      this.bundled = []\n      this.bundledScopes = []\n      this.packageJsonCache = this.parent.packageJsonCache\n    }\n  }\n\n  get isProject () {\n    return !this.parent || this.parent.follow && this.isSymbolicLink\n  }\n\n  onReaddir (entries) {\n    if (this.isProject) {\n      entries = entries.filter(e =>\n        e !== '.git' &&\n        !(e === 'node_modules' && this.bundled.length === 0)\n      )\n    }\n\n    // if we have a package.json, then look in it for 'files'\n    // we _only_ do this in the root project, not bundled deps\n    // or other random folders.  Bundled deps are always assumed\n    // to be in the state the user wants to include them, and\n    // a package.json somewhere else might be a template or\n    // test or something else entirely.\n    if (!this.isProject || !entries.includes('package.json')) {\n      return super.onReaddir(entries)\n    }\n\n    // when the cache has been seeded with the root manifest,\n    // we must respect that (it may differ from the filesystem)\n    const ig = path.resolve(this.path, 'package.json')\n\n    if (this.packageJsonCache.has(ig)) {\n      const pkg = this.packageJsonCache.get(ig)\n\n      // fall back to filesystem when seeded manifest is invalid\n      if (!pkg || typeof pkg !== 'object') {\n        return this.readPackageJson(entries)\n      }\n\n      // feels wonky, but this ensures package bin is _always_\n      // normalized, as well as guarding against invalid JSON\n      return this.getPackageFiles(entries, JSON.stringify(pkg))\n    }\n\n    this.readPackageJson(entries)\n  }\n\n  onReadPackageJson (entries, er, pkg) {\n    if (er) {\n      this.emit('error', er)\n    } else {\n      this.getPackageFiles(entries, pkg)\n    }\n  }\n\n  mustHaveFilesFromPackage (pkg) {\n    const files = []\n    if (pkg.browser) {\n      files.push('/' + pkg.browser)\n    }\n    if (pkg.main) {\n      files.push('/' + pkg.main)\n    }\n    if (pkg.bin) {\n      // always an object because normalized already\n      for (const key in pkg.bin) {\n        files.push('/' + pkg.bin[key])\n      }\n    }\n    files.push(\n      '/package.json',\n      '/npm-shrinkwrap.json',\n      '!/package-lock.json',\n      packageMustHaves\n    )\n    return files\n  }\n\n  getPackageFiles (entries, pkg) {\n    try {\n      // XXX this could be changed to use read-package-json-fast\n      // which handles the normalizing of bins for us, and simplifies\n      // the test for bundleDependencies and bundledDependencies later.\n      // HOWEVER if we do this, we need to be sure that we're careful\n      // about what we write back out since rpj-fast removes some fields\n      // that the user likely wants to keep. it also would add a second\n      // file read that we would want to optimize away.\n      pkg = normalizePackageBin(JSON.parse(pkg.toString()))\n    } catch (er) {\n      // not actually a valid package.json\n      return super.onReaddir(entries)\n    }\n\n    const ig = path.resolve(this.path, 'package.json')\n    this.packageJsonCache.set(ig, pkg)\n\n    // no files list, just return the normal readdir() result\n    if (!Array.isArray(pkg.files)) {\n      return super.onReaddir(entries)\n    }\n\n    pkg.files.push(...this.mustHaveFilesFromPackage(pkg))\n\n    // If the package has a files list, then it's unlikely to include\n    // node_modules, because why would you do that?  but since we use\n    // the files list as the effective readdir result, that means it\n    // looks like we don't have a node_modules folder at all unless we\n    // include it here.\n    if ((pkg.bundleDependencies || pkg.bundledDependencies) && entries.includes('node_modules')) {\n      pkg.files.push('node_modules')\n    }\n\n    const patterns = Array.from(new Set(pkg.files)).reduce((set, pattern) => {\n      const excl = pattern.match(/^!+/)\n      if (excl) {\n        pattern = pattern.substr(excl[0].length)\n      }\n      // strip off any / from the start of the pattern.  /foo => foo\n      pattern = pattern.replace(/^\\/+/, '')\n      // an odd number of ! means a negated pattern.  !!foo ==> foo\n      const negate = excl && excl[0].length % 2 === 1\n      set.push({ pattern, negate })\n      return set\n    }, [])\n\n    let n = patterns.length\n    const set = new Set()\n    const negates = new Set()\n    const results = []\n    const then = (pattern, negate, er, fileList, i) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n\n      results[i] = { negate, fileList }\n      if (--n === 0) {\n        processResults(results)\n      }\n    }\n    const processResults = results => {\n      for (const { negate, fileList } of results) {\n        if (negate) {\n          fileList.forEach(f => {\n            f = f.replace(/\\/+$/, '')\n            set.delete(f)\n            negates.add(f)\n          })\n        } else {\n          fileList.forEach(f => {\n            f = f.replace(/\\/+$/, '')\n            set.add(f)\n            negates.delete(f)\n          })\n        }\n      }\n\n      const list = Array.from(set)\n      // replace the files array with our computed explicit set\n      pkg.files = list.concat(Array.from(negates).map(f => '!' + f))\n      const rdResult = Array.from(new Set(\n        list.map(f => f.replace(/^\\/+/, ''))\n      ))\n      super.onReaddir(rdResult)\n    }\n\n    // maintain the index so that we process them in-order only once all\n    // are completed, otherwise the parallelism messes things up, since a\n    // glob like **/*.js will always be slower than a subsequent !foo.js\n    patterns.forEach(({ pattern, negate }, i) =>\n      this.globFiles(pattern, (er, res) => then(pattern, negate, er, res, i)))\n  }\n\n  filterEntry (entry, partial) {\n    // get the partial path from the root of the walk\n    const p = this.path.substr(this.root.length + 1)\n    const pkgre = /^node_modules\\/(@[^/]+\\/?[^/]+|[^/]+)(\\/.*)?$/\n    const { isProject } = this\n    const pkg = isProject && pkgre.test(entry) ?\n      entry.replace(pkgre, '$1') : null\n    const rootNM = isProject && entry === 'node_modules'\n    const rootPJ = isProject && entry === 'package.json'\n\n    return (\n      // if we're in a bundled package, check with the parent.\n      /^node_modules($|\\/)/i.test(p) && !this.isProject ? this.parent.filterEntry(\n        this.basename + '/' + entry, partial)\n\n      // if package is bundled, all files included\n      // also include @scope dirs for bundled scoped deps\n      // they'll be ignored if no files end up in them.\n      // However, this only matters if we're in the root.\n      // node_modules folders elsewhere, like lib/node_modules,\n      // should be included normally unless ignored.\n      : pkg ? this.bundled.indexOf(pkg) !== -1 ||\n        this.bundledScopes.indexOf(pkg) !== -1\n\n      // only walk top node_modules if we want to bundle something\n      : rootNM ? !!this.bundled.length\n\n      // always include package.json at the root.\n      : rootPJ ? true\n\n      // always include readmes etc in any included dir\n      : packageMustHavesRE.test(entry) ? true\n\n      // npm-shrinkwrap and package.json always included in the root pkg\n      : isProject && (entry === 'npm-shrinkwrap.json' || entry === 'package.json')\n        ? true\n\n      // package-lock never included\n        : isProject && entry === 'package-lock.json' ? false\n\n        // otherwise, follow ignore-walk's logic\n        : super.filterEntry(entry, partial)\n    )\n  }\n\n  filterEntries () {\n    if (this.ignoreRules['.npmignore']) {\n      this.ignoreRules['.gitignore'] = null\n    }\n    this.filterEntries = super.filterEntries\n    super.filterEntries()\n  }\n\n  addIgnoreFile (file, then) {\n    const ig = path.resolve(this.path, file)\n    if (file === 'package.json' && !this.isProject) {\n      then()\n    } else if (this.packageJsonCache.has(ig)) {\n      this.onPackageJson(ig, this.packageJsonCache.get(ig), then)\n    } else {\n      super.addIgnoreFile(file, then)\n    }\n  }\n\n  onPackageJson (ig, pkg, then) {\n    this.packageJsonCache.set(ig, pkg)\n\n    if (Array.isArray(pkg.files)) {\n      // in this case we already included all the must-haves\n      super.onReadIgnoreFile('package.json', pkg.files.map(\n        f => '!' + f\n      ).join('\\n') + '\\n', then)\n    } else {\n      // if there's a bin, browser or main, make sure we don't ignore it\n      // also, don't ignore the package.json itself, or any files that\n      // must be included in the package.\n      const rules = this.mustHaveFilesFromPackage(pkg).map(f => `!${f}`)\n      const data = rules.join('\\n') + '\\n'\n      super.onReadIgnoreFile(packageNecessaryRules, data, then)\n    }\n  }\n\n  // override parent stat function to completely skip any filenames\n  // that will break windows entirely.\n  // XXX(isaacs) Next major version should make this an error instead.\n  stat ({ entry, file, dir }, then) {\n    if (nameIsBadForWindows(entry)) {\n      then()\n    } else {\n      super.stat({ entry, file, dir }, then)\n    }\n  }\n\n  // override parent onstat function to nix all symlinks, other than\n  // those coming out of the followed bundled symlink deps\n  onstat ({ st, entry, file, dir, isSymbolicLink }, then) {\n    if (st.isSymbolicLink()) {\n      then()\n    } else {\n      super.onstat({ st, entry, file, dir, isSymbolicLink }, then)\n    }\n  }\n\n  onReadIgnoreFile (file, data, then) {\n    if (file === 'package.json') {\n      try {\n        const ig = path.resolve(this.path, file)\n        this.onPackageJson(ig, JSON.parse(data), then)\n      } catch (er) {\n        // ignore package.json files that are not json\n        then()\n      }\n    } else {\n      super.onReadIgnoreFile(file, data, then)\n    }\n  }\n\n  sort (a, b) {\n    return sort(a, b)\n  }\n}\n\nclass Walker extends npmWalker(IgnoreWalker) {\n  globFiles (pattern, cb) {\n    glob(pattern, { dot: true, cwd: this.path, nocase: true }, cb)\n  }\n\n  readPackageJson (entries) {\n    fs.readFile(this.path + '/package.json', (er, pkg) =>\n      this.onReadPackageJson(entries, er, pkg))\n  }\n\n  walker (entry, opt, then) {\n    new Walker(this.walkerOpt(entry, opt)).on('done', then).start()\n  }\n}\n\nclass WalkerSync extends npmWalker(IgnoreWalkerSync) {\n  globFiles (pattern, cb) {\n    cb(null, glob.sync(pattern, { dot: true, cwd: this.path, nocase: true }))\n  }\n\n  readPackageJson (entries) {\n    const p = this.path + '/package.json'\n    try {\n      this.onReadPackageJson(entries, null, fs.readFileSync(p))\n    } catch (er) {\n      this.onReadPackageJson(entries, er)\n    }\n  }\n\n  walker (entry, opt, then) {\n    new WalkerSync(this.walkerOpt(entry, opt)).start()\n    then()\n  }\n}\n\nconst walk = (options, callback) => {\n  options = options || {}\n  const p = new Promise((resolve, reject) => {\n    const bw = new BundleWalker(options)\n    bw.on('done', bundled => {\n      options.bundled = bundled\n      options.packageJsonCache = bw.packageJsonCache\n      new Walker(options).on('done', resolve).on('error', reject).start()\n    })\n    bw.start()\n  })\n  return callback ? p.then(res => callback(null, res), callback) : p\n}\n\nconst walkSync = options => {\n  options = options || {}\n  const bw = new BundleWalkerSync(options).start()\n  options.bundled = bw.result\n  options.packageJsonCache = bw.packageJsonCache\n  const walker = new WalkerSync(options)\n  walker.start()\n  return walker.result\n}\n\n// optimize for compressibility\n// extname, then basename, then locale alphabetically\n// https://twitter.com/isntitvacant/status/1131094910923231232\nconst sort = (a, b) => {\n  const exta = path.extname(a).toLowerCase()\n  const extb = path.extname(b).toLowerCase()\n  const basea = path.basename(a).toLowerCase()\n  const baseb = path.basename(b).toLowerCase()\n\n  return exta.localeCompare(extb, 'en') ||\n    basea.localeCompare(baseb, 'en') ||\n    a.localeCompare(b, 'en')\n}\n\nmodule.exports = walk\nwalk.sync = walkSync\nwalk.Walker = Walker\nwalk.WalkerSync = WalkerSync\n"]}