{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const { promisify } = require('util')\nconst path = require('path')\n\nconst getName = require('@npmcli/name-from-folder')\nconst minimatch = require('minimatch')\nconst rpj = require('read-package-json-fast')\nconst glob = require('glob')\nconst pGlob = promisify(glob)\n\nfunction appendNegatedPatterns (patterns) {\n  const results = []\n  for (let pattern of patterns) {\n    const excl = pattern.match(/^!+/)\n    if (excl) {\n      pattern = pattern.substr(excl[0].length)\n    }\n\n    // strip off any / from the start of the pattern.  /foo => foo\n    pattern = pattern.replace(/^\\/+/, '')\n\n    // an odd number of ! means a negated pattern.  !!foo ==> foo\n    const negate = excl && excl[0].length % 2 === 1\n    results.push({ pattern, negate })\n  }\n\n  return results\n}\n\nfunction getPatterns (workspaces) {\n  const workspacesDeclaration =\n    Array.isArray(workspaces.packages)\n      ? workspaces.packages\n      : workspaces\n\n  if (!Array.isArray(workspacesDeclaration)) {\n    throw getError({\n      message: 'workspaces config expects an Array',\n      code: 'EWORKSPACESCONFIG',\n    })\n  }\n\n  return appendNegatedPatterns(workspacesDeclaration)\n}\n\nfunction getPackageName (pkg, pathname) {\n  const { name } = pkg\n  return name || getName(pathname)\n}\n\nfunction pkgPathmame (opts) {\n  return (...args) => {\n    const cwd = opts.cwd ? opts.cwd : process.cwd()\n    return path.join.apply(null, [cwd, ...args])\n  }\n}\n\n// make sure glob pattern only matches folders\nfunction getGlobPattern (pattern) {\n  pattern = pattern.replace(/\\\\/g, '/')\n  return pattern.endsWith('/')\n    ? pattern\n    : `${pattern}/`\n}\n\nfunction getError ({ Type = TypeError, message, code }) {\n  return Object.assign(new Type(message), { code })\n}\n\nfunction reverseResultMap (map) {\n  return new Map(Array.from(map, item => item.reverse()))\n}\n\nasync function mapWorkspaces (opts = {}) {\n  if (!opts || !opts.pkg) {\n    throw getError({\n      message: 'mapWorkspaces missing pkg info',\n      code: 'EMAPWORKSPACESPKG',\n    })\n  }\n\n  const { workspaces = [] } = opts.pkg\n  const patterns = getPatterns(workspaces)\n  const results = new Map()\n  const seen = new Map()\n\n  if (!patterns.length) {\n    return results\n  }\n\n  const getGlobOpts = () => ({\n    ...opts,\n    ignore: [\n      ...opts.ignore || [],\n      ...['**/node_modules/**'],\n    ],\n  })\n\n  const getPackagePathname = pkgPathmame(opts)\n\n  for (const item of patterns) {\n    const matches = await pGlob(getGlobPattern(item.pattern), getGlobOpts())\n\n    for (const match of matches) {\n      let pkg\n      const packageJsonPathname = getPackagePathname(match, 'package.json')\n      const packagePathname = path.dirname(packageJsonPathname)\n\n      try {\n        pkg = await rpj(packageJsonPathname)\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          continue\n        } else {\n          throw err\n        }\n      }\n\n      const name = getPackageName(pkg, packagePathname)\n\n      let seenPackagePathnames = seen.get(name)\n      if (!seenPackagePathnames) {\n        seenPackagePathnames = new Set()\n        seen.set(name, seenPackagePathnames)\n      }\n      if (item.negate) {\n        seenPackagePathnames.delete(packagePathname)\n      } else {\n        seenPackagePathnames.add(packagePathname)\n      }\n    }\n  }\n\n  const errorMessageArray = ['must not have multiple workspaces with the same name']\n  for (const [packageName, seenPackagePathnames] of seen) {\n    if (seenPackagePathnames.size === 0) {\n      continue\n    }\n    if (seenPackagePathnames.size > 1) {\n      addDuplicateErrorMessages(errorMessageArray, packageName, seenPackagePathnames)\n    } else {\n      results.set(packageName, seenPackagePathnames.values().next().value)\n    }\n  }\n\n  if (errorMessageArray.length > 1) {\n    throw getError({\n      Type: Error,\n      message: errorMessageArray.join('\\n'),\n      code: 'EDUPLICATEWORKSPACE',\n    })\n  }\n\n  return results\n}\n\nfunction addDuplicateErrorMessages (messageArray, packageName, packagePathnames) {\n  messageArray.push(\n    `package '${packageName}' has conflicts in the following paths:`\n  )\n\n  for (const packagePathname of packagePathnames) {\n    messageArray.push(\n      '    ' + packagePathname\n    )\n  }\n}\n\nmapWorkspaces.virtual = function (opts = {}) {\n  if (!opts || !opts.lockfile) {\n    throw getError({\n      message: 'mapWorkspaces.virtual missing lockfile info',\n      code: 'EMAPWORKSPACESLOCKFILE',\n    })\n  }\n\n  const { packages = {} } = opts.lockfile\n  const { workspaces = [] } = packages[''] || {}\n  // uses a pathname-keyed map in order to negate the exact items\n  const results = new Map()\n  const patterns = getPatterns(workspaces)\n  if (!patterns.length) {\n    return results\n  }\n  patterns.push({ pattern: '**/node_modules/**', negate: true })\n\n  const getPackagePathname = pkgPathmame(opts)\n\n  for (const packageKey of Object.keys(packages)) {\n    if (packageKey === '') {\n      continue\n    }\n\n    for (const item of patterns) {\n      if (minimatch(packageKey, item.pattern)) {\n        const packagePathname = getPackagePathname(packageKey)\n        const name = getPackageName(packages[packageKey], packagePathname)\n\n        if (item.negate) {\n          results.delete(packagePathname)\n        } else {\n          results.set(packagePathname, name)\n        }\n      }\n    }\n  }\n\n  // Invert pathname-keyed to a proper name-to-pathnames Map\n  return reverseResultMap(results)\n}\n\nmodule.exports = mapWorkspaces\n"]}