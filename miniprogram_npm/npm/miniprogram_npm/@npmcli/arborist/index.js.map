{"version":3,"sources":["index.js","arborist/index.js","add-rm-pkg-deps.js","tracker.js","arborist/pruner.js","arborist/deduper.js","arborist/audit.js","audit-report.js","vuln.js","arborist/build-ideal-tree.js","realpath.js","tree-check.js","debug.js","can-place-dep.js","peer-entry-sets.js","deepest-nesting-target.js","place-dep.js","link.js","relpath.js","node.js","edge.js","dep-valid.js","from-path.js","inventory.js","override-set.js","gather-dep-set.js","consistent-resolve.js","printable.js","case-insensitive-map.js","calc-dep-flags.js","shrinkwrap.js","yarn-lock.js","spec-from-lock.js","version-from-tgz.js","optional-set.js","reset-dep-flags.js","arborist/load-workspaces.js","arborist/load-actual.js","arborist/load-virtual.js","arborist/rebuild.js","get-workspace-nodes.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA;ADIA,ADGA,AGTA,ADGA;ADIA,AGTA,AJYA,AGTA,ADGA;ADIA,AGTA,AJYA,AGTA,ADGA;ADIA,AGTA,AJYA,AGTA,ADGA;ADIA,AIZA,ADGA,AJYA,AGTA,ADGA;ADIA,AIZA,ADGA,AJYA,AGTA,ADGA;ADIA,AIZA,ADGA,AJYA,AGTA,ADGA;ADIA,AIZA,ADGA,AJYA,AGTA,AGTA,AJYA;ADIA,AIZA,ADGA,AJYA,AGTA,AGTA,AJYA;ADIA,AIZA,ADGA,AJYA,AGTA,AGTA,AJYA;ADIA,AIZA,ADGA,AJYA,AGTA,AGTA,AJYA,AKfA;ANmBA,AIZA,ADGA,AJYA,AGTA,AGTA,AJYA,AKfA;ANmBA,AIZA,ADGA,AJYA,AGTA,AGTA,AJYA,AKfA;ANmBA,AIZA,AGTA,AJYA,AJYA,AGTA,AGTA,AJYA,AKfA;ANmBA,AIZA,AGTA,AJYA,AJYA,AGTA,AGTA,AJYA,AKfA;ANmBA,AIZA,AGTA,AJYA,AJYA,AGTA,AGTA,AJYA,AKfA;ANmBA,AIZA,AGTA,AJYA,AJYA,AGTA,AGTA,AGTA,APqBA,AKfA;ANmBA,AIZA,AGTA,AJYA,AJYA,AGTA,AGTA,AGTA,APqBA,AKfA;ANmBA,AIZA,AGTA,AJYA,AJYA,AGTA,AGTA,AGTA,APqBA,AKfA;ANmBA,AIZA,AGTA,AJYA,AJYA,AGTA,AGTA,AGTA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,AJYA,AJYA,AGTA,AGTA,AGTA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AGTA,AGTA,AGTA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AGTA,AGTA,AKfA,AFMA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AGTA,AGTA,AKfA,AFMA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AGTA,AGTA,AKfA,AFMA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AGTA,AGTA,AMlBA,ADGA,AFMA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AGTA,AGTA,AMlBA,ADGA,AFMA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AGTA,AGTA,AMlBA,ADGA,AFMA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AGTA,AGTA,AMlBA,ADGA,AENA,AJYA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AENA,AJYA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AENA,AJYA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,ADGA,AJYA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,ADGA,AJYA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,ADGA,AJYA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,ADGA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,ADGA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,ADGA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AENA,AHSA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AENA,AHSA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AENA,AHSA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AENA,AHSA,AENA,ANkBA,AQxBA,Af6CA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AENA,AHSA,AENA,ANkBA,AQxBA,Af6CA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AENA,AHSA,AENA,ANkBA,AQxBA,Af6CA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AENA,AENA,ALeA,AENA,ANkBA,AQxBA,Af6CA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AENA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AENA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AKfA,AHSA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AIZA,AGTA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AKfA,AHSA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AKfA,AHSA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,ADGA,AGTA,AMlBA,ADGA,AHSA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,ADGA,AS3BA,ADGA,AHSA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,ADGA,AS3BA,ADGA,AHSA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,ADGA,AS3BA,ADGA,AENA,ALeA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,ADGA,AS3BA,ADGA,AENA,ALeA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AQxBA,ADGA,AENA,ALeA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AQxBA,ADGA,AENA,ACHA,ANkBA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AQxBA,ADGA,AENA,ACHA,ANkBA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AQxBA,ADGA,AENA,ACHA,ANkBA,AENA,ALeA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AQxBA,ADGA,AENA,ACHA,ANkBA,AENA,AKfA,AV8BA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AQxBA,ADGA,AENA,ACHA,ANkBA,AENA,AKfA,AV8BA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AQxBA,ADGA,AENA,ACHA,ANkBA,AENA,AKfA,AV8BA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AQxBA,ADGA,AENA,AGTA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AQxBA,ADGA,AENA,AGTA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AQxBA,ADGA,AENA,AGTA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AavCA,ALeA,ADGA,AENA,AGTA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AavCA,ALeA,ADGA,AENA,AGTA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AavCA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,ANkBA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AavCA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AavCA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,AavCA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AMlBA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,APqBA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,A3BiFA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,A3BiFA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,A3BiFA,AQxBA,AHSA;ANmBA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,A3BiFA,AQxBA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,A3BiFA,AQxBA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,A3BiFA,AQxBA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,AENA,A7BuFA,AQxBA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,AENA,A7BuFA,AQxBA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,AENA,A7BuFA,AQxBA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,AENA,A7BuFA,AQxBA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,AENA,A7BuFA,AQxBA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,AKfA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,AENA,A7BuFA,AQxBA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,AENA,A7BuFA,AQxBA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,AENA,A7BuFA,AQxBA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AoB5DA,AENA,A7BuFA,AQxBA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,A7BuFA,AQxBA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,A7BuFA,AQxBA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AMlBA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,A7BuFA,AQxBA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AmCzGA,A7BuFA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AmCzGA,A7BuFA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AmCzGA,A7BuFA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ADGA,A7BuFA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ADGA,A7BuFA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ADGA,A7BuFA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,A7BuFA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,A7BuFA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,A7BuFA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,AFMA,ALeA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AKfA,AFMA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AGTA,ANkBA,AENA,Ae7CA,AV8BA,AV8BA,AENA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AjBmDA,AyB3EA,ALeA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AjBmDA,AoB5DA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AjBmDA,AoB5DA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AjBmDA,AoB5DA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AjBmDA,AoB5DA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AjBmDA,AoB5DA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AjBmDA,AoB5DA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AjBmDA,AoB5DA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AjBmDA,AoB5DA,AENA,ArB+DA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,Ae7CA,APqBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,Ae7CA,AV8BA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,AFMA,AGTA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AsBlEA,AzB2EA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;A7BwFA,AOrBA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AoB5DA,AjBmDA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,ARwBA,AoC5GA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AnByDA,AHSA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AGTA,ANkBA,AENA,AKfA,ARwBA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AHSA,AENA,AKfA,ARwBA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,AHSA,AENA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AQxBA,ADGA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AsBlEA,AhBgDA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,AtBkEA,AuBrEA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,AWjCA,AGTA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AOrBA,ADGA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,ACHA,ACHA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,AENA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,AENA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,AENA,AhCgGA,AMlBA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA,ACHA;AtBmEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,A1B8EA,AMlBA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AENA,ApB4DA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,A4BpFA,AlBsDA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AHSA,Ac1CA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA,AWjCA;ArBgEA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA,AU9BA;AV+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./arborist/index.js')\nmodule.exports.Arborist = module.exports\nmodule.exports.Node = require('./node.js')\nmodule.exports.Link = require('./link.js')\nmodule.exports.Edge = require('./edge.js')\nmodule.exports.Shrinkwrap = require('./shrinkwrap.js')\n// XXX export the other classes, too.  shrinkwrap, diff, etc.\n// they're handy!\n","// The arborist manages three trees:\n// - actual\n// - virtual\n// - ideal\n//\n// The actual tree is what's present on disk in the node_modules tree\n// and elsewhere that links may extend.\n//\n// The virtual tree is loaded from metadata (package.json and lock files).\n//\n// The ideal tree is what we WANT that actual tree to become.  This starts\n// with the virtual tree, and then applies the options requesting\n// add/remove/update actions.\n//\n// To reify a tree, we calculate a diff between the ideal and actual trees,\n// and then turn the actual tree into the ideal tree by taking the actions\n// required.  At the end of the reification process, the actualTree is\n// updated to reflect the changes.\n//\n// Each tree has an Inventory at the root.  Shrinkwrap is tracked by Arborist\n// instance.  It always refers to the actual tree, but is updated (and written\n// to disk) on reification.\n\n// Each of the mixin \"classes\" adds functionality, but are not dependent on\n// constructor call order.  So, we just load them in an array, and build up\n// the base class, so that the overall voltron class is easier to test and\n// cover, and separation of concerns can be maintained.\n\nconst { resolve } = require('path')\nconst { homedir } = require('os')\nconst { depth } = require('treeverse')\nconst { saveTypeMap } = require('../add-rm-pkg-deps.js')\n\nconst mixins = [\n  require('../tracker.js'),\n  require('./pruner.js'),\n  require('./deduper.js'),\n  require('./audit.js'),\n  require('./build-ideal-tree.js'),\n  require('./load-workspaces.js'),\n  require('./load-actual.js'),\n  require('./load-virtual.js'),\n  require('./rebuild.js'),\n  require('./reify.js'),\n]\n\nconst _workspacesEnabled = Symbol.for('workspacesEnabled')\nconst Base = mixins.reduce((a, b) => b(a), require('events'))\nconst getWorkspaceNodes = require('../get-workspace-nodes.js')\n\n// if it's 1, 2, or 3, set it explicitly that.\n// if undefined or null, set it null\n// otherwise, throw.\nconst lockfileVersion = lfv => {\n  if (lfv === 1 || lfv === 2 || lfv === 3) {\n    return lfv\n  }\n\n  if (lfv === undefined || lfv === null) {\n    return null\n  }\n\n  throw new TypeError('Invalid lockfileVersion config: ' + lfv)\n}\n\nclass Arborist extends Base {\n  constructor (options = {}) {\n    process.emit('time', 'arborist:ctor')\n    super(options)\n    this.options = {\n      nodeVersion: process.version,\n      ...options,\n      path: options.path || '.',\n      cache: options.cache || `${homedir()}/.npm/_cacache`,\n      packumentCache: options.packumentCache || new Map(),\n      workspacesEnabled: options.workspacesEnabled !== false,\n      lockfileVersion: lockfileVersion(options.lockfileVersion),\n    }\n\n    this[_workspacesEnabled] = this.options.workspacesEnabled\n\n    if (options.saveType && !saveTypeMap.get(options.saveType)) {\n      throw new Error(`Invalid saveType ${options.saveType}`)\n    }\n    this.cache = resolve(this.options.cache)\n    this.path = resolve(this.options.path)\n    process.emit('timeEnd', 'arborist:ctor')\n  }\n\n  // TODO: We should change these to static functions instead\n  //   of methods for the next major version\n\n  // returns an array of the actual nodes for all the workspaces\n  workspaceNodes (tree, workspaces) {\n    return getWorkspaceNodes(tree, workspaces)\n  }\n\n  // returns a set of workspace nodes and all their deps\n  workspaceDependencySet (tree, workspaces, includeWorkspaceRoot) {\n    const wsNodes = this.workspaceNodes(tree, workspaces)\n    if (includeWorkspaceRoot) {\n      for (const edge of tree.edgesOut.values()) {\n        if (edge.type !== 'workspace' && edge.to) {\n          wsNodes.push(edge.to)\n        }\n      }\n    }\n    const wsDepSet = new Set(wsNodes)\n    const extraneous = new Set()\n    for (const node of wsDepSet) {\n      for (const edge of node.edgesOut.values()) {\n        const dep = edge.to\n        if (dep) {\n          wsDepSet.add(dep)\n          if (dep.isLink) {\n            wsDepSet.add(dep.target)\n          }\n        }\n      }\n      for (const child of node.children.values()) {\n        if (child.extraneous) {\n          extraneous.add(child)\n        }\n      }\n    }\n    for (const extra of extraneous) {\n      wsDepSet.add(extra)\n    }\n\n    return wsDepSet\n  }\n\n  // returns a set of root dependencies, excluding depdencies that are\n  // exclusively workspace dependencies\n  excludeWorkspacesDependencySet (tree) {\n    const rootDepSet = new Set()\n    depth({\n      tree,\n      visit: node => {\n        for (const { to } of node.edgesOut.values()) {\n          if (!to || to.isWorkspace) {\n            continue\n          }\n          for (const edgeIn of to.edgesIn.values()) {\n            if (edgeIn.from.isRoot || rootDepSet.has(edgeIn.from)) {\n              rootDepSet.add(to)\n            }\n          }\n        }\n        return node\n      },\n      filter: node => node,\n      getChildren: (node, tree) =>\n        [...tree.edgesOut.values()].map(edge => edge.to),\n    })\n    return rootDepSet\n  }\n}\n\nmodule.exports = Arborist\n","// add and remove dependency specs to/from pkg manifest\n\nconst log = require('proc-log')\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nconst add = ({ pkg, add, saveBundle, saveType }) => {\n  for (const spec of add) {\n    addSingle({ pkg, spec, saveBundle, saveType })\n  }\n\n  return pkg\n}\n\n// Canonical source of both the map between saveType and where it correlates to\n// in the package, and the names of all our dependencies attributes\nconst saveTypeMap = new Map([\n  ['dev', 'devDependencies'],\n  ['optional', 'optionalDependencies'],\n  ['prod', 'dependencies'],\n  ['peerOptional', 'peerDependencies'],\n  ['peer', 'peerDependencies'],\n])\n\nconst addSingle = ({ pkg, spec, saveBundle, saveType }) => {\n  const { name, rawSpec } = spec\n\n  // if the user does not give us a type, we infer which type(s)\n  // to keep based on the same order of priority we do when\n  // building the tree as defined in the _loadDeps method of\n  // the node class.\n  if (!saveType) {\n    saveType = inferSaveType(pkg, spec.name)\n  }\n\n  if (saveType === 'prod') {\n    // a production dependency can only exist as production (rpj ensures it\n    // doesn't coexist w/ optional)\n    deleteSubKey(pkg, 'devDependencies', name, 'dependencies')\n    deleteSubKey(pkg, 'peerDependencies', name, 'dependencies')\n  } else if (saveType === 'dev') {\n    // a dev dependency may co-exist as peer, or optional, but not production\n    deleteSubKey(pkg, 'dependencies', name, 'devDependencies')\n  } else if (saveType === 'optional') {\n    // an optional dependency may co-exist as dev (rpj ensures it doesn't\n    // coexist w/ prod)\n    deleteSubKey(pkg, 'peerDependencies', name, 'optionalDependencies')\n  } else { // peer or peerOptional is all that's left\n    // a peer dependency may coexist as dev\n    deleteSubKey(pkg, 'dependencies', name, 'peerDependencies')\n    deleteSubKey(pkg, 'optionalDependencies', name, 'peerDependencies')\n  }\n\n  const depType = saveTypeMap.get(saveType)\n\n  pkg[depType] = pkg[depType] || {}\n  if (rawSpec !== '' || pkg[depType][name] === undefined) {\n    pkg[depType][name] = rawSpec || '*'\n  }\n  if (saveType === 'optional') {\n    // Affordance for previous npm versions that require this behaviour\n    pkg.dependencies = pkg.dependencies || {}\n    pkg.dependencies[name] = pkg.optionalDependencies[name]\n  }\n\n  if (saveType === 'peer' || saveType === 'peerOptional') {\n    const pdm = pkg.peerDependenciesMeta || {}\n    if (saveType === 'peer' && pdm[name] && pdm[name].optional) {\n      pdm[name].optional = false\n    } else if (saveType === 'peerOptional') {\n      pdm[name] = pdm[name] || {}\n      pdm[name].optional = true\n      pkg.peerDependenciesMeta = pdm\n    }\n    // peerDeps are often also a devDep, so that they can be tested when\n    // using package managers that don't auto-install peer deps\n    if (pkg.devDependencies && pkg.devDependencies[name] !== undefined) {\n      pkg.devDependencies[name] = pkg.peerDependencies[name]\n    }\n  }\n\n  if (saveBundle && saveType !== 'peer' && saveType !== 'peerOptional') {\n    // keep it sorted, keep it unique\n    const bd = new Set(pkg.bundleDependencies || [])\n    bd.add(spec.name)\n    pkg.bundleDependencies = [...bd].sort(localeCompare)\n  }\n}\n\n// Finds where the package is already in the spec and infers saveType from that\nconst inferSaveType = (pkg, name) => {\n  for (const saveType of saveTypeMap.keys()) {\n    if (hasSubKey(pkg, saveTypeMap.get(saveType), name)) {\n      if (\n        saveType === 'peerOptional' &&\n        (!hasSubKey(pkg, 'peerDependenciesMeta', name) ||\n        !pkg.peerDependenciesMeta[name].optional)\n      ) {\n        return 'peer'\n      }\n      return saveType\n    }\n  }\n  return 'prod'\n}\n\nconst { hasOwnProperty } = Object.prototype\nconst hasSubKey = (pkg, depType, name) => {\n  return pkg[depType] && hasOwnProperty.call(pkg[depType], name)\n}\n\n// Removes a subkey and warns about it if it's being replaced\nconst deleteSubKey = (pkg, depType, name, replacedBy) => {\n  if (hasSubKey(pkg, depType, name)) {\n    if (replacedBy) {\n      log.warn('idealTree', `Removing ${depType}.${name} in favor of ${replacedBy}.${name}`)\n    }\n    delete pkg[depType][name]\n\n    // clean up peerDepsMeta if we are removing something from peerDependencies\n    if (depType === 'peerDependencies' && pkg.peerDependenciesMeta) {\n      delete pkg.peerDependenciesMeta[name]\n      if (!Object.keys(pkg.peerDependenciesMeta).length) {\n        delete pkg.peerDependenciesMeta\n      }\n    }\n\n    if (!Object.keys(pkg[depType]).length) {\n      delete pkg[depType]\n    }\n  }\n}\n\nconst rm = (pkg, rm) => {\n  for (const depType of new Set(saveTypeMap.values())) {\n    for (const name of rm) {\n      deleteSubKey(pkg, depType, name)\n    }\n  }\n  if (pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundleDependencies\n      .filter(name => !rm.includes(name))\n    if (!pkg.bundleDependencies.length) {\n      delete pkg.bundleDependencies\n    }\n  }\n  return pkg\n}\n\nmodule.exports = { add, rm, saveTypeMap, hasSubKey }\n","const _progress = Symbol('_progress')\nconst _onError = Symbol('_onError')\nconst npmlog = require('npmlog')\n\nmodule.exports = cls => class Tracker extends cls {\n  constructor (options = {}) {\n    super(options)\n    this[_progress] = new Map()\n  }\n\n  addTracker (section, subsection = null, key = null) {\n    if (section === null || section === undefined) {\n      this[_onError](`Tracker can't be null or undefined`)\n    }\n\n    if (key === null) {\n      key = subsection\n    }\n\n    const hasTracker = this[_progress].has(section)\n    const hasSubtracker = this[_progress].has(`${section}:${key}`)\n\n    if (hasTracker && subsection === null) {\n      // 0. existing tracker, no subsection\n      this[_onError](`Tracker \"${section}\" already exists`)\n    } else if (!hasTracker && subsection === null) {\n      // 1. no existing tracker, no subsection\n      // Create a new tracker from npmlog\n      // starts progress bar\n      if (this[_progress].size === 0) {\n        npmlog.enableProgress()\n      }\n\n      this[_progress].set(section, npmlog.newGroup(section))\n    } else if (!hasTracker && subsection !== null) {\n      // 2. no parent tracker and subsection\n      this[_onError](`Parent tracker \"${section}\" does not exist`)\n    } else if (!hasTracker || !hasSubtracker) {\n      // 3. existing parent tracker, no subsection tracker\n      // Create a new subtracker in this[_progress] from parent tracker\n      this[_progress].set(`${section}:${key}`,\n        this[_progress].get(section).newGroup(`${section}:${subsection}`)\n      )\n    }\n    // 4. existing parent tracker, existing subsection tracker\n    // skip it\n  }\n\n  finishTracker (section, subsection = null, key = null) {\n    if (section === null || section === undefined) {\n      this[_onError](`Tracker can't be null or undefined`)\n    }\n\n    if (key === null) {\n      key = subsection\n    }\n\n    const hasTracker = this[_progress].has(section)\n    const hasSubtracker = this[_progress].has(`${section}:${key}`)\n\n    // 0. parent tracker exists, no subsection\n    // Finish parent tracker and remove from this[_progress]\n    if (hasTracker && subsection === null) {\n      // check if parent tracker does\n      // not have any remaining children\n      const keys = this[_progress].keys()\n      for (const key of keys) {\n        if (key.match(new RegExp(section + ':'))) {\n          this.finishTracker(section, key)\n        }\n      }\n\n      // remove parent tracker\n      this[_progress].get(section).finish()\n      this[_progress].delete(section)\n\n      // remove progress bar if all\n      // trackers are finished\n      if (this[_progress].size === 0) {\n        npmlog.disableProgress()\n      }\n    } else if (!hasTracker && subsection === null) {\n      // 1. no existing parent tracker, no subsection\n      this[_onError](`Tracker \"${section}\" does not exist`)\n    } else if (!hasTracker || hasSubtracker) {\n      // 2. subtracker exists\n      // Finish subtracker and remove from this[_progress]\n      this[_progress].get(`${section}:${key}`).finish()\n      this[_progress].delete(`${section}:${key}`)\n    }\n    // 3. existing parent tracker, no subsection\n  }\n\n  [_onError] (msg) {\n    npmlog.disableProgress()\n    throw new Error(msg)\n  }\n}\n","const _idealTreePrune = Symbol.for('idealTreePrune')\nconst _workspacesEnabled = Symbol.for('workspacesEnabled')\nconst _addNodeToTrashList = Symbol.for('addNodeToTrashList')\n\nmodule.exports = cls => class Pruner extends cls {\n  async prune (options = {}) {\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = { ...this.options, ...options }\n\n    await this.buildIdealTree(options)\n\n    this[_idealTreePrune]()\n\n    if (!this[_workspacesEnabled]) {\n      const excludeNodes = this.excludeWorkspacesDependencySet(this.idealTree)\n      for (const node of this.idealTree.inventory.values()) {\n        if (\n          node.parent !== null\n          && !node.isProjectRoot\n          && !excludeNodes.has(node)\n        ) {\n          this[_addNodeToTrashList](node)\n        }\n      }\n    }\n\n    return this.reify(options)\n  }\n}\n","module.exports = cls => class Deduper extends cls {\n  async dedupe (options = {}) {\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = { ...this.options, ...options }\n    const tree = await this.loadVirtual().catch(() => this.loadActual())\n    const names = []\n    for (const name of tree.inventory.query('name')) {\n      if (tree.inventory.query('name', name).size > 1) {\n        names.push(name)\n      }\n    }\n    return this.reify({\n      ...options,\n      preferDedupe: true,\n      update: { names },\n    })\n  }\n}\n","// mixin implementing the audit method\n\nconst AuditReport = require('../audit-report.js')\n\n// shared with reify\nconst _global = Symbol.for('global')\nconst _workspaces = Symbol.for('workspaces')\nconst _includeWorkspaceRoot = Symbol.for('includeWorkspaceRoot')\n\nmodule.exports = cls => class Auditor extends cls {\n  async audit (options = {}) {\n    this.addTracker('audit')\n    if (this[_global]) {\n      throw Object.assign(\n        new Error('`npm audit` does not support testing globals'),\n        { code: 'EAUDITGLOBAL' }\n      )\n    }\n\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = { ...this.options, ...options }\n\n    process.emit('time', 'audit')\n    const tree = await this.loadVirtual()\n    if (this[_workspaces] && this[_workspaces].length) {\n      options.filterSet = this.workspaceDependencySet(\n        tree,\n        this[_workspaces],\n        this[_includeWorkspaceRoot]\n      )\n    }\n    if (!options.workspacesEnabled) {\n      options.filterSet =\n        this.excludeWorkspacesDependencySet(tree)\n    }\n    this.auditReport = await AuditReport.load(tree, options)\n    const ret = options.fix ? this.reify(options) : this.auditReport\n    process.emit('timeEnd', 'audit')\n    this.finishTracker('audit')\n    return ret\n  }\n}\n","// an object representing the set of vulnerabilities in a tree\n/* eslint camelcase: \"off\" */\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst npa = require('npm-package-arg')\nconst pickManifest = require('npm-pick-manifest')\n\nconst Vuln = require('./vuln.js')\nconst Calculator = require('@npmcli/metavuln-calculator')\n\nconst _getReport = Symbol('getReport')\nconst _fixAvailable = Symbol('fixAvailable')\nconst _checkTopNode = Symbol('checkTopNode')\nconst _init = Symbol('init')\nconst _omit = Symbol('omit')\nconst log = require('proc-log')\n\nconst fetch = require('npm-registry-fetch')\n\nclass AuditReport extends Map {\n  static load (tree, opts) {\n    return new AuditReport(tree, opts).run()\n  }\n\n  get auditReportVersion () {\n    return 2\n  }\n\n  toJSON () {\n    const obj = {\n      auditReportVersion: this.auditReportVersion,\n      vulnerabilities: {},\n      metadata: {\n        vulnerabilities: {\n          info: 0,\n          low: 0,\n          moderate: 0,\n          high: 0,\n          critical: 0,\n          total: this.size,\n        },\n        dependencies: {\n          prod: 0,\n          dev: 0,\n          optional: 0,\n          peer: 0,\n          peerOptional: 0,\n          total: this.tree.inventory.size - 1,\n        },\n      },\n    }\n\n    for (const node of this.tree.inventory.values()) {\n      const { dependencies } = obj.metadata\n      let prod = true\n      for (const type of [\n        'dev',\n        'optional',\n        'peer',\n        'peerOptional',\n      ]) {\n        if (node[type]) {\n          dependencies[type]++\n          prod = false\n        }\n      }\n      if (prod) {\n        dependencies.prod++\n      }\n    }\n\n    // if it doesn't have any topVulns, then it's fixable with audit fix\n    // for each topVuln, figure out if it's fixable with audit fix --force,\n    // or if we have to just delete the thing, and if the fix --force will\n    // require a semver major update.\n    const vulnerabilities = []\n    for (const [name, vuln] of this.entries()) {\n      vulnerabilities.push([name, vuln.toJSON()])\n      obj.metadata.vulnerabilities[vuln.severity]++\n    }\n\n    obj.vulnerabilities = vulnerabilities\n      .sort(([a], [b]) => localeCompare(a, b))\n      .reduce((set, [name, vuln]) => {\n        set[name] = vuln\n        return set\n      }, {})\n\n    return obj\n  }\n\n  constructor (tree, opts = {}) {\n    super()\n    const { omit } = opts\n    this[_omit] = new Set(omit || [])\n    this.topVulns = new Map()\n\n    this.calculator = new Calculator(opts)\n    this.error = null\n    this.options = opts\n    this.tree = tree\n    this.filterSet = opts.filterSet\n  }\n\n  async run () {\n    this.report = await this[_getReport]()\n    log.silly('audit report', this.report)\n    if (this.report) {\n      await this[_init]()\n    }\n    return this\n  }\n\n  isVulnerable (node) {\n    const vuln = this.get(node.packageName)\n    return !!(vuln && vuln.isVulnerable(node))\n  }\n\n  async [_init] () {\n    process.emit('time', 'auditReport:init')\n\n    const promises = []\n    for (const [name, advisories] of Object.entries(this.report)) {\n      for (const advisory of advisories) {\n        promises.push(this.calculator.calculate(name, advisory))\n      }\n    }\n\n    // now the advisories are calculated with a set of versions\n    // and the packument.  turn them into our style of vuln objects\n    // which also have the affected nodes, and also create entries\n    // for all the metavulns that we find from dependents.\n    const advisories = new Set(await Promise.all(promises))\n    const seen = new Set()\n    for (const advisory of advisories) {\n      const { name, range } = advisory\n\n      // don't flag the exact same name/range more than once\n      // adding multiple advisories with the same range is fine, but no\n      // need to search for nodes we already would have added.\n      const k = `${name}@${range}`\n      if (seen.has(k)) {\n        continue\n      }\n\n      seen.add(k)\n\n      const vuln = this.get(name) || new Vuln({ name, advisory })\n      if (this.has(name)) {\n        vuln.addAdvisory(advisory)\n      }\n      super.set(name, vuln)\n\n      const p = []\n      for (const node of this.tree.inventory.query('packageName', name)) {\n        if (!shouldAudit(node, this[_omit], this.filterSet)) {\n          continue\n        }\n\n        // if not vulnerable by this advisory, keep searching\n        if (!advisory.testVersion(node.version)) {\n          continue\n        }\n\n        // we will have loaded the source already if this is a metavuln\n        if (advisory.type === 'metavuln') {\n          vuln.addVia(this.get(advisory.dependency))\n        }\n\n        // already marked this one, no need to do it again\n        if (vuln.nodes.has(node)) {\n          continue\n        }\n\n        // haven't marked this one yet.  get its dependents.\n        vuln.nodes.add(node)\n        for (const { from: dep, spec } of node.edgesIn) {\n          if (dep.isTop && !vuln.topNodes.has(dep)) {\n            this[_checkTopNode](dep, vuln, spec)\n          } else {\n            // calculate a metavuln, if necessary\n            const calc = this.calculator.calculate(dep.packageName, advisory)\n            p.push(calc.then(meta => {\n              if (meta.testVersion(dep.version, spec)) {\n                advisories.add(meta)\n              }\n            }))\n          }\n        }\n      }\n      await Promise.all(p)\n\n      // make sure we actually got something.  if not, remove it\n      // this can happen if you are loading from a lockfile created by\n      // npm v5, since it lists the current version of all deps,\n      // rather than the range that is actually depended upon,\n      // or if using --omit with the older audit endpoint.\n      if (this.get(name).nodes.size === 0) {\n        this.delete(name)\n        continue\n      }\n\n      // if the vuln is valid, but THIS advisory doesn't apply to any of\n      // the nodes it references, then remove it from the advisory list.\n      // happens when using omit with old audit endpoint.\n      for (const advisory of vuln.advisories) {\n        const relevant = [...vuln.nodes]\n          .some(n => advisory.testVersion(n.version))\n        if (!relevant) {\n          vuln.deleteAdvisory(advisory)\n        }\n      }\n    }\n    process.emit('timeEnd', 'auditReport:init')\n  }\n\n  [_checkTopNode] (topNode, vuln, spec) {\n    vuln.fixAvailable = this[_fixAvailable](topNode, vuln, spec)\n\n    if (vuln.fixAvailable !== true) {\n      // now we know the top node is vulnerable, and cannot be\n      // upgraded out of the bad place without --force.  But, there's\n      // no need to add it to the actual vulns list, because nothing\n      // depends on root.\n      this.topVulns.set(vuln.name, vuln)\n      vuln.topNodes.add(topNode)\n    }\n  }\n\n  // check whether the top node is vulnerable.\n  // check whether we can get out of the bad place with --force, and if\n  // so, whether that update is SemVer Major\n  [_fixAvailable] (topNode, vuln, spec) {\n    // this will always be set to at least {name, versions:{}}\n    const paku = vuln.packument\n\n    if (!vuln.testSpec(spec)) {\n      return true\n    }\n\n    // similarly, even if we HAVE a packument, but we're looking for it\n    // somewhere other than the registry, and we got something vulnerable,\n    // then we're stuck with it.\n    const specObj = npa(spec)\n    if (!specObj.registry) {\n      return false\n    }\n\n    if (specObj.subSpec) {\n      spec = specObj.subSpec.rawSpec\n    }\n\n    // We don't provide fixes for top nodes other than root, but we\n    // still check to see if the node is fixable with a different version,\n    // and if that is a semver major bump.\n    try {\n      const {\n        _isSemVerMajor: isSemVerMajor,\n        version,\n        name,\n      } = pickManifest(paku, spec, {\n        ...this.options,\n        before: null,\n        avoid: vuln.range,\n        avoidStrict: true,\n      })\n      return { name, version, isSemVerMajor }\n    } catch (er) {\n      return false\n    }\n  }\n\n  set () {\n    throw new Error('do not call AuditReport.set() directly')\n  }\n\n  // convert a quick-audit into a bulk advisory listing\n  static auditToBulk (report) {\n    if (!report.advisories) {\n      // tack on the report json where the response body would go\n      throw Object.assign(new Error('Invalid advisory report'), {\n        body: JSON.stringify(report),\n      })\n    }\n\n    const bulk = {}\n    const { advisories } = report\n    for (const advisory of Object.values(advisories)) {\n      const {\n        id,\n        url,\n        title,\n        severity = 'high',\n        vulnerable_versions = '*',\n        module_name: name,\n      } = advisory\n      bulk[name] = bulk[name] || []\n      bulk[name].push({ id, url, title, severity, vulnerable_versions })\n    }\n\n    return bulk\n  }\n\n  async [_getReport] () {\n    // if we're not auditing, just return false\n    if (this.options.audit === false || this.options.offline === true || this.tree.inventory.size === 1) {\n      return null\n    }\n\n    process.emit('time', 'auditReport:getReport')\n    try {\n      try {\n        // first try the super fast bulk advisory listing\n        const body = prepareBulkData(this.tree, this[_omit], this.filterSet)\n        log.silly('audit', 'bulk request', body)\n\n        // no sense asking if we don't have anything to audit,\n        // we know it'll be empty\n        if (!Object.keys(body).length) {\n          return null\n        }\n\n        const res = await fetch('/-/npm/v1/security/advisories/bulk', {\n          ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body,\n        })\n\n        return await res.json()\n      } catch (er) {\n        log.silly('audit', 'bulk request failed', String(er.body))\n        // that failed, try the quick audit endpoint\n        const body = prepareData(this.tree, this.options)\n        const res = await fetch('/-/npm/v1/security/audits/quick', {\n          ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body,\n        })\n        return AuditReport.auditToBulk(await res.json())\n      }\n    } catch (er) {\n      log.verbose('audit error', er)\n      log.silly('audit error', String(er.body))\n      this.error = er\n      return null\n    } finally {\n      process.emit('timeEnd', 'auditReport:getReport')\n    }\n  }\n}\n\n// return true if we should audit this one\nconst shouldAudit = (node, omit, filterSet) =>\n  !node.version ? false\n  : node.isRoot ? false\n  : filterSet && filterSet.size !== 0 && !filterSet.has(node) ? false\n  : omit.size === 0 ? true\n  : !( // otherwise, just ensure we're not omitting this one\n    node.dev && omit.has('dev') ||\n    node.optional && omit.has('optional') ||\n    node.devOptional && omit.has('dev') && omit.has('optional') ||\n    node.peer && omit.has('peer')\n  )\n\nconst prepareBulkData = (tree, omit, filterSet) => {\n  const payload = {}\n  for (const name of tree.inventory.query('packageName')) {\n    const set = new Set()\n    for (const node of tree.inventory.query('packageName', name)) {\n      if (!shouldAudit(node, omit, filterSet)) {\n        continue\n      }\n\n      set.add(node.version)\n    }\n    if (set.size) {\n      payload[name] = [...set]\n    }\n  }\n  return payload\n}\n\nconst prepareData = (tree, opts) => {\n  const { npmVersion: npm_version } = opts\n  const node_version = process.version\n  const { platform, arch } = process\n  const { NODE_ENV: node_env } = process.env\n  const data = tree.meta.commit()\n  // the legacy audit endpoint doesn't support any kind of pre-filtering\n  // we just have to get the advisories and skip over them in the report\n  return {\n    name: data.name,\n    version: data.version,\n    requires: {\n      ...(tree.package.devDependencies || {}),\n      ...(tree.package.peerDependencies || {}),\n      ...(tree.package.optionalDependencies || {}),\n      ...(tree.package.dependencies || {}),\n    },\n    dependencies: data.dependencies,\n    metadata: {\n      node_version,\n      npm_version,\n      platform,\n      arch,\n      node_env,\n    },\n  }\n}\n\nmodule.exports = AuditReport\n","// An object representing a vulnerability either as the result of an\n// advisory or due to the package in question depending exclusively on\n// vulnerable versions of a dep.\n//\n// - name: package name\n// - range: Set of vulnerable versions\n// - nodes: Set of nodes affected\n// - effects: Set of vulns triggered by this one\n// - advisories: Set of advisories (including metavulns) causing this vuln.\n//   All of the entries in via are vulnerability objects returned by\n//   @npmcli/metavuln-calculator\n// - via: dependency vulns which cause this one\n\nconst { satisfies, simplifyRange } = require('semver')\nconst semverOpt = { loose: true, includePrerelease: true }\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst npa = require('npm-package-arg')\nconst _range = Symbol('_range')\nconst _simpleRange = Symbol('_simpleRange')\nconst _fixAvailable = Symbol('_fixAvailable')\n\nconst severities = new Map([\n  ['info', 0],\n  ['low', 1],\n  ['moderate', 2],\n  ['high', 3],\n  ['critical', 4],\n  [null, -1],\n])\n\nfor (const [name, val] of severities.entries()) {\n  severities.set(val, name)\n}\n\nclass Vuln {\n  constructor ({ name, advisory }) {\n    this.name = name\n    this.via = new Set()\n    this.advisories = new Set()\n    this.severity = null\n    this.effects = new Set()\n    this.topNodes = new Set()\n    this[_range] = null\n    this[_simpleRange] = null\n    this.nodes = new Set()\n    // assume a fix is available unless it hits a top node\n    // that locks it in place, setting this false or {isSemVerMajor, version}.\n    this[_fixAvailable] = true\n    this.addAdvisory(advisory)\n    this.packument = advisory.packument\n    this.versions = advisory.versions\n  }\n\n  get fixAvailable () {\n    return this[_fixAvailable]\n  }\n\n  set fixAvailable (f) {\n    this[_fixAvailable] = f\n    // if there's a fix available for this at the top level, it means that\n    // it will also fix the vulns that led to it being there.  to get there,\n    // we set the vias to the most \"strict\" of fix availables.\n    // - false: no fix is available\n    // - {name, version, isSemVerMajor} fix requires -f, is semver major\n    // - {name, version} fix requires -f, not semver major\n    // - true: fix does not require -f\n    for (const v of this.via) {\n      // don't blow up on loops\n      if (v.fixAvailable === f) {\n        continue\n      }\n\n      if (f === false) {\n        v.fixAvailable = f\n      } else if (v.fixAvailable === true) {\n        v.fixAvailable = f\n      } else if (typeof f === 'object' && (\n        typeof v.fixAvailable !== 'object' || !v.fixAvailable.isSemVerMajor)) {\n        v.fixAvailable = f\n      }\n    }\n  }\n\n  get isDirect () {\n    for (const node of this.nodes.values()) {\n      for (const edge of node.edgesIn) {\n        if (edge.from.isProjectRoot || edge.from.isWorkspace) {\n          return true\n        }\n      }\n    }\n    return false\n  }\n\n  testSpec (spec) {\n    const specObj = npa(spec)\n    if (!specObj.registry) {\n      return true\n    }\n\n    if (specObj.subSpec) {\n      spec = specObj.subSpec.rawSpec\n    }\n\n    for (const v of this.versions) {\n      if (satisfies(v, spec) && !satisfies(v, this.range, semverOpt)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  toJSON () {\n    return {\n      name: this.name,\n      severity: this.severity,\n      isDirect: this.isDirect,\n      // just loop over the advisories, since via is only Vuln objects,\n      // and calculated advisories have all the info we need\n      via: [...this.advisories].map(v => v.type === 'metavuln' ? v.dependency : {\n        ...v,\n        versions: undefined,\n        vulnerableVersions: undefined,\n        id: undefined,\n      }).sort((a, b) =>\n        localeCompare(String(a.source || a), String(b.source || b))),\n      effects: [...this.effects].map(v => v.name).sort(localeCompare),\n      range: this.simpleRange,\n      nodes: [...this.nodes].map(n => n.location).sort(localeCompare),\n      fixAvailable: this[_fixAvailable],\n    }\n  }\n\n  addVia (v) {\n    this.via.add(v)\n    v.effects.add(this)\n    // call the setter since we might add vias _after_ setting fixAvailable\n    this.fixAvailable = this.fixAvailable\n  }\n\n  deleteVia (v) {\n    this.via.delete(v)\n    v.effects.delete(this)\n  }\n\n  deleteAdvisory (advisory) {\n    this.advisories.delete(advisory)\n    // make sure we have the max severity of all the vulns causing this one\n    this.severity = null\n    this[_range] = null\n    this[_simpleRange] = null\n    // refresh severity\n    for (const advisory of this.advisories) {\n      this.addAdvisory(advisory)\n    }\n\n    // remove any effects that are no longer relevant\n    const vias = new Set([...this.advisories].map(a => a.dependency))\n    for (const via of this.via) {\n      if (!vias.has(via.name)) {\n        this.deleteVia(via)\n      }\n    }\n  }\n\n  addAdvisory (advisory) {\n    this.advisories.add(advisory)\n    const sev = severities.get(advisory.severity)\n    this[_range] = null\n    this[_simpleRange] = null\n    if (sev > severities.get(this.severity)) {\n      this.severity = advisory.severity\n    }\n  }\n\n  get range () {\n    return this[_range] ||\n      (this[_range] = [...this.advisories].map(v => v.range).join(' || '))\n  }\n\n  get simpleRange () {\n    if (this[_simpleRange] && this[_simpleRange] === this[_range]) {\n      return this[_simpleRange]\n    }\n\n    const versions = [...this.advisories][0].versions\n    const range = this.range\n    const simple = simplifyRange(versions, range, semverOpt)\n    return this[_simpleRange] = this[_range] = simple\n  }\n\n  isVulnerable (node) {\n    if (this.nodes.has(node)) {\n      return true\n    }\n\n    const { version } = node.package\n    if (!version) {\n      return false\n    }\n\n    for (const v of this.advisories) {\n      if (v.testVersion(version)) {\n        this.nodes.add(node)\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\nmodule.exports = Vuln\n","// mixin implementing the buildIdealTree method\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst rpj = require('read-package-json-fast')\nconst npa = require('npm-package-arg')\nconst pacote = require('pacote')\nconst cacache = require('cacache')\nconst promiseCallLimit = require('promise-call-limit')\nconst realpath = require('../../lib/realpath.js')\nconst { resolve, dirname } = require('path')\nconst { promisify } = require('util')\nconst treeCheck = require('../tree-check.js')\nconst readdir = promisify(require('readdir-scoped-modules'))\nconst fs = require('fs')\nconst lstat = promisify(fs.lstat)\nconst readlink = promisify(fs.readlink)\nconst { depth } = require('treeverse')\nconst log = require('proc-log')\n\nconst {\n  OK,\n  REPLACE,\n  CONFLICT,\n} = require('../can-place-dep.js')\nconst PlaceDep = require('../place-dep.js')\n\nconst debug = require('../debug.js')\nconst fromPath = require('../from-path.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst { defaultLockfileVersion } = Shrinkwrap\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst addRmPkgDeps = require('../add-rm-pkg-deps.js')\nconst optionalSet = require('../optional-set.js')\nconst { checkEngine, checkPlatform } = require('npm-install-checks')\n\nconst relpath = require('../relpath.js')\n\n// note: some of these symbols are shared so we can hit\n// them with unit tests and reuse them across mixins\nconst _complete = Symbol('complete')\nconst _depsSeen = Symbol('depsSeen')\nconst _depsQueue = Symbol('depsQueue')\nconst _currentDep = Symbol('currentDep')\nconst _updateAll = Symbol.for('updateAll')\nconst _mutateTree = Symbol('mutateTree')\nconst _flagsSuspect = Symbol.for('flagsSuspect')\nconst _workspaces = Symbol.for('workspaces')\nconst _prune = Symbol('prune')\nconst _preferDedupe = Symbol('preferDedupe')\nconst _legacyBundling = Symbol('legacyBundling')\nconst _parseSettings = Symbol('parseSettings')\nconst _initTree = Symbol('initTree')\nconst _applyUserRequests = Symbol('applyUserRequests')\nconst _applyUserRequestsToNode = Symbol('applyUserRequestsToNode')\nconst _inflateAncientLockfile = Symbol('inflateAncientLockfile')\nconst _buildDeps = Symbol('buildDeps')\nconst _buildDepStep = Symbol('buildDepStep')\nconst _nodeFromEdge = Symbol('nodeFromEdge')\nconst _nodeFromSpec = Symbol('nodeFromSpec')\nconst _fetchManifest = Symbol('fetchManifest')\nconst _problemEdges = Symbol('problemEdges')\nconst _manifests = Symbol('manifests')\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _linkFromSpec = Symbol('linkFromSpec')\nconst _loadPeerSet = Symbol('loadPeerSet')\nconst _updateNames = Symbol.for('updateNames')\nconst _fixDepFlags = Symbol('fixDepFlags')\nconst _resolveLinks = Symbol('resolveLinks')\nconst _rootNodeFromPackage = Symbol('rootNodeFromPackage')\nconst _add = Symbol('add')\nconst _resolvedAdd = Symbol.for('resolvedAdd')\nconst _queueNamedUpdates = Symbol('queueNamedUpdates')\nconst _queueVulnDependents = Symbol('queueVulnDependents')\nconst _avoidRange = Symbol('avoidRange')\nconst _shouldUpdateNode = Symbol('shouldUpdateNode')\nconst resetDepFlags = require('../reset-dep-flags.js')\nconst _loadFailures = Symbol('loadFailures')\nconst _pruneFailedOptional = Symbol('pruneFailedOptional')\nconst _linkNodes = Symbol('linkNodes')\nconst _follow = Symbol('follow')\nconst _globalStyle = Symbol('globalStyle')\nconst _globalRootNode = Symbol('globalRootNode')\nconst _isVulnerable = Symbol.for('isVulnerable')\nconst _usePackageLock = Symbol.for('usePackageLock')\nconst _rpcache = Symbol.for('realpathCache')\nconst _stcache = Symbol.for('statCache')\nconst _updateFilePath = Symbol('updateFilePath')\nconst _followSymlinkPath = Symbol('followSymlinkPath')\nconst _getRelpathSpec = Symbol('getRelpathSpec')\nconst _retrieveSpecName = Symbol('retrieveSpecName')\nconst _strictPeerDeps = Symbol('strictPeerDeps')\nconst _checkEngineAndPlatform = Symbol('checkEngineAndPlatform')\nconst _checkEngine = Symbol('checkEngine')\nconst _checkPlatform = Symbol('checkPlatform')\nconst _virtualRoots = Symbol('virtualRoots')\nconst _virtualRoot = Symbol('virtualRoot')\nconst _includeWorkspaceRoot = Symbol.for('includeWorkspaceRoot')\n\nconst _failPeerConflict = Symbol('failPeerConflict')\nconst _explainPeerConflict = Symbol('explainPeerConflict')\nconst _edgesOverridden = Symbol('edgesOverridden')\n// exposed symbol for unit testing the placeDep method directly\nconst _peerSetSource = Symbol.for('peerSetSource')\n\n// used by Reify mixin\nconst _force = Symbol.for('force')\nconst _explicitRequests = Symbol('explicitRequests')\nconst _global = Symbol.for('global')\nconst _idealTreePrune = Symbol.for('idealTreePrune')\n\nmodule.exports = cls => class IdealTreeBuilder extends cls {\n  constructor (options) {\n    super(options)\n\n    // normalize trailing slash\n    const registry = options.registry || 'https://registry.npmjs.org'\n    options.registry = this.registry = registry.replace(/\\/+$/, '') + '/'\n\n    const {\n      follow = false,\n      force = false,\n      global = false,\n      globalStyle = false,\n      idealTree = null,\n      includeWorkspaceRoot = false,\n      legacyPeerDeps = false,\n      packageLock = true,\n      strictPeerDeps = false,\n      workspaces = [],\n    } = options\n\n    this[_workspaces] = workspaces || []\n    this[_force] = !!force\n    this[_strictPeerDeps] = !!strictPeerDeps\n\n    this.idealTree = idealTree\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this[_usePackageLock] = packageLock\n    this[_global] = !!global\n    this[_globalStyle] = this[_global] || globalStyle\n    this[_follow] = !!follow\n\n    if (this[_workspaces].length && this[_global]) {\n      throw new Error('Cannot operate on workspaces in global mode')\n    }\n\n    this[_explicitRequests] = new Set()\n    this[_preferDedupe] = false\n    this[_legacyBundling] = false\n    this[_depsSeen] = new Set()\n    this[_depsQueue] = []\n    this[_currentDep] = null\n    this[_updateNames] = []\n    this[_updateAll] = false\n    this[_mutateTree] = false\n    this[_loadFailures] = new Set()\n    this[_linkNodes] = new Set()\n    this[_manifests] = new Map()\n    this[_edgesOverridden] = new Set()\n    this[_resolvedAdd] = []\n\n    // a map of each module in a peer set to the thing that depended on\n    // that set of peers in the first place.  Use a WeakMap so that we\n    // don't hold onto references for nodes that are garbage collected.\n    this[_peerSetSource] = new WeakMap()\n    this[_virtualRoots] = new Map()\n\n    this[_includeWorkspaceRoot] = includeWorkspaceRoot\n  }\n\n  get explicitRequests () {\n    return new Set(this[_explicitRequests])\n  }\n\n  // public method\n  async buildIdealTree (options = {}) {\n    if (this.idealTree) {\n      return this.idealTree\n    }\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    // an empty array or any falsey value is the same as null\n    if (!options.add || options.add.length === 0) {\n      options.add = null\n    }\n    if (!options.rm || options.rm.length === 0) {\n      options.rm = null\n    }\n\n    process.emit('time', 'idealTree')\n\n    if (!options.add && !options.rm && !options.update && this[_global]) {\n      throw new Error('global requires add, rm, or update option')\n    }\n\n    // first get the virtual tree, if possible.  If there's a lockfile, then\n    // that defines the ideal tree, unless the root package.json is not\n    // satisfied by what the ideal tree provides.\n    // from there, we start adding nodes to it to satisfy the deps requested\n    // by the package.json in the root.\n\n    this[_parseSettings](options)\n\n    // start tracker block\n    this.addTracker('idealTree')\n\n    try {\n      await this[_initTree]()\n      await this[_inflateAncientLockfile]()\n      await this[_applyUserRequests](options)\n      await this[_buildDeps]()\n      await this[_fixDepFlags]()\n      await this[_pruneFailedOptional]()\n      await this[_checkEngineAndPlatform]()\n    } finally {\n      process.emit('timeEnd', 'idealTree')\n      this.finishTracker('idealTree')\n    }\n\n    return treeCheck(this.idealTree)\n  }\n\n  async [_checkEngineAndPlatform] () {\n    for (const node of this.idealTree.inventory.values()) {\n      if (!node.optional) {\n        this[_checkEngine](node)\n        this[_checkPlatform](node)\n      }\n    }\n  }\n\n  [_checkPlatform] (node) {\n    checkPlatform(node.package, this[_force])\n  }\n\n  [_checkEngine] (node) {\n    const { engineStrict, npmVersion, nodeVersion } = this.options\n    const c = () =>\n      checkEngine(node.package, npmVersion, nodeVersion, this[_force])\n\n    if (engineStrict) {\n      c()\n    } else {\n      try {\n        c()\n      } catch (er) {\n        log.warn(er.code, er.message, {\n          package: er.pkgid,\n          required: er.required,\n          current: er.current,\n        })\n      }\n    }\n  }\n\n  [_parseSettings] (options) {\n    const update = options.update === true ? { all: true }\n      : Array.isArray(options.update) ? { names: options.update }\n      : options.update || {}\n\n    if (update.all || !Array.isArray(update.names)) {\n      update.names = []\n    }\n\n    this[_complete] = !!options.complete\n    this[_preferDedupe] = !!options.preferDedupe\n    this[_legacyBundling] = !!options.legacyBundling\n\n    // validates list of update names, they must\n    // be dep names only, no semver ranges are supported\n    for (const name of update.names) {\n      const spec = npa(name)\n      const validationError =\n        new TypeError(`Update arguments must not contain package version specifiers\n\nTry using the package name instead, e.g:\n    npm update ${spec.name}`)\n      validationError.code = 'EUPDATEARGS'\n\n      if (spec.fetchSpec !== 'latest') {\n        throw validationError\n      }\n    }\n    this[_updateNames] = update.names\n\n    this[_updateAll] = update.all\n    // we prune by default unless explicitly set to boolean false\n    this[_prune] = options.prune !== false\n\n    // set if we add anything, but also set here if we know we'll make\n    // changes and thus have to maybe prune later.\n    this[_mutateTree] = !!(\n      options.add ||\n      options.rm ||\n      update.all ||\n      update.names.length\n    )\n  }\n\n  // load the initial tree, either the virtualTree from a shrinkwrap,\n  // or just the root node from a package.json\n  [_initTree] () {\n    process.emit('time', 'idealTree:init')\n    return (\n      this[_global] ? this[_globalRootNode]()\n      : rpj(this.path + '/package.json').then(\n        pkg => this[_rootNodeFromPackage](pkg),\n        er => {\n          if (er.code === 'EJSONPARSE') {\n            throw er\n          }\n          return this[_rootNodeFromPackage]({})\n        }\n      ))\n      .then(root => this[_loadWorkspaces](root))\n      // ok to not have a virtual tree.  probably initial install.\n      // When updating all, we load the shrinkwrap, but don't bother\n      // to build out the full virtual tree from it, since we'll be\n      // reconstructing it anyway.\n      .then(root => this[_global] ? root\n      : !this[_usePackageLock] || this[_updateAll]\n        ? Shrinkwrap.reset({\n          path: this.path,\n          lockfileVersion: this.options.lockfileVersion,\n        }).then(meta => Object.assign(root, { meta }))\n        : this.loadVirtual({ root }))\n\n      // if we don't have a lockfile to go from, then start with the\n      // actual tree, so we only make the minimum required changes.\n      // don't do this for global installs or updates, because in those\n      // cases we don't use a lockfile anyway.\n      // Load on a new Arborist object, so the Nodes aren't the same,\n      // or else it'll get super confusing when we change them!\n      .then(async root => {\n        if ((!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk) || (this[_global] && this[_updateNames].length)) {\n          await new this.constructor(this.options).loadActual({ root })\n          const tree = root.target\n          // even though we didn't load it from a package-lock.json FILE,\n          // we still loaded it \"from disk\", meaning we have to reset\n          // dep flags before assuming that any mutations were reflected.\n          if (tree.children.size) {\n            root.meta.loadedFromDisk = true\n            // set these so that we don't try to ancient lockfile reload it\n            root.meta.originalLockfileVersion = defaultLockfileVersion\n            root.meta.lockfileVersion = defaultLockfileVersion\n          }\n        }\n        root.meta.inferFormattingOptions(root.package)\n        return root\n      })\n\n      .then(tree => {\n        // null the virtual tree, because we're about to hack away at it\n        // if you want another one, load another copy.\n        this.idealTree = tree\n        this.virtualTree = null\n        process.emit('timeEnd', 'idealTree:init')\n      })\n  }\n\n  async [_globalRootNode] () {\n    const root = await this[_rootNodeFromPackage]({ dependencies: {} })\n    // this is a gross kludge to handle the fact that we don't save\n    // metadata on the root node in global installs, because the \"root\"\n    // node is something like /usr/local/lib.\n    const meta = new Shrinkwrap({\n      path: this.path,\n      lockfileVersion: this.options.lockfileVersion,\n    })\n    meta.reset()\n    root.meta = meta\n    return root\n  }\n\n  async [_rootNodeFromPackage] (pkg) {\n    // if the path doesn't exist, then we explode at this point. Note that\n    // this is not a problem for reify(), since it creates the root path\n    // before ever loading trees.\n    // TODO: make buildIdealTree() and loadActual handle a missing root path,\n    // or a symlink to a missing target, and let reify() create it as needed.\n    const real = await realpath(this.path, this[_rpcache], this[_stcache])\n    const Cls = real === this.path ? Node : Link\n    const root = new Cls({\n      path: this.path,\n      realpath: real,\n      pkg,\n      extraneous: false,\n      dev: false,\n      devOptional: false,\n      peer: false,\n      optional: false,\n      global: this[_global],\n      legacyPeerDeps: this.legacyPeerDeps,\n      loadOverrides: true,\n    })\n    if (root.isLink) {\n      root.target = new Node({\n        path: real,\n        realpath: real,\n        pkg,\n        extraneous: false,\n        dev: false,\n        devOptional: false,\n        peer: false,\n        optional: false,\n        global: this[_global],\n        legacyPeerDeps: this.legacyPeerDeps,\n        root,\n      })\n    }\n    return root\n  }\n\n  // process the add/rm requests by modifying the root node, and the\n  // update.names request by queueing nodes dependent on those named.\n  async [_applyUserRequests] (options) {\n    process.emit('time', 'idealTree:userRequests')\n    const tree = this.idealTree.target\n\n    if (!this[_workspaces].length) {\n      await this[_applyUserRequestsToNode](tree, options)\n    } else {\n      const nodes = this.workspaceNodes(tree, this[_workspaces])\n      if (this[_includeWorkspaceRoot]) {\n        nodes.push(tree)\n      }\n      const appliedRequests = nodes.map(\n        node => this[_applyUserRequestsToNode](node, options)\n      )\n      await Promise.all(appliedRequests)\n    }\n\n    process.emit('timeEnd', 'idealTree:userRequests')\n  }\n\n  async [_applyUserRequestsToNode] (tree, options) {\n    // If we have a list of package names to update, and we know it's\n    // going to update them wherever they are, add any paths into those\n    // named nodes to the buildIdealTree queue.\n    if (!this[_global] && this[_updateNames].length) {\n      this[_queueNamedUpdates]()\n    }\n\n    // global updates only update the globalTop nodes, but we need to know\n    // that they're there, and not reinstall the world unnecessarily.\n    const globalExplicitUpdateNames = []\n    if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {\n      const nm = resolve(this.path, 'node_modules')\n      for (const name of await readdir(nm).catch(() => [])) {\n        tree.package.dependencies = tree.package.dependencies || {}\n        const updateName = this[_updateNames].includes(name)\n        if (this[_updateAll] || updateName) {\n          if (updateName) {\n            globalExplicitUpdateNames.push(name)\n          }\n          const dir = resolve(nm, name)\n          const st = await lstat(dir)\n            .catch(/* istanbul ignore next */ er => null)\n          if (st && st.isSymbolicLink()) {\n            const target = await readlink(dir)\n            const real = resolve(dirname(dir), target)\n            tree.package.dependencies[name] = `file:${real}`\n          } else {\n            tree.package.dependencies[name] = '*'\n          }\n        }\n      }\n    }\n\n    if (this.auditReport && this.auditReport.size > 0) {\n      await this[_queueVulnDependents](options)\n    }\n\n    const { add, rm } = options\n\n    if (rm && rm.length) {\n      addRmPkgDeps.rm(tree.package, rm)\n      for (const name of rm) {\n        this[_explicitRequests].add({ from: tree, name, action: 'DELETE' })\n      }\n    }\n\n    if (add && add.length) {\n      await this[_add](tree, options)\n    }\n\n    // triggers a refresh of all edgesOut.  this has to be done BEFORE\n    // adding the edges to explicitRequests, because the package setter\n    // resets all edgesOut.\n    if (add && add.length || rm && rm.length || this[_global]) {\n      tree.package = tree.package\n    }\n\n    for (const spec of this[_resolvedAdd]) {\n      if (spec.tree === tree) {\n        this[_explicitRequests].add(tree.edgesOut.get(spec.name))\n      }\n    }\n    for (const name of globalExplicitUpdateNames) {\n      this[_explicitRequests].add(tree.edgesOut.get(name))\n    }\n\n    this[_depsQueue].push(tree)\n  }\n\n  // This returns a promise because we might not have the name yet,\n  // and need to call pacote.manifest to find the name.\n  [_add] (tree, { add, saveType = null, saveBundle = false }) {\n    // get the name for each of the specs in the list.\n    // ie, doing `foo@bar` we just return foo\n    // but if it's a url or git, we don't know the name until we\n    // fetch it and look in its manifest.\n    return Promise.all(add.map(async rawSpec => {\n      // We do NOT provide the path to npa here, because user-additions\n      // need to be resolved relative to the CWD the user is in.\n      const spec = await this[_retrieveSpecName](npa(rawSpec))\n        .then(spec => this[_updateFilePath](spec))\n        .then(spec => this[_followSymlinkPath](spec))\n      spec.tree = tree\n      return spec\n    })).then(add => {\n      this[_resolvedAdd].push(...add)\n      // now add is a list of spec objects with names.\n      // find a home for each of them!\n      addRmPkgDeps.add({\n        pkg: tree.package,\n        add,\n        saveBundle,\n        saveType,\n        path: this.path,\n      })\n    })\n  }\n\n  async [_retrieveSpecName] (spec) {\n    // if it's just @'' then we reload whatever's there, or get latest\n    // if it's an explicit tag, we need to install that specific tag version\n    const isTag = spec.rawSpec && spec.type === 'tag'\n\n    if (spec.name && !isTag) {\n      return spec\n    }\n\n    const mani = await pacote.manifest(spec, { ...this.options })\n    // if it's a tag type, then we need to run it down to an actual version\n    if (isTag) {\n      return npa(`${mani.name}@${mani.version}`)\n    }\n\n    spec.name = mani.name\n    return spec\n  }\n\n  async [_updateFilePath] (spec) {\n    if (spec.type === 'file') {\n      return this[_getRelpathSpec](spec, spec.fetchSpec)\n    }\n\n    return spec\n  }\n\n  async [_followSymlinkPath] (spec) {\n    if (spec.type === 'directory') {\n      const real = await (\n        realpath(spec.fetchSpec, this[_rpcache], this[_stcache])\n          // TODO: create synthetic test case to simulate realpath failure\n          .catch(/* istanbul ignore next */() => null)\n      )\n\n      return this[_getRelpathSpec](spec, real)\n    }\n    return spec\n  }\n\n  [_getRelpathSpec] (spec, filepath) {\n    /* istanbul ignore else - should also be covered by realpath failure */\n    if (filepath) {\n      const { name } = spec\n      const tree = this.idealTree.target\n      spec = npa(`file:${relpath(tree.path, filepath)}`, tree.path)\n      spec.name = name\n    }\n    return spec\n  }\n\n  // TODO: provide a way to fix bundled deps by exposing metadata about\n  // what's in the bundle at each published manifest.  Without that, we\n  // can't possibly fix bundled deps without breaking a ton of other stuff,\n  // and leaving the user subject to getting it overwritten later anyway.\n  async [_queueVulnDependents] (options) {\n    for (const vuln of this.auditReport.values()) {\n      for (const node of vuln.nodes) {\n        const bundler = node.getBundler()\n\n        // XXX this belongs in the audit report itself, not here.\n        // We shouldn't even get these things here, and they shouldn't\n        // be printed by npm-audit-report as if they can be fixed, because\n        // they can't.\n        if (bundler) {\n          log.warn(`audit fix ${node.name}@${node.version}`,\n            `${node.location}\\nis a bundled dependency of\\n${\n            bundler.name}@${bundler.version} at ${bundler.location}\\n` +\n            'It cannot be fixed automatically.\\n' +\n            `Check for updates to the ${bundler.name} package.`)\n          continue\n        }\n\n        for (const edge of node.edgesIn) {\n          this.addTracker('idealTree', edge.from.name, edge.from.location)\n          this[_depsQueue].push(edge.from)\n        }\n      }\n    }\n\n    // note any that can't be fixed at the root level without --force\n    // if there's a fix, we use that.  otherwise, the user has to remove it,\n    // find a different thing, fix the upstream, etc.\n    //\n    // XXX: how to handle top nodes that aren't the root?  Maybe the report\n    // just tells the user to cd into that directory and fix it?\n    if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {\n      options.add = options.add || []\n      options.rm = options.rm || []\n      const nodesTouched = new Set()\n      for (const [name, topVuln] of this.auditReport.topVulns.entries()) {\n        const {\n          simpleRange,\n          topNodes,\n          fixAvailable,\n        } = topVuln\n        for (const node of topNodes) {\n          if (!node.isProjectRoot && !node.isWorkspace) {\n            // not something we're going to fix, sorry.  have to cd into\n            // that directory and fix it yourself.\n            log.warn('audit', 'Manual fix required in linked project ' +\n              `at ./${node.location} for ${name}@${simpleRange}.\\n` +\n              `'cd ./${node.location}' and run 'npm audit' for details.`)\n            continue\n          }\n\n          if (!fixAvailable) {\n            log.warn('audit', `No fix available for ${name}@${simpleRange}`)\n            continue\n          }\n\n          const { isSemVerMajor, version } = fixAvailable\n          const breakingMessage = isSemVerMajor\n            ? 'a SemVer major change'\n            : 'outside your stated dependency range'\n          log.warn('audit', `Updating ${name} to ${version},` +\n            `which is ${breakingMessage}.`)\n\n          await this[_add](node, { add: [`${name}@${version}`] })\n          nodesTouched.add(node)\n        }\n      }\n      for (const node of nodesTouched) {\n        node.package = node.package\n      }\n    }\n  }\n\n  [_isVulnerable] (node) {\n    return this.auditReport && this.auditReport.isVulnerable(node)\n  }\n\n  [_avoidRange] (name) {\n    if (!this.auditReport) {\n      return null\n    }\n    const vuln = this.auditReport.get(name)\n    if (!vuln) {\n      return null\n    }\n    return vuln.range\n  }\n\n  [_queueNamedUpdates] () {\n    // ignore top nodes, since they are not loaded the same way, and\n    // probably have their own project associated with them.\n\n    // for every node with one of the names on the list, we add its\n    // dependents to the queue to be evaluated.  in buildDepStep,\n    // anything on the update names list will get refreshed, even if\n    // it isn't a problem.\n\n    // XXX this could be faster by doing a series of inventory.query('name')\n    // calls rather than walking over everything in the tree.\n    const set = this.idealTree.inventory\n      .filter(n => this[_shouldUpdateNode](n))\n    // XXX add any invalid edgesOut to the queue\n    for (const node of set) {\n      for (const edge of node.edgesIn) {\n        this.addTracker('idealTree', edge.from.name, edge.from.location)\n        this[_depsQueue].push(edge.from)\n      }\n    }\n  }\n\n  [_shouldUpdateNode] (node) {\n    return this[_updateNames].includes(node.name) &&\n      !node.isTop &&\n      !node.inDepBundle &&\n      !node.inShrinkwrap\n  }\n\n  async [_inflateAncientLockfile] () {\n    const { meta, inventory } = this.idealTree\n    const ancient = meta.ancientLockfile\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2)\n\n    if (inventory.size === 0 || !ancient && !old) {\n      return\n    }\n\n    // if the lockfile is from node v5 or earlier, then we'll have to reload\n    // all the manifests of everything we encounter.  this is costly, but at\n    // least it's just a one-time hit.\n    process.emit('time', 'idealTree:inflate')\n\n    // don't warn if we're not gonna actually write it back anyway.\n    const heading = ancient ? 'ancient lockfile' : 'old lockfile'\n    if (ancient || !this.options.lockfileVersion ||\n        this.options.lockfileVersion >= defaultLockfileVersion) {\n      log.warn(heading,\n        `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`)\n    }\n\n    this.addTracker('idealTree:inflate')\n    const queue = []\n    for (const node of inventory.values()) {\n      if (node.isProjectRoot) {\n        continue\n      }\n\n      queue.push(async () => {\n        log.silly('inflate', node.location)\n        const { resolved, version, path, name, location, integrity } = node\n        // don't try to hit the registry for linked deps\n        const useResolved = resolved && (\n          !version || resolved.startsWith('file:')\n        )\n        const id = useResolved ? resolved\n          : version || `file:${node.path}`\n        const spec = npa.resolve(name, id, dirname(path))\n        const t = `idealTree:inflate:${location}`\n        this.addTracker(t)\n        await pacote.manifest(spec, {\n          ...this.options,\n          resolved: resolved,\n          integrity: integrity,\n          fullMetadata: false,\n        }).then(mani => {\n          node.package = { ...mani, _id: `${mani.name}@${mani.version}` }\n        }).catch((er) => {\n          const warning = `Could not fetch metadata for ${name}@${id}`\n          log.warn(heading, warning, er)\n        })\n        this.finishTracker(t)\n      })\n    }\n    await promiseCallLimit(queue)\n\n    // have to re-calc dep flags, because the nodes don't have edges\n    // until their packages get assigned, so everything looks extraneous\n    calcDepFlags(this.idealTree)\n\n    // yes, yes, this isn't the \"original\" version, but now that it's been\n    // upgraded, we need to make sure we don't do the work to upgrade it\n    // again, since it's now as new as can be.\n    meta.originalLockfileVersion = defaultLockfileVersion\n    this.finishTracker('idealTree:inflate')\n    process.emit('timeEnd', 'idealTree:inflate')\n  }\n\n  // at this point we have a virtual tree with the actual root node's\n  // package deps, which may be partly or entirely incomplete, invalid\n  // or extraneous.\n  [_buildDeps] () {\n    process.emit('time', 'idealTree:buildDeps')\n    const tree = this.idealTree.target\n    tree.assertRootOverrides()\n    this[_depsQueue].push(tree)\n    // XXX also push anything that depends on a node with a name\n    // in the override list\n    log.silly('idealTree', 'buildDeps')\n    this.addTracker('idealTree', tree.name, '')\n    return this[_buildDepStep]()\n      .then(() => process.emit('timeEnd', 'idealTree:buildDeps'))\n  }\n\n  async [_buildDepStep] () {\n    // removes tracker of previous dependency in the queue\n    if (this[_currentDep]) {\n      const { location, name } = this[_currentDep]\n      process.emit('timeEnd', `idealTree:${location || '#root'}`)\n      this.finishTracker('idealTree', name, location)\n      this[_currentDep] = null\n    }\n\n    if (!this[_depsQueue].length) {\n      return this[_resolveLinks]()\n    }\n\n    // sort physically shallower deps up to the front of the queue,\n    // because they'll affect things deeper in, then alphabetical\n    this[_depsQueue].sort((a, b) =>\n      (a.depth - b.depth) || localeCompare(a.path, b.path))\n\n    const node = this[_depsQueue].shift()\n    const bd = node.package.bundleDependencies\n    const hasBundle = bd && Array.isArray(bd) && bd.length\n    const { hasShrinkwrap } = node\n\n    // if the node was already visited, or has since been removed from the\n    // tree, skip over it and process the rest of the queue.  If a node has\n    // a shrinkwrap, also skip it, because it's going to get its deps\n    // satisfied by whatever's in that file anyway.\n    if (this[_depsSeen].has(node) ||\n        node.root !== this.idealTree ||\n        hasShrinkwrap && !this[_complete]) {\n      return this[_buildDepStep]()\n    }\n\n    this[_depsSeen].add(node)\n    this[_currentDep] = node\n    process.emit('time', `idealTree:${node.location || '#root'}`)\n\n    // if we're loading a _complete_ ideal tree, for a --package-lock-only\n    // installation for example, we have to crack open the tarball and\n    // look inside if it has bundle deps or shrinkwraps.  note that this is\n    // not necessary during a reification, because we just update the\n    // ideal tree by reading bundles/shrinkwraps in place.\n    // Don't bother if the node is from the actual tree and hasn't\n    // been resolved, because we can't fetch it anyway, could be anything!\n    const crackOpen = this[_complete] &&\n      node !== this.idealTree &&\n      node.resolved &&\n      (hasBundle || hasShrinkwrap)\n    if (crackOpen) {\n      const Arborist = this.constructor\n      const opt = { ...this.options }\n      await cacache.tmp.withTmp(this.cache, opt, async path => {\n        await pacote.extract(node.resolved, path, {\n          ...opt,\n          resolved: node.resolved,\n          integrity: node.integrity,\n        })\n\n        if (hasShrinkwrap) {\n          await new Arborist({ ...this.options, path })\n            .loadVirtual({ root: node })\n        }\n\n        if (hasBundle) {\n          await new Arborist({ ...this.options, path })\n            .loadActual({ root: node, ignoreMissing: true })\n        }\n      })\n    }\n\n    // if any deps are missing or invalid, then we fetch the manifest for\n    // the thing we want, and build a new dep node from that.\n    // Then, find the ideal placement for that node.  The ideal placement\n    // searches from the node's deps (or parent deps in the case of non-root\n    // peer deps), and walks up the tree until it finds the highest spot\n    // where it doesn't cause any conflicts.\n    //\n    // A conflict can be:\n    // - A node by that name already exists at that location.\n    // - The parent has a peer dep on that name\n    // - One of the node's peer deps conflicts at that location, unless the\n    //   peer dep is met by a node at that location, which is fine.\n    //\n    // If we create a new node, then build its ideal deps as well.\n    //\n    // Note: this is the same \"maximally naive\" deduping tree-building\n    // algorithm that npm has used since v3.  In a case like this:\n    //\n    // root -> (a@1, b@1||2)\n    // a -> (b@1)\n    //\n    // You'll end up with a tree like this:\n    //\n    // root\n    // +-- a@1\n    // |   +-- b@1\n    // +-- b@2\n    //\n    // rather than this, more deduped, but just as correct tree:\n    //\n    // root\n    // +-- a@1\n    // +-- b@1\n    //\n    // Another way to look at it is that this algorithm favors getting higher\n    // version deps at higher levels in the tree, even if that reduces\n    // potential deduplication.\n    //\n    // Set `preferDedupe: true` in the options to replace the shallower\n    // dep if allowed.\n\n    const tasks = []\n    const peerSource = this[_peerSetSource].get(node) || node\n    for (const edge of this[_problemEdges](node)) {\n      if (edge.peerConflicted) {\n        continue\n      }\n\n      // peerSetSource is only relevant when we have a peerEntryEdge\n      // otherwise we're setting regular non-peer deps as if they have\n      // a virtual root of whatever brought in THIS node.\n      // so we VR the node itself if the edge is not a peer\n      const source = edge.peer ? peerSource : node\n\n      const virtualRoot = this[_virtualRoot](source, true)\n      // reuse virtual root if we already have one, but don't\n      // try to do the override ahead of time, since we MAY be able\n      // to create a more correct tree than the virtual root could.\n      const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name)\n      const vrDep = vrEdge && vrEdge.valid && vrEdge.to\n      // only re-use the virtualRoot if it's a peer edge we're placing.\n      // otherwise, we end up in situations where we override peer deps that\n      // we could have otherwise found homes for.  Eg:\n      // xy -> (x, y)\n      // x -> PEER(z@1)\n      // y -> PEER(z@2)\n      // If xy is a dependency, we can resolve this like:\n      // project\n      // +-- xy\n      // |   +-- y\n      // |   +-- z@2\n      // +-- x\n      // +-- z@1\n      // But if x and y are loaded in the same virtual root, then they will\n      // be forced to agree on a version of z.\n      const required = new Set([edge.from])\n      const parent = edge.peer ? virtualRoot : null\n      const dep = vrDep && vrDep.satisfies(edge) ? vrDep\n        : await this[_nodeFromEdge](edge, parent, null, required)\n\n      /* istanbul ignore next */\n      debug(() => {\n        if (!dep) {\n          throw new Error('no dep??')\n        }\n      })\n\n      tasks.push({ edge, dep })\n    }\n\n    const placeDeps = tasks\n      .sort((a, b) => localeCompare(a.edge.name, b.edge.name))\n      .map(({ edge, dep }) => new PlaceDep({\n        edge,\n        dep,\n\n        explicitRequest: this[_explicitRequests].has(edge),\n        updateNames: this[_updateNames],\n        auditReport: this.auditReport,\n        force: this[_force],\n        preferDedupe: this[_preferDedupe],\n        legacyBundling: this[_legacyBundling],\n        strictPeerDeps: this[_strictPeerDeps],\n        legacyPeerDeps: this.legacyPeerDeps,\n        globalStyle: this[_globalStyle],\n      }))\n\n    const promises = []\n    for (const pd of placeDeps) {\n      // placing a dep is actually a tree of placing the dep itself\n      // and all of its peer group that aren't already met by the tree\n      depth({\n        tree: pd,\n        getChildren: pd => pd.children,\n        visit: pd => {\n          const { placed, edge, canPlace: cpd } = pd\n          // if we didn't place anything, nothing to do here\n          if (!placed) {\n            return\n          }\n\n          // we placed something, that means we changed the tree\n          if (placed.errors.length) {\n            this[_loadFailures].add(placed)\n          }\n          this[_mutateTree] = true\n          if (cpd.canPlaceSelf === OK) {\n            for (const edgeIn of placed.edgesIn) {\n              if (edgeIn === edge) {\n                continue\n              }\n              const { from, valid, peerConflicted } = edgeIn\n              if (!peerConflicted && !valid && !this[_depsSeen].has(from)) {\n                this.addTracker('idealTree', from.name, from.location)\n                this[_depsQueue].push(edgeIn.from)\n              }\n            }\n          } else {\n            /* istanbul ignore else - should be only OK or REPLACE here */\n            if (cpd.canPlaceSelf === REPLACE) {\n              // this may also create some invalid edges, for example if we're\n              // intentionally causing something to get nested which was\n              // previously placed in this location.\n              for (const edgeIn of placed.edgesIn) {\n                if (edgeIn === edge) {\n                  continue\n                }\n\n                const { valid, peerConflicted } = edgeIn\n                if (!valid && !peerConflicted) {\n                  // if it's already been visited, we have to re-visit\n                  // otherwise, just enqueue normally.\n                  this[_depsSeen].delete(edgeIn.from)\n                  this[_depsQueue].push(edgeIn.from)\n                }\n              }\n            }\n          }\n\n          /* istanbul ignore if - should be impossible */\n          if (cpd.canPlaceSelf === CONFLICT) {\n            debug(() => {\n              const er = new Error('placed with canPlaceSelf=CONFLICT')\n              throw Object.assign(er, { placeDep: pd })\n            })\n            return\n          }\n\n          // lastly, also check for the missing deps of the node we placed,\n          // and any holes created by pruning out conflicted peer sets.\n          this[_depsQueue].push(placed)\n          for (const dep of pd.needEvaluation) {\n            this[_depsSeen].delete(dep)\n            this[_depsQueue].push(dep)\n          }\n\n          // pre-fetch any problem edges, since we'll need these soon\n          // if it fails at this point, though, dont' worry because it\n          // may well be an optional dep that has gone missing.  it'll\n          // fail later anyway.\n          const from = fromPath(placed)\n          promises.push(...this[_problemEdges](placed).map(e =>\n            this[_fetchManifest](npa.resolve(e.name, e.spec, from))\n              .catch(er => null)))\n        },\n      })\n    }\n\n    for (const { to } of node.edgesOut.values()) {\n      if (to && to.isLink && to.target) {\n        this[_linkNodes].add(to)\n      }\n    }\n\n    await Promise.all(promises)\n    return this[_buildDepStep]()\n  }\n\n  // loads a node from an edge, and then loads its peer deps (and their\n  // peer deps, on down the line) into a virtual root parent.\n  async [_nodeFromEdge] (edge, parent_, secondEdge, required) {\n    // create a virtual root node with the same deps as the node that\n    // is requesting this one, so that we can get all the peer deps in\n    // a context where they're likely to be resolvable.\n    // Note that the virtual root will also have virtual copies of the\n    // targets of any child Links, so that they resolve appropriately.\n    const parent = parent_ || this[_virtualRoot](edge.from)\n\n    const spec = npa.resolve(edge.name, edge.spec, edge.from.path)\n    const first = await this[_nodeFromSpec](edge.name, spec, parent, edge)\n\n    // we might have a case where the parent has a peer dependency on\n    // `foo@*` which resolves to v2, but another dep in the set has a\n    // peerDependency on `foo@1`.  In that case, if we force it to be v2,\n    // we're unnecessarily triggering an ERESOLVE.\n    // If we have a second edge to worry about, and it's not satisfied\n    // by the first node, try a second and see if that satisfies the\n    // original edge here.\n    const spec2 = secondEdge && npa.resolve(\n      edge.name,\n      secondEdge.spec,\n      secondEdge.from.path\n    )\n    const second = secondEdge && !secondEdge.valid\n      ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge)\n      : null\n\n    // pick the second one if they're both happy with that, otherwise first\n    const node = second && edge.valid ? second : first\n    // ensure the one we want is the one that's placed\n    node.parent = parent\n\n    if (required.has(edge.from) && edge.type !== 'peerOptional' ||\n        secondEdge && (\n          required.has(secondEdge.from) && secondEdge.type !== 'peerOptional')) {\n      required.add(node)\n    }\n\n    // keep track of the thing that caused this node to be included.\n    const src = parent.sourceReference\n    this[_peerSetSource].set(node, src)\n\n    // do not load the peers along with the set if this is a global top pkg\n    // otherwise we'll be tempted to put peers as other top-level installed\n    // things, potentially clobbering what's there already, which is not\n    // what we want.  the missing edges will be picked up on the next pass.\n    if (this[_global] && edge.from.isProjectRoot) {\n      return node\n    }\n\n    // otherwise, we have to make sure that our peers can go along with us.\n    return this[_loadPeerSet](node, required)\n  }\n\n  [_virtualRoot] (node, reuse = false) {\n    if (reuse && this[_virtualRoots].has(node)) {\n      return this[_virtualRoots].get(node)\n    }\n\n    const vr = new Node({\n      path: node.realpath,\n      sourceReference: node,\n      legacyPeerDeps: this.legacyPeerDeps,\n      overrides: node.overrides,\n    })\n\n    // also need to set up any targets from any link deps, so that\n    // they are properly reflected in the virtual environment\n    for (const child of node.children.values()) {\n      if (child.isLink) {\n        new Node({\n          path: child.realpath,\n          sourceReference: child.target,\n          root: vr,\n        })\n      }\n    }\n\n    this[_virtualRoots].set(node, vr)\n    return vr\n  }\n\n  [_problemEdges] (node) {\n    // skip over any bundled deps, they're not our problem.\n    // Note that this WILL fetch bundled meta-deps which are also dependencies\n    // but not listed as bundled deps.  When reifying, we first unpack any\n    // nodes that have bundleDependencies, then do a loadActual on them, move\n    // the nodes into the ideal tree, and then prune.  So, fetching those\n    // possibly-bundled meta-deps at this point doesn't cause any worse\n    // problems than a few unnecessary packument fetches.\n\n    // also skip over any nodes in the tree that failed to load, since those\n    // will crash the install later on anyway.\n    const bd = node.isProjectRoot || node.isWorkspace ? null\n      : node.package.bundleDependencies\n    const bundled = new Set(bd || [])\n\n    return [...node.edgesOut.values()]\n      .filter(edge => {\n        // If it's included in a bundle, we take whatever is specified.\n        if (bundled.has(edge.name)) {\n          return false\n        }\n\n        // If it's already been logged as a load failure, skip it.\n        if (edge.to && this[_loadFailures].has(edge.to)) {\n          return false\n        }\n\n        // If it's shrinkwrapped, we use what the shrinkwap wants.\n        if (edge.to && edge.to.inShrinkwrap) {\n          return false\n        }\n\n        // If the edge has no destination, that's a problem, unless\n        // if it's peerOptional and not explicitly requested.\n        if (!edge.to) {\n          return edge.type !== 'peerOptional' ||\n            this[_explicitRequests].has(edge)\n        }\n\n        // If the edge has an error, there's a problem.\n        if (!edge.valid) {\n          return true\n        }\n\n        // If the edge is a workspace, and it's valid, leave it alone\n        if (edge.to.isWorkspace) {\n          return false\n        }\n\n        // user explicitly asked to update this package by name, problem\n        if (this[_updateNames].includes(edge.name)) {\n          return true\n        }\n\n        // fixing a security vulnerability with this package, problem\n        if (this[_isVulnerable](edge.to)) {\n          return true\n        }\n\n        // user has explicitly asked to install this package, problem\n        if (this[_explicitRequests].has(edge)) {\n          return true\n        }\n\n        // No problems!\n        return false\n      })\n  }\n\n  async [_fetchManifest] (spec) {\n    const options = {\n      ...this.options,\n      avoid: this[_avoidRange](spec.name),\n    }\n    // get the intended spec and stored metadata from yarn.lock file,\n    // if available and valid.\n    spec = this.idealTree.meta.checkYarnLock(spec, options)\n\n    if (this[_manifests].has(spec.raw)) {\n      return this[_manifests].get(spec.raw)\n    } else {\n      log.silly('fetch manifest', spec.raw)\n      const p = pacote.manifest(spec, options)\n        .then(mani => {\n          this[_manifests].set(spec.raw, mani)\n          return mani\n        })\n      this[_manifests].set(spec.raw, p)\n      return p\n    }\n  }\n\n  [_nodeFromSpec] (name, spec, parent, edge) {\n    // pacote will slap integrity on its options, so we have to clone\n    // the object so it doesn't get mutated.\n    // Don't bother to load the manifest for link deps, because the target\n    // might be within another package that doesn't exist yet.\n    const { legacyPeerDeps } = this\n\n    // spec is a directory, link it\n    if (spec.type === 'directory') {\n      return this[_linkFromSpec](name, spec, parent, edge)\n    }\n\n    // if the spec matches a workspace name, then see if the workspace node will\n    // satisfy the edge. if it does, we return the workspace node to make sure it\n    // takes priority.\n    if (this.idealTree.workspaces && this.idealTree.workspaces.has(spec.name)) {\n      const existingNode = this.idealTree.edgesOut.get(spec.name).to\n      if (existingNode && existingNode.isWorkspace && existingNode.satisfies(edge)) {\n        return edge.to\n      }\n    }\n\n    // spec isn't a directory, and either isn't a workspace or the workspace we have\n    // doesn't satisfy the edge. try to fetch a manifest and build a node from that.\n    return this[_fetchManifest](spec)\n      .then(pkg => new Node({ name, pkg, parent, legacyPeerDeps }), error => {\n        error.requiredBy = edge.from.location || '.'\n\n        // failed to load the spec, either because of enotarget or\n        // fetch failure of some other sort.  save it so we can verify\n        // later that it's optional, otherwise the error is fatal.\n        const n = new Node({\n          name,\n          parent,\n          error,\n          legacyPeerDeps,\n        })\n        this[_loadFailures].add(n)\n        return n\n      })\n  }\n\n  [_linkFromSpec] (name, spec, parent, edge) {\n    const realpath = spec.fetchSpec\n    const { legacyPeerDeps } = this\n    return rpj(realpath + '/package.json').catch(() => ({})).then(pkg => {\n      const link = new Link({ name, parent, realpath, pkg, legacyPeerDeps })\n      this[_linkNodes].add(link)\n      return link\n    })\n  }\n\n  // load all peer deps and meta-peer deps into the node's parent\n  // At the end of this, the node's peer-type outward edges are all\n  // resolved, and so are all of theirs, but other dep types are not.\n  // We prefer to get peer deps that meet the requiring node's dependency,\n  // if possible, since that almost certainly works (since that package was\n  // developed with this set of deps) and will typically be more restrictive.\n  // Note that the peers in the set can conflict either with each other,\n  // or with a direct dependency from the virtual root parent!  In strict\n  // mode, this is always an error.  In force mode, it never is, and we\n  // prefer the parent's non-peer dep over a peer dep, or the version that\n  // gets placed first.  In non-strict mode, we behave strictly if the\n  // virtual root is based on the root project, and allow non-peer parent\n  // deps to override, but throw if no preference can be determined.\n  async [_loadPeerSet] (node, required) {\n    const peerEdges = [...node.edgesOut.values()]\n      // we typically only install non-optional peers, but we have to\n      // factor them into the peerSet so that we can avoid conflicts\n      .filter(e => e.peer && !(e.valid && e.to))\n      .sort(({ name: a }, { name: b }) => localeCompare(a, b))\n\n    for (const edge of peerEdges) {\n      // already placed this one, and we're happy with it.\n      if (edge.valid && edge.to) {\n        continue\n      }\n\n      const parentEdge = node.parent.edgesOut.get(edge.name)\n      const { isProjectRoot, isWorkspace } = node.parent.sourceReference\n      const isMine = isProjectRoot || isWorkspace\n      const conflictOK = this[_force] || !isMine && !this[_strictPeerDeps]\n\n      if (!edge.to) {\n        if (!parentEdge) {\n          // easy, just put the thing there\n          await this[_nodeFromEdge](edge, node.parent, null, required)\n          continue\n        } else {\n          // if the parent's edge is very broad like >=1, and the edge in\n          // question is something like 1.x, then we want to get a 1.x, not\n          // a 2.x.  pass along the child edge as an advisory guideline.\n          // if the parent edge doesn't satisfy the child edge, and the\n          // child edge doesn't satisfy the parent edge, then we have\n          // a conflict.  this is always a problem in strict mode, never\n          // in force mode, and a problem in non-strict mode if this isn't\n          // on behalf of our project.  in all such cases, we warn at least.\n          const dep = await this[_nodeFromEdge](\n            parentEdge,\n            node.parent,\n            edge,\n            required\n          )\n\n          // hooray! that worked!\n          if (edge.valid) {\n            continue\n          }\n\n          // allow it.  either we're overriding, or it's not something\n          // that will be installed by default anyway, and we'll fail when\n          // we get to the point where we need to, if we need to.\n          if (conflictOK || !required.has(dep)) {\n            edge.peerConflicted = true\n            continue\n          }\n\n          // problem\n          this[_failPeerConflict](edge, parentEdge)\n        }\n      }\n\n      // There is something present already, and we're not happy about it\n      // See if the thing we WOULD be happy with is also going to satisfy\n      // the other dependents on the current node.\n      const current = edge.to\n      const dep = await this[_nodeFromEdge](edge, null, null, required)\n      if (dep.canReplace(current)) {\n        await this[_nodeFromEdge](edge, node.parent, null, required)\n        continue\n      }\n\n      // at this point we know that there is a dep there, and\n      // we don't like it.  always fail strictly, always allow forcibly or\n      // in non-strict mode if it's not our fault.  don't warn here, because\n      // we are going to warn again when we place the deps, if we end up\n      // overriding for something else.  If the thing that has this dep\n      // isn't also required, then there's a good chance we won't need it,\n      // so allow it for now and let it conflict if it turns out to actually\n      // be necessary for the installation.\n      if (conflictOK || !required.has(edge.from)) {\n        continue\n      }\n\n      // ok, it's the root, or we're in unforced strict mode, so this is bad\n      this[_failPeerConflict](edge, parentEdge)\n    }\n    return node\n  }\n\n  [_failPeerConflict] (edge, currentEdge) {\n    const expl = this[_explainPeerConflict](edge, currentEdge)\n    throw Object.assign(new Error('unable to resolve dependency tree'), expl)\n  }\n\n  [_explainPeerConflict] (edge, currentEdge) {\n    const node = edge.from\n    const curNode = node.resolve(edge.name)\n    const current = curNode.explain()\n    return {\n      code: 'ERESOLVE',\n      current,\n      // it SHOULD be impossible to get here without a current node in place,\n      // but this at least gives us something report on when bugs creep into\n      // the tree handling logic.\n      currentEdge: currentEdge ? currentEdge.explain() : null,\n      edge: edge.explain(),\n      strictPeerDeps: this[_strictPeerDeps],\n      force: this[_force],\n    }\n  }\n\n  // go through all the links in the this[_linkNodes] set\n  // for each one:\n  // - if outside the root, ignore it, assume it's fine, it's not our problem\n  // - if a node in the tree already, assign the target to that node.\n  // - if a path under an existing node, then assign that as the fsParent,\n  //   and add it to the _depsQueue\n  //\n  // call buildDepStep if anything was added to the queue, otherwise we're done\n  [_resolveLinks] () {\n    for (const link of this[_linkNodes]) {\n      this[_linkNodes].delete(link)\n\n      // link we never ended up placing, skip it\n      if (link.root !== this.idealTree) {\n        continue\n      }\n\n      const tree = this.idealTree.target\n      const external = !link.target.isDescendantOf(tree)\n\n      // outside the root, somebody else's problem, ignore it\n      if (external && !this[_follow]) {\n        continue\n      }\n\n      // didn't find a parent for it or it has not been seen yet\n      // so go ahead and process it.\n      const unseenLink = (link.target.parent || link.target.fsParent) &&\n        !this[_depsSeen].has(link.target)\n\n      if (this[_follow] &&\n          !link.target.parent &&\n          !link.target.fsParent ||\n          unseenLink) {\n        this.addTracker('idealTree', link.target.name, link.target.location)\n        this[_depsQueue].push(link.target)\n      }\n    }\n\n    if (this[_depsQueue].length) {\n      return this[_buildDepStep]()\n    }\n  }\n\n  [_fixDepFlags] () {\n    process.emit('time', 'idealTree:fixDepFlags')\n    const metaFromDisk = this.idealTree.meta.loadedFromDisk\n    const flagsSuspect = this[_flagsSuspect]\n    const mutateTree = this[_mutateTree]\n    // if the options set prune:false, then we don't prune, but we still\n    // mark the extraneous items in the tree if we modified it at all.\n    // If we did no modifications, we just iterate over the extraneous nodes.\n    // if we started with an empty tree, then the dep flags are already\n    // all set to true, and there can be nothing extraneous, so there's\n    // nothing to prune, because we built it from scratch.  if we didn't\n    // add or remove anything, then also nothing to do.\n    if (metaFromDisk && mutateTree) {\n      resetDepFlags(this.idealTree)\n    }\n\n    // update all the dev/optional/etc flags in the tree\n    // either we started with a fresh tree, or we\n    // reset all the flags to find the extraneous nodes.\n    //\n    // if we started from a blank slate, or changed something, then\n    // the dep flags will be all set to true.\n    if (!metaFromDisk || mutateTree) {\n      calcDepFlags(this.idealTree)\n    } else {\n      // otherwise just unset all the flags on the root node\n      // since they will sometimes have the default value\n      this.idealTree.extraneous = false\n      this.idealTree.dev = false\n      this.idealTree.optional = false\n      this.idealTree.devOptional = false\n      this.idealTree.peer = false\n    }\n\n    // at this point, any node marked as extraneous should be pruned.\n    // if we started from a shrinkwrap, and then added/removed something,\n    // then the tree is suspect.  Prune what is marked as extraneous.\n    // otherwise, don't bother.\n    const needPrune = metaFromDisk && (mutateTree || flagsSuspect)\n    if (this[_prune] && needPrune) {\n      this[_idealTreePrune]()\n    }\n\n    process.emit('timeEnd', 'idealTree:fixDepFlags')\n  }\n\n  [_idealTreePrune] () {\n    for (const node of this.idealTree.inventory.filter(n => n.extraneous)) {\n      node.parent = null\n    }\n  }\n\n  [_pruneFailedOptional] () {\n    for (const node of this[_loadFailures]) {\n      if (!node.optional) {\n        throw node.errors[0]\n      }\n\n      const set = optionalSet(node)\n      for (const node of set) {\n        node.parent = null\n      }\n    }\n  }\n}\n","// look up the realpath, but cache stats to minimize overhead\n// If the parent folder is in  the realpath cache, then we just\n// lstat the child, since there's no need to do a full realpath\n// This is not a separate module, and is much simpler than Node's\n// built-in fs.realpath, because we only care about symbolic links,\n// so we can handle many fewer edge cases.\n\nconst fs = require('fs')\nconst promisify = require('util').promisify\nconst readlink = promisify(fs.readlink)\nconst lstat = promisify(fs.lstat)\nconst { resolve, basename, dirname } = require('path')\n\nconst realpathCached = (path, rpcache, stcache, depth) => {\n  // just a safety against extremely deep eloops\n  /* istanbul ignore next */\n  if (depth > 2000) {\n    throw eloop(path)\n  }\n\n  path = resolve(path)\n  if (rpcache.has(path)) {\n    return Promise.resolve(rpcache.get(path))\n  }\n\n  const dir = dirname(path)\n  const base = basename(path)\n\n  if (base && rpcache.has(dir)) {\n    return realpathChild(dir, base, rpcache, stcache, depth)\n  }\n\n  // if it's the root, then we know it's real\n  if (!base) {\n    rpcache.set(dir, dir)\n    return Promise.resolve(dir)\n  }\n\n  // the parent, what is that?\n  // find out, and then come back.\n  return realpathCached(dir, rpcache, stcache, depth + 1).then(() =>\n    realpathCached(path, rpcache, stcache, depth + 1))\n}\n\nconst lstatCached = (path, stcache) => {\n  if (stcache.has(path)) {\n    return Promise.resolve(stcache.get(path))\n  }\n\n  const p = lstat(path).then(st => {\n    stcache.set(path, st)\n    return st\n  })\n  stcache.set(path, p)\n  return p\n}\n\n// This is a slight fib, as it doesn't actually occur during a stat syscall.\n// But file systems are giant piles of lies, so whatever.\nconst eloop = path =>\n  Object.assign(new Error(\n    `ELOOP: too many symbolic links encountered, stat '${path}'`), {\n    errno: -62,\n    syscall: 'stat',\n    code: 'ELOOP',\n    path: path,\n  })\n\nconst realpathChild = (dir, base, rpcache, stcache, depth) => {\n  const realdir = rpcache.get(dir)\n  // that unpossible\n  /* istanbul ignore next */\n  if (typeof realdir === 'undefined') {\n    throw new Error('in realpathChild without parent being in realpath cache')\n  }\n\n  const realish = resolve(realdir, base)\n  return lstatCached(realish, stcache).then(st => {\n    if (!st.isSymbolicLink()) {\n      rpcache.set(resolve(dir, base), realish)\n      return realish\n    }\n\n    return readlink(realish).then(target => {\n      const resolved = resolve(realdir, target)\n      if (realish === resolved) {\n        throw eloop(realish)\n      }\n\n      return realpathCached(resolved, rpcache, stcache, depth + 1)\n    }).then(real => {\n      rpcache.set(resolve(dir, base), real)\n      return real\n    })\n  })\n}\n\nmodule.exports = realpathCached\n","const debug = require('./debug.js')\n\nconst checkTree = (tree, checkUnreachable = true) => {\n  const log = [['START TREE CHECK', tree.path]]\n\n  // this can only happen in tests where we have a \"tree\" object\n  // that isn't actually a tree.\n  if (!tree.root || !tree.root.inventory) {\n    return tree\n  }\n\n  const { inventory } = tree.root\n  const seen = new Set()\n  const check = (node, via = tree, viaType = 'self') => {\n    log.push([\n      'CHECK',\n      node && node.location,\n      via && via.location,\n      viaType,\n      'seen=' + seen.has(node),\n      'promise=' + !!(node && node.then),\n      'root=' + !!(node && node.isRoot),\n    ])\n\n    if (!node || seen.has(node) || node.then) {\n      return\n    }\n\n    seen.add(node)\n\n    if (node.isRoot && node !== tree.root) {\n      throw Object.assign(new Error('double root'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    if (node.root !== tree.root) {\n      throw Object.assign(new Error('node from other root in tree'), {\n        node: node.path,\n        realpath: node.realpath,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        otherRoot: node.root && node.root.path,\n        log,\n      })\n    }\n\n    if (!node.isRoot && node.inventory.size !== 0) {\n      throw Object.assign(new Error('non-root has non-zero inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        inventory: [...node.inventory.values()].map(node =>\n          [node.path, node.location]),\n        log,\n      })\n    }\n\n    if (!node.isRoot && !inventory.has(node) && !node.dummy) {\n      throw Object.assign(new Error('not in inventory'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    const devEdges = [...node.edgesOut.values()].filter(e => e.dev)\n    if (!node.isTop && devEdges.length) {\n      throw Object.assign(new Error('dev edges on non-top node'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        devEdges: devEdges.map(e => [e.type, e.name, e.spec, e.error]),\n        log,\n      })\n    }\n\n    if (node.path === tree.root.path && node !== tree.root) {\n      throw Object.assign(new Error('node with same path as root'), {\n        node: node.path,\n        tree: tree.path,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    if (!node.isLink && node.path !== node.realpath) {\n      throw Object.assign(new Error('non-link with mismatched path/realpath'), {\n        node: node.path,\n        tree: tree.path,\n        realpath: node.realpath,\n        root: tree.root.path,\n        via: via.path,\n        viaType,\n        log,\n      })\n    }\n\n    const { parent, fsParent, target } = node\n    check(parent, node, 'parent')\n    check(fsParent, node, 'fsParent')\n    check(target, node, 'target')\n    log.push(['CHILDREN', node.location, ...node.children.keys()])\n    for (const kid of node.children.values()) {\n      check(kid, node, 'children')\n    }\n    for (const kid of node.fsChildren) {\n      check(kid, node, 'fsChildren')\n    }\n    for (const link of node.linksIn) {\n      check(link, node, 'linksIn')\n    }\n    for (const top of node.tops) {\n      check(top, node, 'tops')\n    }\n    log.push(['DONE', node.location])\n  }\n  check(tree)\n  if (checkUnreachable) {\n    for (const node of inventory.values()) {\n      if (!seen.has(node) && node !== tree.root) {\n        throw Object.assign(new Error('unreachable in inventory'), {\n          node: node.path,\n          realpath: node.realpath,\n          location: node.location,\n          root: tree.root.path,\n          tree: tree.path,\n          log,\n        })\n      }\n    }\n  }\n  return tree\n}\n\n// should only ever run this check in debug mode\nmodule.exports = tree => tree\ndebug(() => module.exports = checkTree)\n","// certain assertions we should do only when testing arborist itself, because\n// they are too expensive or aggressive and would break user programs if we\n// miss a situation where they are actually valid.\n//\n// call like this:\n//\n// /* istanbul ignore next - debug check */\n// debug(() => {\n//   if (someExpensiveCheck)\n//     throw new Error('expensive check should have returned false')\n// })\n\n// run in debug mode if explicitly requested, running arborist tests,\n// or working in the arborist project directory.\n\nconst debug = process.env.ARBORIST_DEBUG !== '0' && (\n  process.env.ARBORIST_DEBUG === '1' ||\n  /\\barborist\\b/.test(process.env.NODE_DEBUG || '') ||\n  process.env.npm_package_name === '@npmcli/arborist' &&\n  ['test', 'snap'].includes(process.env.npm_lifecycle_event) ||\n  process.cwd() === require('path').resolve(__dirname, '..')\n)\n\nmodule.exports = debug ? fn => fn() : () => {}\nconst red = process.stderr.isTTY ? msg => `\\x1B[31m${msg}\\x1B[39m` : m => m\nmodule.exports.log = (...msg) => module.exports(() => {\n  const { format } = require('util')\n  const prefix = `\\n${process.pid} ${red(format(msg.shift()))} `\n  msg = (prefix + format(...msg).trim().split('\\n').join(prefix)).trim()\n  console.error(msg)\n})\n","// Internal methods used by buildIdealTree.\n// Answer the question: \"can I put this dep here?\"\n//\n// IMPORTANT: *nothing* in this class should *ever* modify or mutate the tree\n// at all.  The contract here is strictly limited to read operations.  We call\n// this in the process of walking through the ideal tree checking many\n// different potential placement targets for a given node.  If a change is made\n// to the tree along the way, that can cause serious problems!\n//\n// In order to enforce this restriction, in debug mode, canPlaceDep() will\n// snapshot the tree at the start of the process, and then at the end, will\n// verify that it still matches the snapshot, and throw an error if any changes\n// occurred.\n//\n// The algorithm is roughly like this:\n// - check the node itself:\n//   - if there is no version present, and no conflicting edges from target,\n//     OK, provided all peers can be placed at or above the target.\n//   - if the current version matches, KEEP\n//   - if there is an older version present, which can be replaced, then\n//     - if satisfying and preferDedupe? KEEP\n//     - else: REPLACE\n//   - if there is a newer version present, and preferDedupe, REPLACE\n//   - if the version present satisfies the edge, KEEP\n//   - else: CONFLICT\n// - if the node is not in conflict, check each of its peers:\n//   - if the peer can be placed in the target, continue\n//   - else if the peer can be placed in a parent, and there is no other\n//     conflicting version shadowing it, continue\n//   - else CONFLICT\n// - If the peers are not in conflict, return the original node's value\n//\n// An exception to this logic is that if the target is the deepest location\n// that a node can be placed, and the conflicting node can be placed deeper,\n// then we will return REPLACE rather than CONFLICT, and Arborist will queue\n// the replaced node for resolution elsewhere.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst semver = require('semver')\nconst debug = require('./debug.js')\nconst peerEntrySets = require('./peer-entry-sets.js')\nconst deepestNestingTarget = require('./deepest-nesting-target.js')\n\nconst CONFLICT = Symbol('CONFLICT')\nconst OK = Symbol('OK')\nconst REPLACE = Symbol('REPLACE')\nconst KEEP = Symbol('KEEP')\n\nclass CanPlaceDep {\n  // dep is a dep that we're trying to place.  it should already live in\n  // a virtual tree where its peer set is loaded as children of the root.\n  // target is the actual place where we're trying to place this dep\n  // in a node_modules folder.\n  // edge is the edge that we're trying to satisfy with this placement.\n  // parent is the CanPlaceDep object of the entry node when placing a peer.\n  constructor (options) {\n    const {\n      dep,\n      target,\n      edge,\n      preferDedupe,\n      parent = null,\n      peerPath = [],\n      explicitRequest = false,\n    } = options\n\n    debug(() => {\n      if (!dep) {\n        throw new Error('no dep provided to CanPlaceDep')\n      }\n\n      if (!target) {\n        throw new Error('no target provided to CanPlaceDep')\n      }\n\n      if (!edge) {\n        throw new Error('no edge provided to CanPlaceDep')\n      }\n\n      this._treeSnapshot = JSON.stringify([...target.root.inventory.entries()]\n        .map(([loc, { packageName, version, resolved }]) => {\n          return [loc, packageName, version, resolved]\n        }).sort(([a], [b]) => localeCompare(a, b)))\n    })\n\n    // the result of whether we can place it or not\n    this.canPlace = null\n    // if peers conflict, but this one doesn't, then that is useful info\n    this.canPlaceSelf = null\n\n    this.dep = dep\n    this.target = target\n    this.edge = edge\n    this.explicitRequest = explicitRequest\n\n    // preventing cycles when we check peer sets\n    this.peerPath = peerPath\n    // we always prefer to dedupe peers, because they are trying\n    // a bit harder to be singletons.\n    this.preferDedupe = !!preferDedupe || edge.peer\n    this.parent = parent\n    this.children = []\n\n    this.isSource = target === this.peerSetSource\n    this.name = edge.name\n    this.current = target.children.get(this.name)\n    this.targetEdge = target.edgesOut.get(this.name)\n    this.conflicts = new Map()\n\n    // check if this dep was already subject to a peerDep override while\n    // building the peerSet.\n    this.edgeOverride = !dep.satisfies(edge)\n\n    this.canPlace = this.checkCanPlace()\n    if (!this.canPlaceSelf) {\n      this.canPlaceSelf = this.canPlace\n    }\n\n    debug(() => {\n      const treeSnapshot = JSON.stringify([...target.root.inventory.entries()]\n        .map(([loc, { packageName, version, resolved }]) => {\n          return [loc, packageName, version, resolved]\n        }).sort(([a], [b]) => localeCompare(a, b)))\n      /* istanbul ignore if */\n      if (this._treeSnapshot !== treeSnapshot) {\n        throw Object.assign(new Error('tree changed in CanPlaceDep'), {\n          expect: this._treeSnapshot,\n          actual: treeSnapshot,\n        })\n      }\n    })\n  }\n\n  checkCanPlace () {\n    const { target, targetEdge, current, dep } = this\n\n    // if the dep failed to load, we're going to fail the build or\n    // prune it out anyway, so just move forward placing/replacing it.\n    if (dep.errors.length) {\n      return current ? REPLACE : OK\n    }\n\n    // cannot place peers inside their dependents, except for tops\n    if (targetEdge && targetEdge.peer && !target.isTop) {\n      return CONFLICT\n    }\n\n    // skip this test if there's a current node, because we might be able\n    // to dedupe against it anyway\n    if (!current &&\n        targetEdge &&\n        !dep.satisfies(targetEdge) &&\n        targetEdge !== this.edge) {\n      return CONFLICT\n    }\n\n    return current ? this.checkCanPlaceCurrent() : this.checkCanPlaceNoCurrent()\n  }\n\n  // we know that the target has a dep by this name in its node_modules\n  // already.  Can return KEEP, REPLACE, or CONFLICT.\n  checkCanPlaceCurrent () {\n    const { preferDedupe, explicitRequest, current, target, edge, dep } = this\n\n    if (dep.matches(current)) {\n      if (current.satisfies(edge) || this.edgeOverride) {\n        return explicitRequest ? REPLACE : KEEP\n      }\n    }\n\n    const { version: curVer } = current\n    const { version: newVer } = dep\n    const tryReplace = curVer && newVer && semver.gte(newVer, curVer)\n    if (tryReplace && dep.canReplace(current)) {\n      // It's extremely rare that a replaceable node would be a conflict, if\n      // the current one wasn't a conflict, but it is theoretically possible\n      // if peer deps are pinned.  In that case we treat it like any other\n      // conflict, and keep trying.\n      const cpp = this.canPlacePeers(REPLACE)\n      if (cpp !== CONFLICT) {\n        return cpp\n      }\n    }\n\n    // ok, can't replace the current with new one, but maybe current is ok?\n    if (current.satisfies(edge) && (!explicitRequest || preferDedupe)) {\n      return KEEP\n    }\n\n    // if we prefer deduping, then try replacing newer with older\n    if (preferDedupe && !tryReplace && dep.canReplace(current)) {\n      const cpp = this.canPlacePeers(REPLACE)\n      if (cpp !== CONFLICT) {\n        return cpp\n      }\n    }\n\n    // Check for interesting cases!\n    // First, is this the deepest place that this thing can go, and NOT the\n    // deepest place where the conflicting dep can go?  If so, replace it,\n    // and let it re-resolve deeper in the tree.\n    const myDeepest = this.deepestNestingTarget\n\n    // ok, i COULD be placed deeper, so leave the current one alone.\n    if (target !== myDeepest) {\n      return CONFLICT\n    }\n\n    // if we are not checking a peerDep, then we MUST place it here, in the\n    // target that has a non-peer dep on it.\n    if (!edge.peer && target === edge.from) {\n      return this.canPlacePeers(REPLACE)\n    }\n\n    // if we aren't placing a peer in a set, then we're done here.\n    // This is ignored because it SHOULD be redundant, as far as I can tell,\n    // with the deepest target and target===edge.from tests.  But until we\n    // can prove that isn't possible, this condition is here for safety.\n    /* istanbul ignore if - allegedly impossible */\n    if (!this.parent && !edge.peer) {\n      return CONFLICT\n    }\n\n    // check the deps in the peer group for each edge into that peer group\n    // if ALL of them can be pushed deeper, or if it's ok to replace its\n    // members with the contents of the new peer group, then we're good.\n    let canReplace = true\n    for (const [entryEdge, currentPeers] of peerEntrySets(current)) {\n      if (entryEdge === this.edge || entryEdge === this.peerEntryEdge) {\n        continue\n      }\n\n      // First, see if it's ok to just replace the peerSet entirely.\n      // we do this by walking out from the entryEdge, because in a case like\n      // this:\n      //\n      // v -> PEER(a@1||2)\n      // a@1 -> PEER(b@1)\n      // a@2 -> PEER(b@2)\n      // b@1 -> PEER(a@1)\n      // b@2 -> PEER(a@2)\n      //\n      // root\n      // +-- v\n      // +-- a@2\n      // +-- b@2\n      //\n      // Trying to place a peer group of (a@1, b@1) would fail to note that\n      // they can be replaced, if we did it by looping 1 by 1.  If we are\n      // replacing something, we don't have to check its peer deps, because\n      // the peerDeps in the placed peerSet will presumably satisfy.\n      const entryNode = entryEdge.to\n      const entryRep = dep.parent.children.get(entryNode.name)\n      if (entryRep) {\n        if (entryRep.canReplace(entryNode, dep.parent.children.keys())) {\n          continue\n        }\n      }\n\n      let canClobber = !entryRep\n      if (!entryRep) {\n        const peerReplacementWalk = new Set([entryNode])\n        OUTER: for (const currentPeer of peerReplacementWalk) {\n          for (const edge of currentPeer.edgesOut.values()) {\n            if (!edge.peer || !edge.valid) {\n              continue\n            }\n            const rep = dep.parent.children.get(edge.name)\n            if (!rep) {\n              if (edge.to) {\n                peerReplacementWalk.add(edge.to)\n              }\n              continue\n            }\n            if (!rep.satisfies(edge)) {\n              canClobber = false\n              break OUTER\n            }\n          }\n        }\n      }\n      if (canClobber) {\n        continue\n      }\n\n      // ok, we can't replace, but maybe we can nest the current set deeper?\n      let canNestCurrent = true\n      for (const currentPeer of currentPeers) {\n        if (!canNestCurrent) {\n          break\n        }\n\n        // still possible to nest this peerSet\n        const curDeep = deepestNestingTarget(entryEdge.from, currentPeer.name)\n        if (curDeep === target || target.isDescendantOf(curDeep)) {\n          canNestCurrent = false\n          canReplace = false\n        }\n        if (canNestCurrent) {\n          continue\n        }\n      }\n    }\n\n    // if we can nest or replace all the current peer groups, we can replace.\n    if (canReplace) {\n      return this.canPlacePeers(REPLACE)\n    }\n\n    return CONFLICT\n  }\n\n  checkCanPlaceNoCurrent () {\n    const { target, peerEntryEdge, dep, name } = this\n\n    // check to see what that name resolves to here, and who may depend on\n    // being able to reach it by crawling up past the parent.  we know\n    // that it's not the target's direct child node, and if it was a direct\n    // dep of the target, we would have conflicted earlier.\n    const current = target !== peerEntryEdge.from && target.resolve(name)\n    if (current) {\n      for (const edge of current.edgesIn.values()) {\n        if (edge.from.isDescendantOf(target) && edge.valid) {\n          if (!dep.satisfies(edge)) {\n            return CONFLICT\n          }\n        }\n      }\n    }\n\n    // no objections, so this is fine as long as peers are ok here.\n    return this.canPlacePeers(OK)\n  }\n\n  get deepestNestingTarget () {\n    const start = this.parent ? this.parent.deepestNestingTarget\n      : this.edge.from\n    return deepestNestingTarget(start, this.name)\n  }\n\n  get conflictChildren () {\n    return this.allChildren.filter(c => c.canPlace === CONFLICT)\n  }\n\n  get allChildren () {\n    const set = new Set(this.children)\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild)\n      }\n    }\n    return [...set]\n  }\n\n  get top () {\n    return this.parent ? this.parent.top : this\n  }\n\n  // check if peers can go here.  returns state or CONFLICT\n  canPlacePeers (state) {\n    this.canPlaceSelf = state\n    if (this._canPlacePeers) {\n      return this._canPlacePeers\n    }\n\n    // TODO: represent peerPath in ERESOLVE error somehow?\n    const peerPath = [...this.peerPath, this.dep]\n    let sawConflict = false\n    for (const peerEdge of this.dep.edgesOut.values()) {\n      if (!peerEdge.peer || !peerEdge.to || peerPath.includes(peerEdge.to)) {\n        continue\n      }\n      const peer = peerEdge.to\n      // it may be the case that the *initial* dep can be nested, but a peer\n      // of that dep needs to be placed shallower, because the target has\n      // a peer dep on the peer as well.\n      const target = deepestNestingTarget(this.target, peer.name)\n      const cpp = new CanPlaceDep({\n        dep: peer,\n        target,\n        parent: this,\n        edge: peerEdge,\n        peerPath,\n        // always place peers in preferDedupe mode\n        preferDedupe: true,\n      })\n      /* istanbul ignore next */\n      debug(() => {\n        if (this.children.some(c => c.dep === cpp.dep)) {\n          throw new Error('checking same dep repeatedly')\n        }\n      })\n      this.children.push(cpp)\n\n      if (cpp.canPlace === CONFLICT) {\n        sawConflict = true\n      }\n    }\n\n    this._canPlacePeers = sawConflict ? CONFLICT : state\n    return this._canPlacePeers\n  }\n\n  // what is the node that is causing this peerSet to be placed?\n  get peerSetSource () {\n    return this.parent ? this.parent.peerSetSource : this.edge.from\n  }\n\n  get peerEntryEdge () {\n    return this.top.edge\n  }\n\n  static get CONFLICT () {\n    return CONFLICT\n  }\n\n  static get OK () {\n    return OK\n  }\n\n  static get REPLACE () {\n    return REPLACE\n  }\n\n  static get KEEP () {\n    return KEEP\n  }\n\n  get description () {\n    const { canPlace } = this\n    return canPlace && canPlace.description ||\n    /* istanbul ignore next - old node affordance */ canPlace\n  }\n}\n\nmodule.exports = CanPlaceDep\n","// Given a node in a tree, return all of the peer dependency sets that\n// it is a part of, with the entry (top or non-peer) edges into the sets\n// identified.\n//\n// With this information, we can determine whether it is appropriate to\n// replace the entire peer set with another (and remove the old one),\n// push the set deeper into the tree, and so on.\n//\n// Returns a Map of { edge => Set(peerNodes) },\n\nconst peerEntrySets = node => {\n  // this is the union of all peer groups that the node is a part of\n  // later, we identify all of the entry edges, and create a set of\n  // 1 or more overlapping sets that this node is a part of.\n  const unionSet = new Set([node])\n  for (const node of unionSet) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.valid && edge.peer && edge.to) {\n        unionSet.add(edge.to)\n      }\n    }\n    for (const edge of node.edgesIn) {\n      if (edge.valid && edge.peer) {\n        unionSet.add(edge.from)\n      }\n    }\n  }\n  const entrySets = new Map()\n  for (const peer of unionSet) {\n    for (const edge of peer.edgesIn) {\n      // if not valid, it doesn't matter anyway.  either it's been previously\n      // peerConflicted, or it's the thing we're interested in replacing.\n      if (!edge.valid) {\n        continue\n      }\n      // this is the entry point into the peer set\n      if (!edge.peer || edge.from.isTop) {\n        // get the subset of peer brought in by this peer entry edge\n        const sub = new Set([peer])\n        for (const peer of sub) {\n          for (const edge of peer.edgesOut.values()) {\n            if (edge.valid && edge.peer && edge.to) {\n              sub.add(edge.to)\n            }\n          }\n        }\n        // if this subset does not include the node we are focused on,\n        // then it is not relevant for our purposes.  Example:\n        //\n        // a -> (b, c, d)\n        // b -> PEER(d) b -> d -> e -> f <-> g\n        // c -> PEER(f, h) c -> (f <-> g, h -> g)\n        // d -> PEER(e) d -> e -> f <-> g\n        // e -> PEER(f)\n        // f -> PEER(g)\n        // g -> PEER(f)\n        // h -> PEER(g)\n        //\n        // The unionSet(e) will include c, but we don't actually care about\n        // it.  We only expanded to the edge of the peer nodes in order to\n        // find the entry edges that caused the inclusion of peer sets\n        // including (e), so we want:\n        //   Map{\n        //     Edge(a->b) => Set(b, d, e, f, g)\n        //     Edge(a->d) => Set(d, e, f, g)\n        //   }\n        if (sub.has(node)) {\n          entrySets.set(edge, sub)\n        }\n      }\n    }\n  }\n\n  return entrySets\n}\n\nmodule.exports = peerEntrySets\n","// given a starting node, what is the *deepest* target where name could go?\n// This is not on the Node class for the simple reason that we sometimes\n// need to check the deepest *potential* target for a Node that is not yet\n// added to the tree where we are checking.\nconst deepestNestingTarget = (start, name) => {\n  for (const target of start.ancestry()) {\n    // note: this will skip past the first target if edge is peer\n    if (target.isProjectRoot || !target.resolveParent || target.globalTop) {\n      return target\n    }\n    const targetEdge = target.edgesOut.get(name)\n    if (!targetEdge || !targetEdge.peer) {\n      return target\n    }\n  }\n}\n\nmodule.exports = deepestNestingTarget\n","// Given a dep, a node that depends on it, and the edge representing that\n// dependency, place the dep somewhere in the node's tree, and all of its\n// peer dependencies.\n//\n// Handles all of the tree updating needed to place the dep, including\n// removing replaced nodes, pruning now-extraneous or invalidated nodes,\n// and saves a set of what was placed and what needs re-evaluation as\n// a result.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst log = require('proc-log')\nconst deepestNestingTarget = require('./deepest-nesting-target.js')\nconst CanPlaceDep = require('./can-place-dep.js')\nconst {\n  KEEP,\n  CONFLICT,\n} = CanPlaceDep\nconst debug = require('./debug.js')\n\nconst Link = require('./link.js')\nconst gatherDepSet = require('./gather-dep-set.js')\nconst peerEntrySets = require('./peer-entry-sets.js')\n\nclass PlaceDep {\n  constructor (options) {\n    const {\n      dep,\n      edge,\n      parent = null,\n    } = options\n    this.name = edge.name\n    this.dep = dep\n    this.edge = edge\n    this.canPlace = null\n\n    this.target = null\n    this.placed = null\n\n    // inherit all these fields from the parent to ensure consistency.\n    const {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle,\n    } = parent || options\n    Object.assign(this, {\n      preferDedupe,\n      force,\n      explicitRequest,\n      updateNames,\n      auditReport,\n      legacyBundling,\n      strictPeerDeps,\n      legacyPeerDeps,\n      globalStyle,\n    })\n\n    this.children = []\n    this.parent = parent\n    this.peerConflict = null\n\n    this.needEvaluation = new Set()\n\n    this.checks = new Map()\n\n    this.place()\n  }\n\n  place () {\n    const {\n      edge,\n      dep,\n      preferDedupe,\n      globalStyle,\n      legacyBundling,\n      explicitRequest,\n      updateNames,\n      checks,\n    } = this\n\n    // nothing to do if the edge is fine as it is\n    if (edge.to &&\n        !edge.error &&\n        !explicitRequest &&\n        !updateNames.includes(edge.name) &&\n        !this.isVulnerable(edge.to)) {\n      return\n    }\n\n    // walk up the tree until we hit either a top/root node, or a place\n    // where the dep is not a peer dep.\n    const start = this.getStartNode()\n\n    let canPlace = null\n    let canPlaceSelf = null\n    for (const target of start.ancestry()) {\n      // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers,\n      // and the getStartNode will start us out above any peers from the\n      // thing that depends on it.  but we could hit it with something like:\n      //\n      // a -> (b@1, c@1)\n      // +-- c@1\n      // +-- b -> PEEROPTIONAL(v) (c@2)\n      //     +-- c@2 -> (v)\n      //\n      // So we check if we can place v under c@2, that's fine.\n      // Then we check under b, and can't, because of the optional peer dep.\n      // but we CAN place it under a, so the correct thing to do is keep\n      // walking up the tree.\n      const targetEdge = target.edgesOut.get(edge.name)\n      if (!target.isTop && targetEdge && targetEdge.peer) {\n        continue\n      }\n\n      const cpd = new CanPlaceDep({\n        dep,\n        edge,\n        // note: this sets the parent's canPlace as the parent of this\n        // canPlace, but it does NOT add this canPlace to the parent's\n        // children.  This way, we can know that it's a peer dep, and\n        // get the top edge easily, while still maintaining the\n        // tree of checks that factored into the original decision.\n        parent: this.parent && this.parent.canPlace,\n        target,\n        preferDedupe,\n        explicitRequest: this.explicitRequest,\n      })\n      checks.set(target, cpd)\n\n      // It's possible that a \"conflict\" is a conflict among the *peers* of\n      // a given node we're trying to place, but there actually is no current\n      // node.  Eg,\n      // root -> (a, b)\n      // a -> PEER(c)\n      // b -> PEER(d)\n      // d -> PEER(c@2)\n      // We place (a), and get a peer of (c) along with it.\n      // then we try to place (b), and get CONFLICT in the check, because\n      // of the conflicting peer from (b)->(d)->(c@2).  In that case, we\n      // should treat (b) and (d) as OK, and place them in the last place\n      // where they did not themselves conflict, and skip c@2 if conflict\n      // is ok by virtue of being forced or not ours and not strict.\n      if (cpd.canPlaceSelf !== CONFLICT) {\n        canPlaceSelf = cpd\n      }\n\n      // we found a place this can go, along with all its peer friends.\n      // we break when we get the first conflict\n      if (cpd.canPlace !== CONFLICT) {\n        canPlace = cpd\n      } else {\n        break\n      }\n\n      // if it's a load failure, just plop it in the first place attempted,\n      // since we're going to crash the build or prune it out anyway.\n      // but, this will frequently NOT be a successful canPlace, because\n      // it'll have no version or other information.\n      if (dep.errors.length) {\n        break\n      }\n\n      // nest packages like npm v1 and v2\n      // very disk-inefficient\n      if (legacyBundling) {\n        break\n      }\n\n      // when installing globally, or just in global style, we never place\n      // deps above the first level.\n      if (globalStyle) {\n        const rp = target.resolveParent\n        if (rp && rp.isProjectRoot) {\n          break\n        }\n      }\n    }\n\n    Object.assign(this, {\n      canPlace,\n      canPlaceSelf,\n    })\n    this.current = edge.to\n\n    // if we can't find a target, that means that the last place checked,\n    // and all the places before it, had a conflict.\n    if (!canPlace) {\n      // if not forced, or it's our dep, or strictPeerDeps is set, then\n      // this is an ERESOLVE error.\n      if (!this.conflictOk) {\n        return this.failPeerConflict()\n      }\n\n      // ok!  we're gonna allow the conflict, but we should still warn\n      // if we have a current, then we treat CONFLICT as a KEEP.\n      // otherwise, we just skip it.  Only warn on the one that actually\n      // could not be placed somewhere.\n      if (!canPlaceSelf) {\n        this.warnPeerConflict()\n        return\n      }\n\n      this.canPlace = canPlaceSelf\n    }\n\n    // now we have a target, a tree of CanPlaceDep results for the peer group,\n    // and we are ready to go\n    this.placeInTree()\n  }\n\n  placeInTree () {\n    const {\n      dep,\n      canPlace,\n      edge,\n    } = this\n\n    /* istanbul ignore next */\n    if (!canPlace) {\n      debug(() => {\n        throw new Error('canPlace not set, but trying to place in tree')\n      })\n      return\n    }\n\n    const { target } = canPlace\n\n    log.silly(\n      'placeDep',\n      target.location || 'ROOT',\n      `${dep.name}@${dep.version}`,\n      canPlace.description,\n      `for: ${this.edge.from.package._id || this.edge.from.location}`,\n      `want: ${edge.spec || '*'}`\n    )\n\n    const placementType = canPlace.canPlace === CONFLICT\n      ? canPlace.canPlaceSelf\n      : canPlace.canPlace\n\n    // if we're placing in the tree with --force, we can get here even though\n    // it's a conflict.  Treat it as a KEEP, but warn and move on.\n    if (placementType === KEEP) {\n      // this was a peerConflicted peer dep\n      if (edge.peer && !edge.valid) {\n        this.warnPeerConflict()\n      }\n\n      // if we get a KEEP in a update scenario, then we MAY have something\n      // already duplicating this unnecessarily!  For example:\n      // ```\n      // root (dep: y@1)\n      // +-- x (dep: y@1.1)\n      // |   +-- y@1.1.0 (replacing with 1.1.2, got KEEP at the root)\n      // +-- y@1.1.2 (updated already from 1.0.0)\n      // ```\n      // Now say we do `reify({update:['y']})`, and the latest version is\n      // 1.1.2, which we now have in the root.  We'll try to place y@1.1.2\n      // first in x, then in the root, ending with KEEP, because we already\n      // have it.  In that case, we ought to REMOVE the nm/x/nm/y node, because\n      // it is an unnecessary duplicate.\n      this.pruneDedupable(target)\n      return\n    }\n\n    // we were told to place it here in the target, so either it does not\n    // already exist in the tree, OR it's shadowed.\n    // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n    for (let p = target; p; p = p.resolveParent) {\n      if (p.matches(dep) && !p.isTop) {\n        this.placed = new Link({ parent: target, target: p })\n        return\n      }\n    }\n\n    // XXX if we are replacing SOME of a peer entry group, we will need to\n    // remove any that are not being replaced and will now be invalid, and\n    // re-evaluate them deeper into the tree.\n\n    const virtualRoot = dep.parent\n    this.placed = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.overrides ? { overrides: dep.overrides } : {}),\n      ...(dep.isLink ? { target: dep.target, realpath: dep.realpath } : {}),\n    })\n\n    this.oldDep = target.children.get(this.name)\n    if (this.oldDep) {\n      this.replaceOldDep()\n    } else {\n      this.placed.parent = target\n    }\n\n    // if it's a peerConflicted peer dep, warn about it\n    if (edge.peer && !this.placed.satisfies(edge)) {\n      this.warnPeerConflict()\n    }\n\n    // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n    if (edge.valid && edge.to && edge.to !== this.placed) {\n      this.pruneDedupable(edge.to, false)\n    }\n\n    // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n    for (const node of target.root.inventory.query('name', this.name)) {\n      if (node.isDescendantOf(target) && !node.isTop) {\n        this.pruneDedupable(node, false)\n        // only walk the direct children of the ones we kept\n        if (node.root === target.root) {\n          for (const kid of node.children.values()) {\n            this.pruneDedupable(kid, false)\n          }\n        }\n      }\n    }\n\n    // also place its unmet or invalid peer deps at this location\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n    for (const peerEdge of this.placed.edgesOut.values()) {\n      if (peerEdge.valid || !peerEdge.peer || peerEdge.peerConflicted) {\n        continue\n      }\n\n      const peer = virtualRoot.children.get(peerEdge.name)\n\n      // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), then this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n      if (!peer) {\n        continue\n      }\n\n      // peerConflicted peerEdge, just accept what's there already\n      if (!peer.satisfies(peerEdge)) {\n        continue\n      }\n\n      this.children.push(new PlaceDep({\n        parent: this,\n        dep: peer,\n        node: this.placed,\n        edge: peerEdge,\n      }))\n    }\n  }\n\n  replaceOldDep () {\n    const target = this.oldDep.parent\n\n    // XXX handle replacing an entire peer group?\n    // what about cases where we need to push some other peer groups deeper\n    // into the tree?  all the tree updating should be done here, and track\n    // all the things that we add and remove, so that we can know what\n    // to re-evaluate.\n\n    // if we're replacing, we should also remove any nodes for edges that\n    // are now invalid, and where this (or its deps) is the only dependent,\n    // and also recurse on that pruning.  Otherwise leaving that dep node\n    // around can result in spurious conflicts pushing nodes deeper into\n    // the tree than needed in the case of cycles that will be removed\n    // later anyway.\n    const oldDeps = []\n    for (const [name, edge] of this.oldDep.edgesOut.entries()) {\n      if (!this.placed.edgesOut.has(name) && edge.to) {\n        oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to))\n      }\n    }\n\n    // gather all peer edgesIn which are at this level, and will not be\n    // satisfied by the new dependency.  Those are the peer sets that need\n    // to be either warned about (if they cannot go deeper), or removed and\n    // re-placed (if they can).\n    const prunePeerSets = []\n    for (const edge of this.oldDep.edgesIn) {\n      if (this.placed.satisfies(edge) ||\n          !edge.peer ||\n          edge.from.parent !== target ||\n          edge.peerConflicted) {\n        // not a peer dep, not invalid, or not from this level, so it's fine\n        // to just let it re-evaluate as a problemEdge later, or let it be\n        // satisfied by the new dep being placed.\n        continue\n      }\n      for (const entryEdge of peerEntrySets(edge.from).keys()) {\n        // either this one needs to be pruned and re-evaluated, or marked\n        // as peerConflicted and warned about.  If the entryEdge comes in from\n        // the root or a workspace, then we have to leave it alone, and in that\n        // case, it will have already warned or crashed by getting to this point\n        const entryNode = entryEdge.to\n        const deepestTarget = deepestNestingTarget(entryNode)\n        if (deepestTarget !== target &&\n            !(entryEdge.from.isProjectRoot || entryEdge.from.isWorkspace)) {\n          prunePeerSets.push(...gatherDepSet([entryNode], e => {\n            return e.to !== entryNode && !e.peerConflicted\n          }))\n        } else {\n          this.warnPeerConflict(edge, this.dep)\n        }\n      }\n    }\n\n    this.placed.replace(this.oldDep)\n    this.pruneForReplacement(this.placed, oldDeps)\n    for (const dep of prunePeerSets) {\n      for (const edge of dep.edgesIn) {\n        this.needEvaluation.add(edge.from)\n      }\n      dep.root = null\n    }\n  }\n\n  pruneForReplacement (node, oldDeps) {\n    // gather up all the now-invalid/extraneous edgesOut, as long as they are\n    // only depended upon by the old node/deps\n    const invalidDeps = new Set([...node.edgesOut.values()]\n      .filter(e => e.to && !e.valid).map(e => e.to))\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid)\n      for (const dep of set) {\n        invalidDeps.add(dep)\n      }\n    }\n\n    // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n    const deps = gatherDepSet(invalidDeps, edge =>\n      edge.from !== node && edge.to !== node && edge.valid)\n\n    // now just delete whatever's left, because it's junk\n    for (const dep of deps) {\n      dep.root = null\n    }\n  }\n\n  // prune all the nodes in a branch of the tree that can be safely removed\n  // This is only the most basic duplication detection; it finds if there\n  // is another satisfying node further up the tree, and if so, dedupes.\n  // Even in legacyBundling mode, we do this amount of deduplication.\n  pruneDedupable (node, descend = true) {\n    if (node.canDedupe(this.preferDedupe)) {\n      // gather up all deps that have no valid edges in from outside\n      // the dep set, except for this node we're deduping, so that we\n      // also prune deps that would be made extraneous.\n      const deps = gatherDepSet([node], e => e.to !== node && e.valid)\n      for (const node of deps) {\n        node.root = null\n      }\n      return\n    }\n    if (descend) {\n      // sort these so that they're deterministically ordered\n      // otherwise, resulting tree shape is dependent on the order\n      // in which they happened to be resolved.\n      const nodeSort = (a, b) => localeCompare(a.location, b.location)\n\n      const children = [...node.children.values()].sort(nodeSort)\n      for (const child of children) {\n        this.pruneDedupable(child)\n      }\n      const fsChildren = [...node.fsChildren].sort(nodeSort)\n      for (const topNode of fsChildren) {\n        const children = [...topNode.children.values()].sort(nodeSort)\n        for (const child of children) {\n          this.pruneDedupable(child)\n        }\n      }\n    }\n  }\n\n  get conflictOk () {\n    return this.force || (!this.isMine && !this.strictPeerDeps)\n  }\n\n  get isMine () {\n    const { edge } = this.top\n    const { from: node } = edge\n\n    if (node.isWorkspace || node.isProjectRoot) {\n      return true\n    }\n\n    if (!edge.peer) {\n      return false\n    }\n\n    // re-entry case.  check if any non-peer edges come from the project,\n    // or any entryEdges on peer groups are from the root.\n    let hasPeerEdges = false\n    for (const edge of node.edgesIn) {\n      if (edge.peer) {\n        hasPeerEdges = true\n        continue\n      }\n      if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n        return true\n      }\n    }\n    if (hasPeerEdges) {\n      for (const edge of peerEntrySets(node).keys()) {\n        if (edge.from.isWorkspace || edge.from.isProjectRoot) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  warnPeerConflict (edge, dep) {\n    edge = edge || this.edge\n    dep = dep || this.dep\n    edge.peerConflicted = true\n    const expl = this.explainPeerConflict(edge, dep)\n    log.warn('ERESOLVE', 'overriding peer dependency', expl)\n  }\n\n  failPeerConflict (edge, dep) {\n    edge = edge || this.top.edge\n    dep = dep || this.top.dep\n    const expl = this.explainPeerConflict(edge, dep)\n    throw Object.assign(new Error('could not resolve'), expl)\n  }\n\n  explainPeerConflict (edge, dep) {\n    const { from: node } = edge\n    const curNode = node.resolve(edge.name)\n\n    const expl = {\n      code: 'ERESOLVE',\n      edge: edge.explain(),\n      dep: dep.explain(edge),\n    }\n\n    if (this.parent) {\n      // this is the conflicted peer\n      expl.current = curNode && curNode.explain(edge)\n      expl.peerConflict = this.current && this.current.explain(this.edge)\n    } else {\n      expl.current = curNode && curNode.explain()\n      if (this.canPlaceSelf && this.canPlaceSelf.canPlaceSelf !== CONFLICT) {\n        // failed while checking for a child dep\n        const cps = this.canPlaceSelf\n        for (const peer of cps.conflictChildren) {\n          if (peer.current) {\n            expl.peerConflict = {\n              current: peer.current.explain(),\n              peer: peer.dep.explain(peer.edge),\n            }\n            break\n          }\n        }\n      } else {\n        expl.peerConflict = {\n          current: this.current && this.current.explain(),\n          peer: this.dep.explain(this.edge),\n        }\n      }\n    }\n\n    const {\n      strictPeerDeps,\n      force,\n      isMine,\n    } = this\n    Object.assign(expl, {\n      strictPeerDeps,\n      force,\n      isMine,\n    })\n\n    // XXX decorate more with this.canPlace and this.canPlaceSelf,\n    // this.checks, this.children, walk over conflicted peers, etc.\n    return expl\n  }\n\n  getStartNode () {\n    // if we are a peer, then we MUST be at least as shallow as the\n    // peer dependent\n    const from = this.parent ? this.parent.getStartNode() : this.edge.from\n    return deepestNestingTarget(from, this.name)\n  }\n\n  get top () {\n    return this.parent ? this.parent.top : this\n  }\n\n  isVulnerable (node) {\n    return this.auditReport && this.auditReport.isVulnerable(node)\n  }\n\n  get allChildren () {\n    const set = new Set(this.children)\n    for (const child of set) {\n      for (const grandchild of child.children) {\n        set.add(grandchild)\n      }\n    }\n    return [...set]\n  }\n}\n\nmodule.exports = PlaceDep\n","const debug = require('./debug.js')\nconst relpath = require('./relpath.js')\nconst Node = require('./node.js')\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps')\nconst _target = Symbol.for('_target')\nconst { dirname } = require('path')\n// defined by Node class\nconst _delistFromMeta = Symbol.for('_delistFromMeta')\nconst _refreshLocation = Symbol.for('_refreshLocation')\nclass Link extends Node {\n  constructor (options) {\n    const { root, realpath, target, parent, fsParent } = options\n\n    if (!realpath && !(target && target.path)) {\n      throw new TypeError('must provide realpath for Link node')\n    }\n\n    super({\n      ...options,\n      realpath: realpath || target.path,\n      root: root || (parent ? parent.root\n      : fsParent ? fsParent.root\n      : target ? target.root\n      : null),\n    })\n\n    if (target) {\n      this.target = target\n    } else if (this.realpath === this.root.path) {\n      this.target = this.root\n    } else {\n      this.target = new Node({\n        ...options,\n        path: realpath,\n        parent: null,\n        fsParent: null,\n        root: this.root,\n      })\n    }\n  }\n\n  get version () {\n    return this.target ? this.target.version : this.package.version || ''\n  }\n\n  get target () {\n    return this[_target]\n  }\n\n  set target (target) {\n    const current = this[_target]\n    if (target === current) {\n      return\n    }\n\n    if (current && current.then) {\n      debug(() => {\n        throw Object.assign(new Error('cannot set target while awaiting'), {\n          path: this.path,\n          realpath: this.realpath,\n        })\n      })\n    }\n\n    if (target && target.then) {\n      // can set to a promise during an async tree build operation\n      // wait until then to assign it.\n      this[_target] = target\n      target.then(node => {\n        this[_target] = null\n        this.target = node\n      })\n      return\n    }\n\n    if (!target) {\n      if (current && current.linksIn) {\n        current.linksIn.delete(this)\n      }\n      if (this.path) {\n        this[_delistFromMeta]()\n        this[_target] = null\n        this.package = {}\n        this[_refreshLocation]()\n      } else {\n        this[_target] = null\n      }\n      return\n    }\n\n    if (!this.path) {\n      // temp node pending assignment to a tree\n      // we know it's not in the inventory yet, because no path.\n      if (target.path) {\n        this.realpath = target.path\n      } else {\n        target.path = target.realpath = this.realpath\n      }\n      target.root = this.root\n      this[_target] = target\n      target.linksIn.add(this)\n      this.package = target.package\n      return\n    }\n\n    // have to refresh metadata, because either realpath or package\n    // is very likely changing.\n    this[_delistFromMeta]()\n    this.package = target.package\n    this.realpath = target.path\n    this[_refreshLocation]()\n\n    target.root = this.root\n  }\n\n  // a link always resolves to the relative path to its target\n  get resolved () {\n    // the path/realpath guard is there for the benefit of setting\n    // these things in the \"wrong\" order\n    return this.path && this.realpath\n      ? `file:${relpath(dirname(this.path), this.realpath)}`\n      : null\n  }\n\n  set resolved (r) {}\n\n  // deps are resolved on the target, not the Link\n  // so this is a no-op\n  [_loadDeps] () {}\n\n  // links can't have children, only their targets can\n  // fix it to an empty list so that we can still call\n  // things that iterate over them, just as a no-op\n  get children () {\n    return new Map()\n  }\n\n  set children (c) {}\n\n  get isLink () {\n    return true\n  }\n}\n\nmodule.exports = Link\n","const { relative } = require('path')\nconst relpath = (from, to) => relative(from, to).replace(/\\\\/g, '/')\nmodule.exports = relpath\n","// inventory, path, realpath, root, and parent\n//\n// node.root is a reference to the root module in the tree (ie, typically the\n// cwd project folder)\n//\n// node.location is the /-delimited path from the root module to the node.  In\n// the case of link targets that may be outside of the root's package tree,\n// this can include some number of /../ path segments.  The location of the\n// root module is always '.'.  node.location thus never contains drive letters\n// or absolute paths, and is portable within a given project, suitable for\n// inclusion in lockfiles and metadata.\n//\n// node.path is the path to the place where this node lives on disk.  It is\n// system-specific and absolute.\n//\n// node.realpath is the path to where the module actually resides on disk.  In\n// the case of non-link nodes, node.realpath is equivalent to node.path.  In\n// the case of link nodes, it is equivalent to node.target.path.\n//\n// Setting node.parent will set the node's root to the parent's root, as well\n// as updating edgesIn and edgesOut to reload dependency resolutions as needed,\n// and setting node.path to parent.path/node_modules/name.\n//\n// node.inventory is a Map of name to a Set() of all the nodes under a given\n// root by that name.  It's empty for non-root nodes, and changing the root\n// reference will remove it from the old root's inventory and add it to the new\n// one.  This map is useful for cases like `npm update foo` or `npm ls foo`\n// where we need to quickly find all instances of a given package name within a\n// tree.\n\nconst semver = require('semver')\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst Edge = require('./edge.js')\nconst Inventory = require('./inventory.js')\nconst OverrideSet = require('./override-set.js')\nconst { normalize } = require('read-package-json-fast')\nconst { getPaths: getBinPaths } = require('bin-links')\nconst npa = require('npm-package-arg')\nconst debug = require('./debug.js')\nconst gatherDepSet = require('./gather-dep-set.js')\nconst treeCheck = require('./tree-check.js')\nconst walkUp = require('walk-up-path')\n\nconst { resolve, relative, dirname, basename } = require('path')\nconst util = require('util')\nconst _package = Symbol('_package')\nconst _parent = Symbol('_parent')\nconst _target = Symbol.for('_target')\nconst _fsParent = Symbol('_fsParent')\nconst _loadDepType = Symbol('_loadDepType')\nconst _loadWorkspaces = Symbol('_loadWorkspaces')\nconst _reloadNamedEdges = Symbol('_reloadNamedEdges')\n// overridden by Link class\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps')\nconst _root = Symbol('_root')\nconst _refreshLocation = Symbol.for('_refreshLocation')\nconst _changePath = Symbol.for('_changePath')\n// used by Link class as well\nconst _delistFromMeta = Symbol.for('_delistFromMeta')\nconst _global = Symbol.for('global')\nconst _workspaces = Symbol('_workspaces')\nconst _explain = Symbol('_explain')\nconst _explanation = Symbol('_explanation')\nconst _meta = Symbol('_meta')\n\nconst relpath = require('./relpath.js')\nconst consistentResolve = require('./consistent-resolve.js')\n\nconst printableTree = require('./printable.js')\nconst CaseInsensitiveMap = require('./case-insensitive-map.js')\n\nclass Node {\n  constructor (options) {\n    // NB: path can be null if it's a link target\n    const {\n      root,\n      path,\n      realpath,\n      parent,\n      error,\n      meta,\n      fsParent,\n      resolved,\n      integrity,\n      // allow setting name explicitly when we haven't set a path yet\n      name,\n      children,\n      fsChildren,\n      legacyPeerDeps = false,\n      linksIn,\n      hasShrinkwrap,\n      overrides,\n      loadOverrides = false,\n      extraneous = true,\n      dev = true,\n      optional = true,\n      devOptional = true,\n      peer = true,\n      global = false,\n      dummy = false,\n      sourceReference = null,\n    } = options\n\n    // true if part of a global install\n    this[_global] = global\n\n    this[_workspaces] = null\n\n    this.errors = error ? [error] : []\n\n    // this will usually be null, except when modeling a\n    // package's dependencies in a virtual root.\n    this.sourceReference = sourceReference\n\n    const pkg = sourceReference ? sourceReference.package\n      : normalize(options.pkg || {})\n\n    this.name = name ||\n      nameFromFolder(path || pkg.name || realpath) ||\n      pkg.name ||\n      null\n\n    // should be equal if not a link\n    this.path = path ? resolve(path) : null\n\n    if (!this.name && (!this.path || this.path !== dirname(this.path))) {\n      throw new TypeError('could not detect node name from path or package')\n    }\n\n    this.realpath = !this.isLink ? this.path : resolve(realpath)\n\n    this.resolved = resolved || null\n    if (!this.resolved) {\n      // note: this *only* works for non-file: deps, so we avoid even\n      // trying here.\n      // file: deps are tracked in package.json will _resolved set to the\n      // full path to the tarball or link target.  However, if the package\n      // is checked into git or moved to another location, that's 100% not\n      // portable at all!  The _where and _location don't provide much help,\n      // since _location is just where the module ended up in the tree,\n      // and _where can be different than the actual root if it's a\n      // meta-dep deeper in the dependency graph.\n      //\n      // If we don't have the other oldest indicators of legacy npm, then it's\n      // probably what we're getting from pacote, which IS trustworthy.\n      //\n      // Otherwise, hopefully a shrinkwrap will help us out.\n      const resolved = consistentResolve(pkg._resolved)\n      if (resolved && !(/^file:/.test(resolved) && pkg._where)) {\n        this.resolved = resolved\n      }\n    }\n    this.integrity = integrity || pkg._integrity || null\n    this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this.children = new CaseInsensitiveMap()\n    this.fsChildren = new Set()\n    this.inventory = new Inventory({})\n    this.tops = new Set()\n    this.linksIn = new Set(linksIn || [])\n\n    // these three are set by an Arborist taking a catalog\n    // after the tree is built.  We don't get this along the way,\n    // because they have a tendency to change as new children are\n    // added, especially when they're deduped.  Eg, a dev dep may be\n    // a 3-levels-deep dependency of a non-dev dep.  If we calc the\n    // flags along the way, then they'll tend to be invalid  by the\n    // time we need to look at them.\n    if (!dummy) {\n      this.dev = dev\n      this.optional = optional\n      this.devOptional = devOptional\n      this.peer = peer\n      this.extraneous = extraneous\n      this.dummy = false\n    } else {\n      // true if this is a placeholder for the purpose of serving as a\n      // fsParent to link targets that get their deps resolved outside\n      // the root tree folder.\n      this.dummy = true\n      this.dev = false\n      this.optional = false\n      this.devOptional = false\n      this.peer = false\n      this.extraneous = false\n    }\n\n    this.edgesIn = new Set()\n    this.edgesOut = new CaseInsensitiveMap()\n\n    // have to set the internal package ref before assigning the parent,\n    // because this.package is read when adding to inventory\n    this[_package] = pkg && typeof pkg === 'object' ? pkg : {}\n\n    if (overrides) {\n      this.overrides = overrides\n    } else if (loadOverrides) {\n      const overrides = this[_package].overrides || {}\n      if (Object.keys(overrides).length > 0) {\n        this.overrides = new OverrideSet({\n          overrides: this[_package].overrides,\n        })\n      }\n    }\n\n    // only relevant for the root and top nodes\n    this.meta = meta\n\n    // Note: this is _slightly_ less efficient for the initial tree\n    // building than it could be, but in exchange, it's a much simpler\n    // algorithm.\n    // If this node has a bunch of children, and those children satisfy\n    // its various deps, then we're going to _first_ create all the\n    // edges, and _then_ assign the children into place, re-resolving\n    // them all in _reloadNamedEdges.\n    // A more efficient, but more complicated, approach would be to\n    // flag this node as being a part of a tree build, so it could\n    // hold off on resolving its deps until its children are in place.\n\n    // call the parent setter\n    // Must be set prior to calling _loadDeps, because top-ness is relevant\n\n    // will also assign root if present on the parent\n    this[_parent] = null\n    this.parent = parent || null\n\n    this[_fsParent] = null\n    this.fsParent = fsParent || null\n\n    // see parent/root setters below.\n    // root is set to parent's root if we have a parent, otherwise if it's\n    // null, then it's set to the node itself.\n    if (!parent && !fsParent) {\n      this.root = root || null\n    }\n\n    // mostly a convenience for testing, but also a way to create\n    // trees in a more declarative way than setting parent on each\n    if (children) {\n      for (const c of children) {\n        new Node({ ...c, parent: this })\n      }\n    }\n    if (fsChildren) {\n      for (const c of fsChildren) {\n        new Node({ ...c, fsParent: this })\n      }\n    }\n\n    // now load all the dep edges\n    this[_loadDeps]()\n  }\n\n  get meta () {\n    return this[_meta]\n  }\n\n  set meta (meta) {\n    this[_meta] = meta\n    if (meta) {\n      meta.add(this)\n    }\n  }\n\n  get global () {\n    return this.root[_global]\n  }\n\n  // true for packages installed directly in the global node_modules folder\n  get globalTop () {\n    return this.global && this.parent && this.parent.isProjectRoot\n  }\n\n  get workspaces () {\n    return this[_workspaces]\n  }\n\n  set workspaces (workspaces) {\n    // deletes edges if they already exists\n    if (this[_workspaces]) {\n      for (const name of this[_workspaces].keys()) {\n        if (!workspaces.has(name)) {\n          this.edgesOut.get(name).detach()\n        }\n      }\n    }\n\n    this[_workspaces] = workspaces\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n  }\n\n  get binPaths () {\n    if (!this.parent) {\n      return []\n    }\n\n    return getBinPaths({\n      pkg: this[_package],\n      path: this.path,\n      global: this.global,\n      top: this.globalTop,\n    })\n  }\n\n  get hasInstallScript () {\n    const { hasInstallScript, scripts } = this.package\n    const { install, preinstall, postinstall } = scripts || {}\n    return !!(hasInstallScript || install || preinstall || postinstall)\n  }\n\n  get version () {\n    return this[_package].version || ''\n  }\n\n  get packageName () {\n    return this[_package].name || null\n  }\n\n  get pkgid () {\n    const { name = '', version = '' } = this.package\n    // root package will prefer package name over folder name,\n    // and never be called an alias.\n    const { isProjectRoot } = this\n    const myname = isProjectRoot ? name || this.name\n      : this.name\n    const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@`\n      : ''\n    return `${myname}@${alias}${version}`\n  }\n\n  get package () {\n    return this[_package]\n  }\n\n  set package (pkg) {\n    // just detach them all.  we could make this _slightly_ more efficient\n    // by only detaching the ones that changed, but we'd still have to walk\n    // them all, and the comparison logic gets a bit tricky.  we generally\n    // only do this more than once at the root level, so the resolve() calls\n    // are only one level deep, and there's not much to be saved, anyway.\n    // simpler to just toss them all out.\n    for (const edge of this.edgesOut.values()) {\n      edge.detach()\n    }\n\n    this[_explanation] = null\n    /* istanbul ignore next - should be impossible */\n    if (!pkg || typeof pkg !== 'object') {\n      debug(() => {\n        throw new Error('setting Node.package to non-object')\n      })\n      pkg = {}\n    }\n    this[_package] = pkg\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n    // do a hard reload, since the dependents may now be valid or invalid\n    // as a result of the package change.\n    this.edgesIn.forEach(edge => edge.reload(true))\n  }\n\n  // node.explain(nodes seen already, edge we're trying to satisfy\n  // if edge is not specified, it lists every edge into the node.\n  explain (edge = null, seen = []) {\n    if (this[_explanation]) {\n      return this[_explanation]\n    }\n\n    return this[_explanation] = this[_explain](edge, seen)\n  }\n\n  [_explain] (edge, seen) {\n    if (this.isProjectRoot && !this.sourceReference) {\n      return {\n        location: this.path,\n      }\n    }\n\n    const why = {\n      name: this.isProjectRoot || this.isTop ? this.packageName : this.name,\n      version: this.package.version,\n    }\n    if (this.errors.length || !this.packageName || !this.package.version) {\n      why.errors = this.errors.length ? this.errors : [\n        new Error('invalid package: lacks name and/or version'),\n      ]\n      why.package = this.package\n    }\n\n    if (this.root.sourceReference) {\n      const { name, version } = this.root.package\n      why.whileInstalling = {\n        name,\n        version,\n        path: this.root.sourceReference.path,\n      }\n    }\n\n    if (this.sourceReference) {\n      return this.sourceReference.explain(edge, seen)\n    }\n\n    if (seen.includes(this)) {\n      return why\n    }\n\n    why.location = this.location\n    why.isWorkspace = this.isWorkspace\n\n    // make a new list each time.  we can revisit, but not loop.\n    seen = seen.concat(this)\n\n    why.dependents = []\n    if (edge) {\n      why.dependents.push(edge.explain(seen))\n    } else {\n      // ignore invalid edges, since those aren't satisfied by this thing,\n      // and are not keeping it held in this spot anyway.\n      const edges = []\n      for (const edge of this.edgesIn) {\n        if (!edge.valid && !edge.from.isProjectRoot) {\n          continue\n        }\n\n        edges.push(edge)\n      }\n      for (const edge of edges) {\n        why.dependents.push(edge.explain(seen))\n      }\n    }\n\n    if (this.linksIn.size) {\n      why.linksIn = [...this.linksIn].map(link => link[_explain](edge, seen))\n    }\n\n    return why\n  }\n\n  isDescendantOf (node) {\n    for (let p = this; p; p = p.resolveParent) {\n      if (p === node) {\n        return true\n      }\n    }\n    return false\n  }\n\n  getBundler (path = []) {\n    // made a cycle, definitely not bundled!\n    if (path.includes(this)) {\n      return null\n    }\n\n    path.push(this)\n\n    const parent = this[_parent]\n    if (!parent) {\n      return null\n    }\n\n    const pBundler = parent.getBundler(path)\n    if (pBundler) {\n      return pBundler\n    }\n\n    const ppkg = parent.package\n    const bd = ppkg && ppkg.bundleDependencies\n    // explicit bundling\n    if (Array.isArray(bd) && bd.includes(this.name)) {\n      return parent\n    }\n\n    // deps that are deduped up to the bundling level are bundled.\n    // however, if they get their dep met further up than that,\n    // then they are not bundled.  Ie, installing a package with\n    // unmet bundled deps will not cause your deps to be bundled.\n    for (const edge of this.edgesIn) {\n      const eBundler = edge.from.getBundler(path)\n      if (!eBundler) {\n        continue\n      }\n\n      if (eBundler === parent) {\n        return eBundler\n      }\n    }\n\n    return null\n  }\n\n  get inBundle () {\n    return !!this.getBundler()\n  }\n\n  // when reifying, if a package is technically in a bundleDependencies list,\n  // but that list is the root project, we still have to install it.  This\n  // getter returns true if it's in a dependency's bundle list, not the root's.\n  get inDepBundle () {\n    const bundler = this.getBundler()\n    return !!bundler && bundler !== this.root\n  }\n\n  get isWorkspace () {\n    if (this.isProjectRoot) {\n      return false\n    }\n    const { root } = this\n    const { type, to } = root.edgesOut.get(this.packageName) || {}\n    return type === 'workspace' && to && (to.target === this || to === this)\n  }\n\n  get isRoot () {\n    return this === this.root\n  }\n\n  get isProjectRoot () {\n    // only treat as project root if it's the actual link that is the root,\n    // or the target of the root link, but NOT if it's another link to the\n    // same root that happens to be somewhere else.\n    return this === this.root || this === this.root.target\n  }\n\n  * ancestry () {\n    for (let anc = this; anc; anc = anc.resolveParent) {\n      yield anc\n    }\n  }\n\n  set root (root) {\n    // setting to null means this is the new root\n    // should only ever be one step\n    while (root && root.root !== root) {\n      root = root.root\n    }\n\n    root = root || this\n\n    // delete from current root inventory\n    this[_delistFromMeta]()\n\n    // can't set the root (yet) if there's no way to determine location\n    // this allows us to do new Node({...}) and then set the root later.\n    // just make the assignment so we don't lose it, and move on.\n    if (!this.path || !root.realpath || !root.path) {\n      return this[_root] = root\n    }\n\n    // temporarily become a root node\n    this[_root] = this\n\n    // break all linksIn, we're going to re-set them if needed later\n    for (const link of this.linksIn) {\n      link[_target] = null\n      this.linksIn.delete(link)\n    }\n\n    // temporarily break this link as well, we'll re-set if possible later\n    const { target } = this\n    if (this.isLink) {\n      if (target) {\n        target.linksIn.delete(this)\n        if (target.root === this) {\n          target[_delistFromMeta]()\n        }\n      }\n      this[_target] = null\n    }\n\n    // if this is part of a cascading root set, then don't do this bit\n    // but if the parent/fsParent is in a different set, we have to break\n    // that reference before proceeding\n    if (this.parent && this.parent.root !== root) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent && this.fsParent.root !== root) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    if (root === this) {\n      this[_refreshLocation]()\n    } else {\n      // setting to some different node.\n      const loc = relpath(root.realpath, this.path)\n      const current = root.inventory.get(loc)\n\n      // clobber whatever is there now\n      if (current) {\n        current.root = null\n      }\n\n      this[_root] = root\n      // set this.location and add to inventory\n      this[_refreshLocation]()\n\n      // try to find our parent/fsParent in the new root inventory\n      for (const p of walkUp(dirname(this.path))) {\n        if (p === this.path) {\n          continue\n        }\n        const ploc = relpath(root.realpath, p)\n        const parent = root.inventory.get(ploc)\n        if (parent) {\n          /* istanbul ignore next - impossible */\n          if (parent.isLink) {\n            debug(() => {\n              throw Object.assign(new Error('assigning parentage to link'), {\n                path: this.path,\n                parent: parent.path,\n                parentReal: parent.realpath,\n              })\n            })\n            continue\n          }\n          const childLoc = `${ploc}${ploc ? '/' : ''}node_modules/${this.name}`\n          const isParent = this.location === childLoc\n          if (isParent) {\n            const oldChild = parent.children.get(this.name)\n            if (oldChild && oldChild !== this) {\n              oldChild.root = null\n            }\n            if (this.parent) {\n              this.parent.children.delete(this.name)\n              this.parent[_reloadNamedEdges](this.name)\n            }\n            parent.children.set(this.name, this)\n            this[_parent] = parent\n            // don't do it for links, because they don't have a target yet\n            // we'll hit them up a bit later on.\n            if (!this.isLink) {\n              parent[_reloadNamedEdges](this.name)\n            }\n          } else {\n            /* istanbul ignore if - should be impossible, since we break\n             * all fsParent/child relationships when moving? */\n            if (this.fsParent) {\n              this.fsParent.fsChildren.delete(this)\n            }\n            parent.fsChildren.add(this)\n            this[_fsParent] = parent\n          }\n          break\n        }\n      }\n\n      // if it doesn't have a parent, it's a top node\n      if (!this.parent) {\n        root.tops.add(this)\n      } else {\n        root.tops.delete(this)\n      }\n\n      // assign parentage for any nodes that need to have this as a parent\n      // this can happen when we have a node at nm/a/nm/b added *before*\n      // the node at nm/a, which might have the root node as a fsParent.\n      // we can't rely on the public setter here, because it calls into\n      // this function to set up these references!\n      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`\n      const isChild = n => n.location === nmloc + n.name\n      // check dirname so that /foo isn't treated as the fsparent of /foo-bar\n      const isFsChild = n => {\n        return dirname(n.path).startsWith(this.path) &&\n          n !== this &&\n          !n.parent &&\n          (!n.fsParent ||\n            n.fsParent === this ||\n            dirname(this.path).startsWith(n.fsParent.path))\n      }\n      const isKid = n => isChild(n) || isFsChild(n)\n\n      // only walk top nodes, since anything else already has a parent.\n      for (const child of root.tops) {\n        if (!isKid(child)) {\n          continue\n        }\n\n        // set up the internal parentage links\n        if (this.isLink) {\n          child.root = null\n        } else {\n          // can't possibly have a parent, because it's in tops\n          if (child.fsParent) {\n            child.fsParent.fsChildren.delete(child)\n          }\n          child[_fsParent] = null\n          if (isChild(child)) {\n            this.children.set(child.name, child)\n            child[_parent] = this\n            root.tops.delete(child)\n          } else {\n            this.fsChildren.add(child)\n            child[_fsParent] = this\n          }\n        }\n      }\n\n      // look for any nodes with the same realpath.  either they're links\n      // to that realpath, or a thing at that realpath if we're adding a link\n      // (if we're adding a regular node, we already deleted the old one)\n      for (const node of root.inventory.query('realpath', this.realpath)) {\n        if (node === this) {\n          continue\n        }\n\n        /* istanbul ignore next - should be impossible */\n        debug(() => {\n          if (node.root !== root) {\n            throw new Error('inventory contains node from other root')\n          }\n        })\n\n        if (this.isLink) {\n          const target = node.target\n          this[_target] = target\n          this[_package] = target.package\n          target.linksIn.add(this)\n          // reload edges here, because now we have a target\n          if (this.parent) {\n            this.parent[_reloadNamedEdges](this.name)\n          }\n          break\n        } else {\n          /* istanbul ignore else - should be impossible */\n          if (node.isLink) {\n            node[_target] = this\n            node[_package] = this.package\n            this.linksIn.add(node)\n            if (node.parent) {\n              node.parent[_reloadNamedEdges](node.name)\n            }\n          } else {\n            debug(() => {\n              throw Object.assign(new Error('duplicate node in root setter'), {\n                path: this.path,\n                realpath: this.realpath,\n                root: root.realpath,\n              })\n            })\n          }\n        }\n      }\n    }\n\n    // reload all edgesIn where the root doesn't match, so we don't have\n    // cross-tree dependency graphs\n    for (const edge of this.edgesIn) {\n      if (edge.from.root !== root) {\n        edge.reload()\n      }\n    }\n    // reload all edgesOut where root doens't match, or is missing, since\n    // it might not be missing in the new tree\n    for (const edge of this.edgesOut.values()) {\n      if (!edge.to || edge.to.root !== root) {\n        edge.reload()\n      }\n    }\n\n    // now make sure our family comes along for the ride!\n    const family = new Set([\n      ...this.fsChildren,\n      ...this.children.values(),\n      ...this.inventory.values(),\n    ].filter(n => n !== this))\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child[_delistFromMeta]()\n        child[_parent] = null\n        this.children.delete(child.name)\n        child[_fsParent] = null\n        this.fsChildren.delete(child)\n        for (const l of child.linksIn) {\n          l[_target] = null\n          child.linksIn.delete(l)\n        }\n      }\n    }\n    for (const child of family) {\n      if (child.root !== root) {\n        child.root = root\n      }\n    }\n\n    // if we had a target, and didn't find one in the new root, then bring\n    // it over as well, but only if we're setting the link into a new root,\n    // as we don't want to lose the target any time we remove a link.\n    if (this.isLink && target && !this.target && root !== this) {\n      target.root = root\n    }\n\n    // tree should always be valid upon root setter completion.\n    treeCheck(this)\n    treeCheck(root)\n  }\n\n  get root () {\n    return this[_root] || this\n  }\n\n  [_loadWorkspaces] () {\n    if (!this[_workspaces]) {\n      return\n    }\n\n    for (const [name, path] of this[_workspaces].entries()) {\n      new Edge({ from: this, name, spec: `file:${path}`, type: 'workspace' })\n    }\n  }\n\n  [_loadDeps] () {\n    // Caveat!  Order is relevant!\n    // Packages in optionalDependencies are optional.\n    // Packages in both deps and devDeps are required.\n    // Note the subtle breaking change from v6: it is no longer possible\n    // to have a different spec for a devDep than production dep.\n\n    // Linked targets that are disconnected from the tree are tops,\n    // but don't have a 'path' field, only a 'realpath', because we\n    // don't know their canonical location. We don't need their devDeps.\n    const pd = this.package.peerDependencies\n    if (pd && typeof pd === 'object' && !this.legacyPeerDeps) {\n      const pm = this.package.peerDependenciesMeta || {}\n      const peerDependencies = {}\n      const peerOptional = {}\n      for (const [name, dep] of Object.entries(pd)) {\n        if (pm[name] && pm[name].optional) {\n          peerOptional[name] = dep\n        } else {\n          peerDependencies[name] = dep\n        }\n      }\n      this[_loadDepType](peerDependencies, 'peer')\n      this[_loadDepType](peerOptional, 'peerOptional')\n    }\n\n    this[_loadDepType](this.package.dependencies, 'prod')\n    this[_loadDepType](this.package.optionalDependencies, 'optional')\n\n    const { globalTop, isTop, path, sourceReference } = this\n    const {\n      globalTop: srcGlobalTop,\n      isTop: srcTop,\n      path: srcPath,\n    } = sourceReference || {}\n    const thisDev = isTop && !globalTop && path\n    const srcDev = !sourceReference || srcTop && !srcGlobalTop && srcPath\n    if (thisDev && srcDev) {\n      this[_loadDepType](this.package.devDependencies, 'dev')\n    }\n  }\n\n  [_loadDepType] (deps, type) {\n    const ad = this.package.acceptDependencies || {}\n    // Because of the order in which _loadDeps runs, we always want to\n    // prioritize a new edge over an existing one\n    for (const [name, spec] of Object.entries(deps || {})) {\n      const current = this.edgesOut.get(name)\n      if (!current || current.type !== 'workspace') {\n        new Edge({ from: this, name, spec, accept: ad[name], type })\n      }\n    }\n  }\n\n  get fsParent () {\n    const parent = this[_fsParent]\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own fsParent')\n      }\n    })\n    return parent\n  }\n\n  set fsParent (fsParent) {\n    if (!fsParent) {\n      if (this[_fsParent]) {\n        this.root = null\n      }\n      return\n    }\n\n    debug(() => {\n      if (fsParent === this) {\n        throw new Error('setting node to its own fsParent')\n      }\n\n      if (fsParent.realpath === this.realpath) {\n        throw new Error('setting fsParent to same path')\n      }\n\n      // the initial set MUST be an actual walk-up from the realpath\n      // subsequent sets will re-root on the new fsParent's path.\n      if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {\n        throw Object.assign(new Error('setting fsParent improperly'), {\n          path: this.path,\n          realpath: this.realpath,\n          fsParent: {\n            path: fsParent.path,\n            realpath: fsParent.realpath,\n          },\n        })\n      }\n    })\n\n    if (fsParent.isLink) {\n      fsParent = fsParent.target\n    }\n\n    // setting a thing to its own fsParent is not normal, but no-op for safety\n    if (this === fsParent || fsParent.realpath === this.realpath) {\n      return\n    }\n\n    // nothing to do\n    if (this[_fsParent] === fsParent) {\n      return\n    }\n\n    const oldFsParent = this[_fsParent]\n    const newPath = !oldFsParent ? this.path\n      : resolve(fsParent.path, relative(oldFsParent.path, this.path))\n    const nmPath = resolve(fsParent.path, 'node_modules', this.name)\n\n    // this is actually the parent, set that instead\n    if (newPath === nmPath) {\n      this.parent = fsParent\n      return\n    }\n\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    const oldParent = this.parent\n    const oldName = this.name\n    if (this.parent) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange) {\n      this[_changePath](newPath)\n    }\n\n    if (oldParent) {\n      oldParent[_reloadNamedEdges](oldName)\n    }\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = fsParent.root\n  }\n\n  // is it safe to replace one node with another?  check the edges to\n  // make sure no one will get upset.  Note that the node might end up\n  // having its own unmet dependencies, if the new node has new deps.\n  // Note that there are cases where Arborist will opt to insert a node\n  // into the tree even though this function returns false!  This is\n  // necessary when a root dependency is added or updated, or when a\n  // root dependency brings peer deps along with it.  In that case, we\n  // will go ahead and create the invalid state, and then try to resolve\n  // it with more tree construction, because it's a user request.\n  canReplaceWith (node, ignorePeers = []) {\n    if (node.name !== this.name) {\n      return false\n    }\n\n    if (node.packageName !== this.packageName) {\n      return false\n    }\n\n    // XXX need to check for two root nodes?\n    if (node.overrides !== this.overrides) {\n      return false\n    }\n\n    ignorePeers = new Set(ignorePeers)\n\n    // gather up all the deps of this node and that are only depended\n    // upon by deps of this node.  those ones don't count, since\n    // they'll be replaced if this node is replaced anyway.\n    const depSet = gatherDepSet([this], e => e.to !== this && e.valid)\n\n    for (const edge of this.edgesIn) {\n      // when replacing peer sets, we need to be able to replace the entire\n      // peer group, which means we ignore incoming edges from other peers\n      // within the replacement set.\n      const ignored = !this.isTop &&\n        edge.from.parent === this.parent &&\n        edge.peer &&\n        ignorePeers.has(edge.from.name)\n      if (ignored) {\n        continue\n      }\n\n      // only care about edges that don't originate from this node\n      if (!depSet.has(edge.from) && !edge.satisfiedBy(node)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  canReplace (node, ignorePeers) {\n    return node.canReplaceWith(this, ignorePeers)\n  }\n\n  // return true if it's safe to remove this node, because anything that\n  // is depending on it would be fine with the thing that they would resolve\n  // to if it was removed, or nothing is depending on it in the first place.\n  canDedupe (preferDedupe = false) {\n    // not allowed to mess with shrinkwraps or bundles\n    if (this.inDepBundle || this.inShrinkwrap) {\n      return false\n    }\n\n    // it's a top level pkg, or a dep of one\n    if (!this.resolveParent || !this.resolveParent.resolveParent) {\n      return false\n    }\n\n    // no one wants it, remove it\n    if (this.edgesIn.size === 0) {\n      return true\n    }\n\n    const other = this.resolveParent.resolveParent.resolve(this.name)\n\n    // nothing else, need this one\n    if (!other) {\n      return false\n    }\n\n    // if it's the same thing, then always fine to remove\n    if (other.matches(this)) {\n      return true\n    }\n\n    // if the other thing can't replace this, then skip it\n    if (!other.canReplace(this)) {\n      return false\n    }\n\n    // if we prefer dedupe, or if the version is greater/equal, take the other\n    if (preferDedupe || semver.gte(other.version, this.version)) {\n      return true\n    }\n\n    return false\n  }\n\n  satisfies (requested) {\n    if (requested instanceof Edge) {\n      return this.name === requested.name && requested.satisfiedBy(this)\n    }\n\n    const parsed = npa(requested)\n    const { name = this.name, rawSpec: spec } = parsed\n    return this.name === name && this.satisfies(new Edge({\n      from: new Node({ path: this.root.realpath }),\n      type: 'prod',\n      name,\n      spec,\n    }))\n  }\n\n  matches (node) {\n    // if the nodes are literally the same object, obviously a match.\n    if (node === this) {\n      return true\n    }\n\n    // if the names don't match, they're different things, even if\n    // the package contents are identical.\n    if (node.name !== this.name) {\n      return false\n    }\n\n    // if they're links, they match if the targets match\n    if (this.isLink) {\n      return node.isLink && this.target.matches(node.target)\n    }\n\n    // if they're two project root nodes, they're different if the paths differ\n    if (this.isProjectRoot && node.isProjectRoot) {\n      return this.path === node.path\n    }\n\n    // if the integrity matches, then they're the same.\n    if (this.integrity && node.integrity) {\n      return this.integrity === node.integrity\n    }\n\n    // if no integrity, check resolved\n    if (this.resolved && node.resolved) {\n      return this.resolved === node.resolved\n    }\n\n    // if no resolved, check both package name and version\n    // otherwise, conclude that they are different things\n    return this.packageName && node.packageName &&\n      this.packageName === node.packageName &&\n      this.version && node.version &&\n      this.version === node.version\n  }\n\n  // replace this node with the supplied argument\n  // Useful when mutating an ideal tree, so we can avoid having to call\n  // the parent/root setters more than necessary.\n  replaceWith (node) {\n    node.replace(this)\n  }\n\n  replace (node) {\n    this[_delistFromMeta]()\n\n    // if the name matches, but is not identical, we are intending to clobber\n    // something case-insensitively, so merely setting name and path won't\n    // have the desired effect.  just set the path so it'll collide in the\n    // parent's children map, and leave it at that.\n    const nameMatch = node.parent &&\n      node.parent.children.get(this.name) === node\n    if (nameMatch) {\n      this.path = resolve(node.parent.path, 'node_modules', this.name)\n    } else {\n      this.path = node.path\n      this.name = node.name\n    }\n\n    if (!this.isLink) {\n      this.realpath = this.path\n    }\n    this[_refreshLocation]()\n\n    // keep children when a node replaces another\n    if (!this.isLink) {\n      for (const kid of node.children.values()) {\n        kid.parent = this\n      }\n    }\n\n    if (!node.isRoot) {\n      this.root = node.root\n    }\n\n    treeCheck(this)\n  }\n\n  get inShrinkwrap () {\n    return this.parent &&\n      (this.parent.hasShrinkwrap || this.parent.inShrinkwrap)\n  }\n\n  get parent () {\n    const parent = this[_parent]\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if (parent === this) {\n        throw new Error('node set to its own parent')\n      }\n    })\n    return parent\n  }\n\n  // This setter keeps everything in order when we move a node from\n  // one point in a logical tree to another.  Edges get reloaded,\n  // metadata updated, etc.  It's also called when we *replace* a node\n  // with another by the same name (eg, to update or dedupe).\n  // This does a couple of walks out on the node_modules tree, recursing\n  // into child nodes.  However, as setting the parent is typically done\n  // with nodes that don't have have many children, and (deduped) package\n  // trees tend to be broad rather than deep, it's not that bad.\n  // The only walk that starts from the parent rather than this node is\n  // limited by edge name.\n  set parent (parent) {\n    // when setting to null, just remove it from the tree entirely\n    if (!parent) {\n      // but only delete it if we actually had a parent in the first place\n      // otherwise it's just setting to null when it's already null\n      if (this[_parent]) {\n        this.root = null\n      }\n      return\n    }\n\n    if (parent.isLink) {\n      parent = parent.target\n    }\n\n    // setting a thing to its own parent is not normal, but no-op for safety\n    if (this === parent) {\n      return\n    }\n\n    const oldParent = this[_parent]\n\n    // nothing to do\n    if (oldParent === parent) {\n      return\n    }\n\n    // ok now we know something is actually changing, and parent is not a link\n    const newPath = resolve(parent.path, 'node_modules', this.name)\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    if (oldParent) {\n      oldParent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange) {\n      this[_changePath](newPath)\n    }\n\n    if (parent.overrides) {\n      this.overrides = parent.overrides.getNodeRule(this)\n    }\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = parent.root\n  }\n\n  // Call this before changing path or updating the _root reference.\n  // Removes the node from its root the metadata and inventory.\n  [_delistFromMeta] () {\n    const root = this.root\n    if (!root.realpath || !this.path) {\n      return\n    }\n    root.inventory.delete(this)\n    root.tops.delete(this)\n    if (root.meta) {\n      root.meta.delete(this.path)\n    }\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if ([...root.inventory.values()].includes(this)) {\n        throw new Error('failed to delist')\n      }\n    })\n  }\n\n  // update this.path/realpath and the paths of all children/fsChildren\n  [_changePath] (newPath) {\n    // have to de-list before changing paths\n    this[_delistFromMeta]()\n    const oldPath = this.path\n    this.path = newPath\n    const namePattern = /(?:^|\\/|\\\\)node_modules[\\\\/](@[^/\\\\]+[\\\\/][^\\\\/]+|[^\\\\/]+)$/\n    const nameChange = newPath.match(namePattern)\n    if (nameChange && this.name !== nameChange[1]) {\n      this.name = nameChange[1].replace(/\\\\/g, '/')\n    }\n\n    // if we move a link target, update link realpaths\n    if (!this.isLink) {\n      this.realpath = newPath\n      for (const link of this.linksIn) {\n        link[_delistFromMeta]()\n        link.realpath = newPath\n        link[_refreshLocation]()\n      }\n    }\n    // if we move /x to /y, then a module at /x/a/b becomes /y/a/b\n    for (const child of this.fsChildren) {\n      child[_changePath](resolve(newPath, relative(oldPath, child.path)))\n    }\n    for (const [name, child] of this.children.entries()) {\n      child[_changePath](resolve(newPath, 'node_modules', name))\n    }\n\n    this[_refreshLocation]()\n  }\n\n  // Called whenever the root/parent is changed.\n  // NB: need to remove from former root's meta/inventory and then update\n  // this.path BEFORE calling this method!\n  [_refreshLocation] () {\n    const root = this.root\n    const loc = relpath(root.realpath, this.path)\n\n    this.location = loc\n\n    root.inventory.add(this)\n    if (root.meta) {\n      root.meta.add(this)\n    }\n  }\n\n  assertRootOverrides () {\n    if (!this.isProjectRoot || !this.overrides) {\n      return\n    }\n\n    for (const edge of this.edgesOut.values()) {\n      // if these differ an override has been applied, those are not allowed\n      // for top level dependencies so throw an error\n      if (edge.spec !== edge.rawSpec && !edge.spec.startsWith('$')) {\n        throw Object.assign(new Error(`Override for ${edge.name}@${edge.rawSpec} conflicts with direct dependency`), { code: 'EOVERRIDE' })\n      }\n    }\n  }\n\n  addEdgeOut (edge) {\n    if (this.overrides) {\n      edge.overrides = this.overrides.getEdgeRule(edge)\n    }\n\n    this.edgesOut.set(edge.name, edge)\n  }\n\n  addEdgeIn (edge) {\n    if (edge.overrides) {\n      this.overrides = edge.overrides\n    }\n\n    this.edgesIn.add(edge)\n\n    // try to get metadata from the yarn.lock file\n    if (this.root.meta) {\n      this.root.meta.addEdge(edge)\n    }\n  }\n\n  [_reloadNamedEdges] (name, rootLoc = this.location) {\n    const edge = this.edgesOut.get(name)\n    // if we don't have an edge, do nothing, but keep descending\n    const rootLocResolved = edge && edge.to &&\n      edge.to.location === `${rootLoc}/node_modules/${edge.name}`\n    const sameResolved = edge && this.resolve(name) === edge.to\n    const recheck = rootLocResolved || !sameResolved\n    if (edge && recheck) {\n      edge.reload(true)\n    }\n    for (const c of this.children.values()) {\n      c[_reloadNamedEdges](name, rootLoc)\n    }\n\n    for (const c of this.fsChildren) {\n      c[_reloadNamedEdges](name, rootLoc)\n    }\n  }\n\n  get isLink () {\n    return false\n  }\n\n  get target () {\n    return this\n  }\n\n  set target (n) {\n    debug(() => {\n      throw Object.assign(new Error('cannot set target on non-Link Nodes'), {\n        path: this.path,\n      })\n    })\n  }\n\n  get depth () {\n    return this.isTop ? 0 : this.parent.depth + 1\n  }\n\n  get isTop () {\n    return !this.parent || this.globalTop\n  }\n\n  get top () {\n    return this.isTop ? this : this.parent.top\n  }\n\n  get isFsTop () {\n    return !this.fsParent\n  }\n\n  get fsTop () {\n    return this.isFsTop ? this : this.fsParent.fsTop\n  }\n\n  get resolveParent () {\n    return this.parent || this.fsParent\n  }\n\n  resolve (name) {\n    /* istanbul ignore next - should be impossible,\n     * but I keep doing this mistake in tests */\n    debug(() => {\n      if (typeof name !== 'string' || !name) {\n        throw new Error('non-string passed to Node.resolve')\n      }\n    })\n    const mine = this.children.get(name)\n    if (mine) {\n      return mine\n    }\n    const resolveParent = this.resolveParent\n    if (resolveParent) {\n      return resolveParent.resolve(name)\n    }\n    return null\n  }\n\n  inNodeModules () {\n    const rp = this.realpath\n    const name = this.name\n    const scoped = name.charAt(0) === '@'\n    const d = dirname(rp)\n    const nm = scoped ? dirname(d) : d\n    const dir = dirname(nm)\n    const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp)\n    return base === name && basename(nm) === 'node_modules' ? dir : false\n  }\n\n  toJSON () {\n    return printableTree(this)\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nmodule.exports = Node\n","// An edge in the dependency graph\n// Represents a dependency relationship of some kind\n\nconst util = require('util')\nconst npa = require('npm-package-arg')\nconst depValid = require('./dep-valid.js')\nconst _from = Symbol('_from')\nconst _to = Symbol('_to')\nconst _type = Symbol('_type')\nconst _spec = Symbol('_spec')\nconst _accept = Symbol('_accept')\nconst _name = Symbol('_name')\nconst _error = Symbol('_error')\nconst _loadError = Symbol('_loadError')\nconst _setFrom = Symbol('_setFrom')\nconst _explain = Symbol('_explain')\nconst _explanation = Symbol('_explanation')\n\nconst types = new Set([\n  'prod',\n  'dev',\n  'optional',\n  'peer',\n  'peerOptional',\n  'workspace',\n])\n\nclass ArboristEdge {}\nconst printableEdge = (edge) => {\n  const edgeFrom = edge.from && edge.from.location\n  const edgeTo = edge.to && edge.to.location\n  const override = edge.overrides && edge.overrides.value\n\n  return Object.assign(new ArboristEdge(), {\n    name: edge.name,\n    spec: edge.spec,\n    type: edge.type,\n    ...(edgeFrom != null ? { from: edgeFrom } : {}),\n    ...(edgeTo ? { to: edgeTo } : {}),\n    ...(edge.error ? { error: edge.error } : {}),\n    ...(edge.peerConflicted ? { peerConflicted: true } : {}),\n    ...(override ? { overridden: override } : {}),\n  })\n}\n\nclass Edge {\n  constructor (options) {\n    const { type, name, spec, accept, from, overrides } = options\n\n    if (typeof spec !== 'string') {\n      throw new TypeError('must provide string spec')\n    }\n\n    if (type === 'workspace' && npa(spec).type !== 'directory') {\n      throw new TypeError('workspace edges must be a symlink')\n    }\n\n    this[_spec] = spec\n\n    if (overrides !== undefined) {\n      this.overrides = overrides\n    }\n\n    if (accept !== undefined) {\n      if (typeof accept !== 'string') {\n        throw new TypeError('accept field must be a string if provided')\n      }\n      this[_accept] = accept || '*'\n    }\n\n    if (typeof name !== 'string') {\n      throw new TypeError('must provide dependency name')\n    }\n    this[_name] = name\n\n    if (!types.has(type)) {\n      throw new TypeError(\n        `invalid type: ${type}\\n` +\n        `(valid types are: ${Edge.types.join(', ')})`)\n    }\n    this[_type] = type\n    if (!from) {\n      throw new TypeError('must provide \"from\" node')\n    }\n    this[_setFrom](from)\n    this[_error] = this[_loadError]()\n    this.peerConflicted = false\n  }\n\n  satisfiedBy (node) {\n    if (node.name !== this.name) {\n      return false\n    }\n\n    return depValid(node, this.spec, this.accept, this.from)\n  }\n\n  explain (seen = []) {\n    if (this[_explanation]) {\n      return this[_explanation]\n    }\n\n    return this[_explanation] = this[_explain](seen)\n  }\n\n  // return the edge data, and an explanation of how that edge came to be here\n  [_explain] (seen) {\n    const { error, from, bundled } = this\n    return {\n      type: this.type,\n      name: this.name,\n      spec: this.spec,\n      ...(this.rawSpec !== this.spec ? {\n        rawSpec: this.rawSpec,\n        overridden: true,\n      } : {}),\n      ...(bundled ? { bundled } : {}),\n      ...(error ? { error } : {}),\n      ...(from ? { from: from.explain(null, seen) } : {}),\n    }\n  }\n\n  get bundled () {\n    if (!this.from) {\n      return false\n    }\n    const { package: { bundleDependencies = [] } } = this.from\n    return bundleDependencies.includes(this.name)\n  }\n\n  get workspace () {\n    return this[_type] === 'workspace'\n  }\n\n  get prod () {\n    return this[_type] === 'prod'\n  }\n\n  get dev () {\n    return this[_type] === 'dev'\n  }\n\n  get optional () {\n    return this[_type] === 'optional' || this[_type] === 'peerOptional'\n  }\n\n  get peer () {\n    return this[_type] === 'peer' || this[_type] === 'peerOptional'\n  }\n\n  get type () {\n    return this[_type]\n  }\n\n  get name () {\n    return this[_name]\n  }\n\n  get rawSpec () {\n    return this[_spec]\n  }\n\n  get spec () {\n    if (this.overrides && this.overrides.value && this.overrides.name === this.name) {\n      if (this.overrides.value.startsWith('$')) {\n        const ref = this.overrides.value.slice(1)\n        const pkg = this.from.root.package\n        const overrideSpec = (pkg.devDependencies && pkg.devDependencies[ref]) ||\n            (pkg.optionalDependencies && pkg.optionalDependencies[ref]) ||\n            (pkg.dependencies && pkg.dependencies[ref]) ||\n            (pkg.peerDependencies && pkg.peerDependencies[ref])\n\n        if (overrideSpec) {\n          return overrideSpec\n        }\n\n        throw new Error(`Unable to resolve reference ${this.overrides.value}`)\n      }\n      return this.overrides.value\n    }\n    return this[_spec]\n  }\n\n  get accept () {\n    return this[_accept]\n  }\n\n  get valid () {\n    return !this.error\n  }\n\n  get missing () {\n    return this.error === 'MISSING'\n  }\n\n  get invalid () {\n    return this.error === 'INVALID'\n  }\n\n  get peerLocal () {\n    return this.error === 'PEER LOCAL'\n  }\n\n  get error () {\n    this[_error] = this[_error] || this[_loadError]()\n    return this[_error] === 'OK' ? null : this[_error]\n  }\n\n  [_loadError] () {\n    return !this[_to] ? (this.optional ? null : 'MISSING')\n      : this.peer && this.from === this.to.parent && !this.from.isTop ? 'PEER LOCAL'\n      : !this.satisfiedBy(this.to) ? 'INVALID'\n      : 'OK'\n  }\n\n  reload (hard = false) {\n    this[_explanation] = null\n    const newTo = this[_from].resolve(this.name)\n    if (newTo !== this[_to]) {\n      if (this[_to]) {\n        this[_to].edgesIn.delete(this)\n      }\n      this[_to] = newTo\n      this[_error] = this[_loadError]()\n      if (this[_to]) {\n        this[_to].addEdgeIn(this)\n      }\n    } else if (hard) {\n      this[_error] = this[_loadError]()\n    }\n  }\n\n  detach () {\n    this[_explanation] = null\n    if (this[_to]) {\n      this[_to].edgesIn.delete(this)\n    }\n    this[_from].edgesOut.delete(this.name)\n    this[_to] = null\n    this[_error] = 'DETACHED'\n    this[_from] = null\n  }\n\n  [_setFrom] (node) {\n    this[_explanation] = null\n    this[_from] = node\n    if (node.edgesOut.has(this.name)) {\n      node.edgesOut.get(this.name).detach()\n    }\n\n    node.addEdgeOut(this)\n    this.reload()\n  }\n\n  get from () {\n    return this[_from]\n  }\n\n  get to () {\n    return this[_to]\n  }\n\n  toJSON () {\n    return printableEdge(this)\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nEdge.types = [...types]\nEdge.errors = [\n  'DETACHED',\n  'MISSING',\n  'PEER LOCAL',\n  'INVALID',\n]\n\nmodule.exports = Edge\n","// Do not rely on package._fields, so that we don't throw\n// false failures if a tree is generated by other clients.\n// Only relies on child.resolved, which MAY come from\n// client-specific package.json meta _fields, but most of\n// the time will be pulled out of a lockfile\n\nconst semver = require('semver')\nconst npa = require('npm-package-arg')\nconst { relative } = require('path')\nconst fromPath = require('./from-path.js')\n\nconst depValid = (child, requested, requestor) => {\n  // NB: we don't do much to verify 'tag' type requests.\n  // Just verify that we got a remote resolution.  Presumably, it\n  // came from a registry and was tagged at some point.\n\n  if (typeof requested === 'string') {\n    try {\n      // tarball/dir must have resolved to the same tgz on disk, but for\n      // file: deps that depend on other files/dirs, we must resolve the\n      // location based on the *requestor* file/dir, not where it ends up.\n      // '' is equivalent to '*'\n      requested = npa.resolve(child.name, requested || '*', fromPath(requestor))\n    } catch (er) {\n      // Not invalid because the child doesn't match, but because\n      // the spec itself is not supported.  Nothing would match,\n      // so the edge is definitely not valid and never can be.\n      er.dependency = child.name\n      er.requested = requested\n      requestor.errors.push(er)\n      return false\n    }\n  }\n\n  // if the lockfile is super old, or hand-modified,\n  // then it's possible to hit this state.\n  if (!requested) {\n    const er = new Error('Invalid dependency specifier')\n    er.dependency = child.name\n    er.requested = requested\n    requestor.errors.push(er)\n    return false\n  }\n\n  switch (requested.type) {\n    case 'range':\n      if (requested.fetchSpec === '*') {\n        return true\n      }\n      // fallthrough\n    case 'version':\n      // if it's a version or a range other than '*', semver it\n      return semver.satisfies(child.version, requested.fetchSpec, true)\n\n    case 'directory':\n      // directory must be a link to the specified folder\n      return !!child.isLink &&\n        relative(child.realpath, requested.fetchSpec) === ''\n\n    case 'file':\n      return tarballValid(child, requested, requestor)\n\n    case 'alias':\n      // check that the alias target is valid\n      return depValid(child, requested.subSpec, requestor)\n\n    case 'tag':\n      // if it's a tag, we just verify that it has a tarball resolution\n      // presumably, it came from the registry and was tagged at some point\n      return child.resolved && npa(child.resolved).type === 'remote'\n\n    case 'remote':\n      // verify that we got it from the desired location\n      return child.resolved === requested.fetchSpec\n\n    case 'git': {\n      // if it's a git type, verify that they're the same repo\n      //\n      // if it specifies a definite commit, then it must have the\n      // same commit to be considered the same repo\n      //\n      // if it has a #semver:<range> specifier, verify that the\n      // version in the package is in the semver range\n      const resRepo = npa(child.resolved || '')\n      const resHost = resRepo.hosted\n      const reqHost = requested.hosted\n      const reqCommit = /^[a-fA-F0-9]{40}$/.test(requested.gitCommittish || '')\n      const nc = { noCommittish: !reqCommit }\n      const sameRepo =\n        resHost ? reqHost && reqHost.ssh(nc) === resHost.ssh(nc)\n        : resRepo.fetchSpec === requested.fetchSpec\n\n      return !sameRepo ? false\n        : !requested.gitRange ? true\n        : semver.satisfies(child.package.version, requested.gitRange, {\n          loose: true,\n        })\n    }\n\n    default: // unpossible, just being cautious\n      break\n  }\n\n  const er = new Error('Unsupported dependency type')\n  er.dependency = child.name\n  er.requested = requested\n  requestor.errors.push(er)\n  return false\n}\n\nconst tarballValid = (child, requested, requestor) => {\n  if (child.isLink) {\n    return false\n  }\n\n  if (child.resolved) {\n    return child.resolved.replace(/\\\\/g, '/') === `file:${requested.fetchSpec.replace(/\\\\/g, '/')}`\n  }\n\n  // if we have a legacy mutated package.json file.  we can't be 100%\n  // sure that it resolved to the same file, but if it was the same\n  // request, that's a pretty good indicator of sameness.\n  if (child.package._requested) {\n    return child.package._requested.saveSpec === requested.saveSpec\n  }\n\n  // ok, we're probably dealing with some legacy cruft here, not much\n  // we can do at this point unfortunately.\n  return false\n}\n\nmodule.exports = (child, requested, accept, requestor) =>\n  depValid(child, requested, requestor) ||\n  (typeof accept === 'string' ? depValid(child, accept, requestor) : false)\n","// file dependencies need their dependencies resolved based on the\n// location where the tarball was found, not the location where they\n// end up getting installed.  directory (ie, symlink) deps also need\n// to be resolved based on their targets, but that's what realpath is\n\nconst { dirname } = require('path')\nconst npa = require('npm-package-arg')\n\nconst fromPath = (node, spec) =>\n  spec && spec.type === 'file' ? dirname(spec.fetchSpec)\n  : node.realpath\n\nmodule.exports = node => fromPath(node, node.resolved && npa(node.resolved))\n","// a class to manage an inventory and set of indexes of\n// a set of objects based on specific fields.\n// primary is the primary index key.\n// keys is the set of fields to be able to query.\nconst _primaryKey = Symbol('_primaryKey')\nconst _index = Symbol('_index')\nconst defaultKeys = ['name', 'license', 'funding', 'realpath', 'packageName']\nconst { hasOwnProperty } = Object.prototype\nconst debug = require('./debug.js')\n\n// handling for the outdated \"licenses\" array, just pick the first one\n// also support the alternative spelling \"licence\"\nconst getLicense = pkg => {\n  if (pkg) {\n    const lic = pkg.license || pkg.licence\n    if (lic) {\n      return lic\n    }\n    const lics = pkg.licenses || pkg.licences\n    if (Array.isArray(lics)) {\n      return lics[0]\n    }\n  }\n}\n\nclass Inventory extends Map {\n  constructor (opt = {}) {\n    const { primary, keys } = opt\n    super()\n    this[_primaryKey] = primary || 'location'\n    this[_index] = (keys || defaultKeys).reduce((index, i) => {\n      index.set(i, new Map())\n      return index\n    }, new Map())\n  }\n\n  get primaryKey () {\n    return this[_primaryKey]\n  }\n\n  get indexes () {\n    return [...this[_index].keys()]\n  }\n\n  * filter (fn) {\n    for (const node of this.values()) {\n      if (fn(node)) {\n        yield node\n      }\n    }\n  }\n\n  add (node) {\n    const root = super.get('')\n    if (root && node.root !== root && node.root !== root.root) {\n      debug(() => {\n        throw Object.assign(new Error('adding external node to inventory'), {\n          root: root.path,\n          node: node.path,\n          nodeRoot: node.root.path,\n        })\n      })\n      return\n    }\n\n    const current = super.get(node[this.primaryKey])\n    if (current) {\n      if (current === node) {\n        return\n      }\n      this.delete(current)\n    }\n    super.set(node[this.primaryKey], node)\n    for (const [key, map] of this[_index].entries()) {\n      // if the node has the value, but it's false, then use that\n      const val_ = hasOwnProperty.call(node, key) ? node[key]\n        : key === 'license' ? getLicense(node.package)\n        : node[key] ? node[key]\n        : node.package && node.package[key]\n      const val = typeof val_ === 'string' ? val_\n        : !val_ || typeof val_ !== 'object' ? val_\n        : key === 'license' ? val_.type\n        : key === 'funding' ? val_.url\n        : /* istanbul ignore next - not used */ val_\n      const set = map.get(val) || new Set()\n      set.add(node)\n      map.set(val, set)\n    }\n  }\n\n  delete (node) {\n    if (!this.has(node)) {\n      return\n    }\n\n    super.delete(node[this.primaryKey])\n    for (const [key, map] of this[_index].entries()) {\n      const val = node[key] !== undefined ? node[key]\n        : (node[key] || (node.package && node.package[key]))\n      const set = map.get(val)\n      if (set) {\n        set.delete(node)\n        if (set.size === 0) {\n          map.delete(node[key])\n        }\n      }\n    }\n  }\n\n  query (key, val) {\n    const map = this[_index].get(key)\n    return map && (arguments.length === 2 ? map.get(val) : map.keys()) ||\n      new Set()\n  }\n\n  has (node) {\n    return super.get(node[this.primaryKey]) === node\n  }\n\n  set (k, v) {\n    throw new Error('direct set() not supported, use inventory.add(node)')\n  }\n}\n\nmodule.exports = Inventory\n","const npa = require('npm-package-arg')\nconst semver = require('semver')\n\nclass OverrideSet {\n  constructor ({ overrides, key, parent }) {\n    this.parent = parent\n    this.children = new Map()\n\n    if (typeof overrides === 'string') {\n      overrides = { '.': overrides }\n    }\n\n    // change a literal empty string to * so we can use truthiness checks on\n    // the value property later\n    if (overrides['.'] === '') {\n      overrides['.'] = '*'\n    }\n\n    if (parent) {\n      const spec = npa(key)\n      if (!spec.name) {\n        throw new Error(`Override without name: ${key}`)\n      }\n\n      this.name = spec.name\n      spec.name = ''\n      this.key = key\n      this.keySpec = spec.rawSpec === '' ? '' : spec.toString()\n      this.value = overrides['.'] || this.keySpec\n    }\n\n    for (const [key, childOverrides] of Object.entries(overrides)) {\n      if (key === '.') {\n        continue\n      }\n\n      const child = new OverrideSet({\n        parent: this,\n        key,\n        overrides: childOverrides,\n      })\n\n      this.children.set(child.key, child)\n    }\n  }\n\n  getEdgeRule (edge) {\n    for (const rule of this.ruleset.values()) {\n      if (rule.name !== edge.name) {\n        continue\n      }\n\n      if (rule.keySpec === '' ||\n        semver.intersects(edge.spec, rule.keySpec)) {\n        return rule\n      }\n    }\n\n    return this\n  }\n\n  getNodeRule (node) {\n    for (const rule of this.ruleset.values()) {\n      if (rule.name !== node.name) {\n        continue\n      }\n\n      if (rule.keySpec === '' ||\n        semver.satisfies(node.version, rule.keySpec) ||\n        semver.satisfies(node.version, rule.value)) {\n        return rule\n      }\n    }\n\n    return this\n  }\n\n  getMatchingRule (node) {\n    for (const rule of this.ruleset.values()) {\n      if (rule.name !== node.name) {\n        continue\n      }\n\n      if (rule.keySpec === '' ||\n        semver.satisfies(node.version, rule.keySpec) ||\n        semver.satisfies(node.version, rule.value)) {\n        return rule\n      }\n    }\n\n    return null\n  }\n\n  * ancestry () {\n    for (let ancestor = this; ancestor; ancestor = ancestor.parent) {\n      yield ancestor\n    }\n  }\n\n  get isRoot () {\n    return !this.parent\n  }\n\n  get ruleset () {\n    const ruleset = new Map()\n\n    for (const override of this.ancestry()) {\n      for (const kid of override.children.values()) {\n        if (!ruleset.has(kid.key)) {\n          ruleset.set(kid.key, kid)\n        }\n      }\n\n      if (!override.isRoot && !ruleset.has(override.key)) {\n        ruleset.set(override.key, override)\n      }\n    }\n\n    return ruleset\n  }\n}\n\nmodule.exports = OverrideSet\n","// Given a set of nodes in a tree, and a filter function to test\n// incoming edges to the dep set that should be ignored otherwise.\n//\n// find the set of deps that are only depended upon by nodes in the set, or\n// their dependencies, or edges that are ignored.\n//\n// Used when figuring out what to prune when replacing a node with a newer\n// version, or when an optional dep fails to install.\n\nconst gatherDepSet = (set, edgeFilter) => {\n  const deps = new Set(set)\n\n  // add the full set of dependencies.  note that this loop will continue\n  // as the deps set increases in size.\n  for (const node of deps) {\n    for (const edge of node.edgesOut.values()) {\n      if (edge.to && edgeFilter(edge)) {\n        deps.add(edge.to)\n      }\n    }\n  }\n\n  // now remove all nodes in the set that have a dependant outside the set\n  // if any change is made, then re-check\n  // continue until no changes made, or deps set evaporates fully.\n  let changed = true\n  while (changed === true && deps.size > 0) {\n    changed = false\n    for (const dep of deps) {\n      for (const edge of dep.edgesIn) {\n        if (!deps.has(edge.from) && edgeFilter(edge)) {\n          changed = true\n          deps.delete(dep)\n          break\n        }\n      }\n    }\n  }\n\n  return deps\n}\n\nmodule.exports = gatherDepSet\n","// take a path and a resolved value, and turn it into a resolution from\n// the given new path.  This is used with converting a package.json's\n// relative file: path into one suitable for a lockfile, or between\n// lockfiles, and for converting hosted git repos to a consistent url type.\nconst npa = require('npm-package-arg')\nconst relpath = require('./relpath.js')\nconst consistentResolve = (resolved, fromPath, toPath, relPaths = false) => {\n  if (!resolved) {\n    return null\n  }\n\n  try {\n    const hostedOpt = { noCommittish: false }\n    const {\n      fetchSpec,\n      saveSpec,\n      type,\n      hosted,\n      rawSpec,\n      raw,\n    } = npa(resolved, fromPath)\n    const isPath = type === 'file' || type === 'directory'\n    return isPath && !relPaths ? `file:${fetchSpec}`\n      : isPath ? 'file:' + (toPath ? relpath(toPath, fetchSpec) : fetchSpec)\n      : hosted ? `git+${\n        hosted.auth ? hosted.https(hostedOpt) : hosted.sshurl(hostedOpt)\n      }`\n      : type === 'git' ? saveSpec\n      // always return something.  'foo' is interpreted as 'foo@' otherwise.\n      : rawSpec === '' && raw.slice(-1) !== '@' ? raw\n      // just strip off the name, but otherwise return as-is\n      : rawSpec\n  } catch (_) {\n    // whatever we passed in was not acceptable to npa.\n    // leave it 100% untouched.\n    return resolved\n  }\n}\nmodule.exports = consistentResolve\n","// helper function to output a clearer visualization\n// of the current node and its descendents\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst util = require('util')\nconst relpath = require('./relpath.js')\n\nclass ArboristNode {\n  constructor (tree, path) {\n    this.name = tree.name\n    if (tree.packageName && tree.packageName !== this.name) {\n      this.packageName = tree.packageName\n    }\n    if (tree.version) {\n      this.version = tree.version\n    }\n    this.location = tree.location\n    this.path = tree.path\n    if (tree.realpath !== this.path) {\n      this.realpath = tree.realpath\n    }\n    if (tree.resolved !== null) {\n      this.resolved = tree.resolved\n    }\n    if (tree.extraneous) {\n      this.extraneous = true\n    }\n    if (tree.dev) {\n      this.dev = true\n    }\n    if (tree.optional) {\n      this.optional = true\n    }\n    if (tree.devOptional && !tree.dev && !tree.optional) {\n      this.devOptional = true\n    }\n    if (tree.peer) {\n      this.peer = true\n    }\n    if (tree.inBundle) {\n      this.bundled = true\n    }\n    if (tree.inDepBundle) {\n      this.bundler = tree.getBundler().location\n    }\n    if (tree.isProjectRoot) {\n      this.isProjectRoot = true\n    }\n    if (tree.isWorkspace) {\n      this.isWorkspace = true\n    }\n    const bd = tree.package && tree.package.bundleDependencies\n    if (bd && bd.length) {\n      this.bundleDependencies = bd\n    }\n    if (tree.inShrinkwrap) {\n      this.inShrinkwrap = true\n    } else if (tree.hasShrinkwrap) {\n      this.hasShrinkwrap = true\n    }\n    if (tree.error) {\n      this.error = treeError(tree.error)\n    }\n    if (tree.errors && tree.errors.length) {\n      this.errors = tree.errors.map(treeError)\n    }\n\n    if (tree.overrides) {\n      this.overrides = new Map([...tree.overrides.ruleset.values()]\n        .map((override) => [override.key, override.value]))\n    }\n\n    // edgesOut sorted by name\n    if (tree.edgesOut.size) {\n      this.edgesOut = new Map([...tree.edgesOut.entries()]\n        .sort(([a], [b]) => localeCompare(a, b))\n        .map(([name, edge]) => [name, new EdgeOut(edge)]))\n    }\n\n    // edgesIn sorted by location\n    if (tree.edgesIn.size) {\n      this.edgesIn = new Set([...tree.edgesIn]\n        .sort((a, b) => localeCompare(a.from.location, b.from.location))\n        .map(edge => new EdgeIn(edge)))\n    }\n\n    if (tree.workspaces && tree.workspaces.size) {\n      this.workspaces = new Map([...tree.workspaces.entries()]\n        .map(([name, path]) => [name, relpath(tree.root.realpath, path)]))\n    }\n\n    // fsChildren sorted by path\n    if (tree.fsChildren.size) {\n      this.fsChildren = new Set([...tree.fsChildren]\n        .sort(({ path: a }, { path: b }) => localeCompare(a, b))\n        .map(tree => printableTree(tree, path)))\n    }\n\n    // children sorted by name\n    if (tree.children.size) {\n      this.children = new Map([...tree.children.entries()]\n        .sort(([a], [b]) => localeCompare(a, b))\n        .map(([name, tree]) => [name, printableTree(tree, path)]))\n    }\n  }\n}\n\nclass ArboristVirtualNode extends ArboristNode {\n  constructor (tree, path) {\n    super(tree, path)\n    this.sourceReference = printableTree(tree.sourceReference, path)\n  }\n}\n\nclass ArboristLink extends ArboristNode {\n  constructor (tree, path) {\n    super(tree, path)\n    this.target = printableTree(tree.target, path)\n  }\n}\n\nconst treeError = ({ code, path }) => ({\n  code,\n  ...(path ? { path } : {}),\n})\n\n// print out edges without dumping the full node all over again\n// this base class will toJSON as a plain old object, but the\n// util.inspect() output will be a bit cleaner\nclass Edge {\n  constructor (edge) {\n    this.type = edge.type\n    this.name = edge.name\n    this.spec = edge.rawSpec || '*'\n    if (edge.rawSpec !== edge.spec) {\n      this.override = edge.spec\n    }\n    if (edge.error) {\n      this.error = edge.error\n    }\n    if (edge.peerConflicted) {\n      this.peerConflicted = edge.peerConflicted\n    }\n  }\n}\n\n// don't care about 'from' for edges out\nclass EdgeOut extends Edge {\n  constructor (edge) {\n    super(edge)\n    this.to = edge.to && edge.to.location\n  }\n\n  [util.inspect.custom] () {\n    return `{ ${this.type} ${this.name}@${this.spec}${\n      this.override ? ` overridden:${this.override}` : ''\n    }${\n      this.to ? ' -> ' + this.to : ''\n    }${\n      this.error ? ' ' + this.error : ''\n    }${\n      this.peerConflicted ? ' peerConflicted' : ''\n    } }`\n  }\n}\n\n// don't care about 'to' for edges in\nclass EdgeIn extends Edge {\n  constructor (edge) {\n    super(edge)\n    this.from = edge.from && edge.from.location\n  }\n\n  [util.inspect.custom] () {\n    return `{ ${this.from || '\"\"'} ${this.type} ${this.name}@${this.spec}${\n      this.error ? ' ' + this.error : ''\n    }${\n      this.peerConflicted ? ' peerConflicted' : ''\n    } }`\n  }\n}\n\nconst printableTree = (tree, path = []) => {\n  if (!tree) {\n    return tree\n  }\n\n  const Cls = tree.isLink ? ArboristLink\n    : tree.sourceReference ? ArboristVirtualNode\n    : ArboristNode\n  if (path.includes(tree)) {\n    const obj = Object.create(Cls.prototype)\n    return Object.assign(obj, { location: tree.location })\n  }\n  path.push(tree)\n  return new Cls(tree, path)\n}\n\nmodule.exports = printableTree\n","// package children are represented with a Map object, but many file systems\n// are case-insensitive and unicode-normalizing, so we need to treat\n// node.children.get('FOO') and node.children.get('foo') as the same thing.\n\nconst _keys = Symbol('keys')\nconst _normKey = Symbol('normKey')\nconst normalize = s => s.normalize('NFKD').toLowerCase()\nconst OGMap = Map\nmodule.exports = class Map extends OGMap {\n  constructor (items = []) {\n    super()\n    this[_keys] = new OGMap()\n    for (const [key, val] of items) {\n      this.set(key, val)\n    }\n  }\n\n  [_normKey] (key) {\n    return typeof key === 'string' ? normalize(key) : key\n  }\n\n  get (key) {\n    const normKey = this[_normKey](key)\n    return this[_keys].has(normKey) ? super.get(this[_keys].get(normKey))\n      : undefined\n  }\n\n  set (key, val) {\n    const normKey = this[_normKey](key)\n    if (this[_keys].has(normKey)) {\n      super.delete(this[_keys].get(normKey))\n    }\n    this[_keys].set(normKey, key)\n    return super.set(key, val)\n  }\n\n  delete (key) {\n    const normKey = this[_normKey](key)\n    if (this[_keys].has(normKey)) {\n      const prevKey = this[_keys].get(normKey)\n      this[_keys].delete(normKey)\n      return super.delete(prevKey)\n    }\n  }\n\n  has (key) {\n    const normKey = this[_normKey](key)\n    return this[_keys].has(normKey) && super.has(this[_keys].get(normKey))\n  }\n}\n","const { depth } = require('treeverse')\n\nconst calcDepFlags = (tree, resetRoot = true) => {\n  if (resetRoot) {\n    tree.dev = false\n    tree.optional = false\n    tree.devOptional = false\n    tree.peer = false\n  }\n  const ret = depth({\n    tree,\n    visit: node => calcDepFlagsStep(node),\n    filter: node => node,\n    getChildren: (node, tree) =>\n      [...tree.edgesOut.values()].map(edge => edge.to),\n  })\n  return ret\n}\n\nconst calcDepFlagsStep = (node) => {\n  // This rewalk is necessary to handle cases where devDep and optional\n  // or normal dependency graphs overlap deep in the dep graph.\n  // Since we're only walking through deps that are not already flagged\n  // as non-dev/non-optional, it's typically a very shallow traversal\n  node.extraneous = false\n  resetParents(node, 'extraneous')\n  resetParents(node, 'dev')\n  resetParents(node, 'peer')\n  resetParents(node, 'devOptional')\n  resetParents(node, 'optional')\n\n  // for links, map their hierarchy appropriately\n  if (node.isLink) {\n    node.target.dev = node.dev\n    node.target.optional = node.optional\n    node.target.devOptional = node.devOptional\n    node.target.peer = node.peer\n    return calcDepFlagsStep(node.target)\n  }\n\n  node.edgesOut.forEach(({ peer, optional, dev, to }) => {\n    // if the dep is missing, then its flags are already maximally unset\n    if (!to) {\n      return\n    }\n\n    // everything with any kind of edge into it is not extraneous\n    to.extraneous = false\n\n    // devOptional is the *overlap* of the dev and optional tree.\n    // however, for convenience and to save an extra rewalk, we leave\n    // it set when we are in *either* tree, and then omit it from the\n    // package-lock if either dev or optional are set.\n    const unsetDevOpt = !node.devOptional && !node.dev && !node.optional &&\n      !dev && !optional\n\n    // if we are not in the devOpt tree, then we're also not in\n    // either the dev or opt trees\n    const unsetDev = unsetDevOpt || !node.dev && !dev\n    const unsetOpt = unsetDevOpt ||\n      !node.optional && !optional\n    const unsetPeer = !node.peer && !peer\n\n    if (unsetPeer) {\n      unsetFlag(to, 'peer')\n    }\n\n    if (unsetDevOpt) {\n      unsetFlag(to, 'devOptional')\n    }\n\n    if (unsetDev) {\n      unsetFlag(to, 'dev')\n    }\n\n    if (unsetOpt) {\n      unsetFlag(to, 'optional')\n    }\n  })\n\n  return node\n}\n\nconst resetParents = (node, flag) => {\n  if (node[flag]) {\n    return\n  }\n\n  for (let p = node; p && (p === node || p[flag]); p = p.resolveParent) {\n    p[flag] = false\n  }\n}\n\n// typically a short walk, since it only traverses deps that\n// have the flag set.\nconst unsetFlag = (node, flag) => {\n  if (node[flag]) {\n    node[flag] = false\n    depth({\n      tree: node,\n      visit: node => {\n        node.extraneous = node[flag] = false\n        if (node.isLink) {\n          node.target.extraneous = node.target[flag] = false\n        }\n      },\n      getChildren: node => [...node.target.edgesOut.values()]\n        .filter(edge => edge.to && edge.to[flag] &&\n          (flag !== 'peer' && edge.type === 'peer' || edge.type === 'prod'))\n        .map(edge => edge.to),\n    })\n  }\n}\n\nmodule.exports = calcDepFlags\n","// a module that manages a shrinkwrap file (npm-shrinkwrap.json or\n// package-lock.json).\n\n// Increment whenever the lockfile version updates\n// v1 - npm <=6\n// v2 - arborist v1, npm v7, backwards compatible with v1, add 'packages'\n// v3 will drop the 'dependencies' field, backwards comp with v2, not v1\n//\n// We cannot bump to v3 until npm v6 is out of common usage, and\n// definitely not before npm v8.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst defaultLockfileVersion = 2\n\n// for comparing nodes to yarn.lock entries\nconst mismatch = (a, b) => a && b && a !== b\n\n// this.tree => the root node for the tree (ie, same path as this)\n// - Set the first time we do `this.add(node)` for a path matching this.path\n//\n// this.add(node) =>\n// - decorate the node with the metadata we have, if we have it, and it matches\n// - add to the map of nodes needing to be committed, so that subsequent\n// changes are captured when we commit that location's metadata.\n//\n// this.commit() =>\n// - commit all nodes awaiting update to their metadata entries\n// - re-generate this.data and this.yarnLock based on this.tree\n//\n// Note that between this.add() and this.commit(), `this.data` will be out of\n// date!  Always call `commit()` before relying on it.\n//\n// After calling this.commit(), any nodes not present in the tree will have\n// been removed from the shrinkwrap data as well.\n\nconst log = require('proc-log')\nconst YarnLock = require('./yarn-lock.js')\nconst { promisify } = require('util')\nconst rimraf = promisify(require('rimraf'))\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst writeFile = promisify(fs.writeFile)\nconst stat = promisify(fs.stat)\nconst readdir_ = promisify(fs.readdir)\nconst readlink = promisify(fs.readlink)\n\n// XXX remove when drop support for node v10\nconst lstat = promisify(fs.lstat)\n/* istanbul ignore next - version specific polyfill */\nconst readdir = async (path, opt) => {\n  if (!opt || !opt.withFileTypes) {\n    return readdir_(path, opt)\n  }\n  const ents = await readdir_(path, opt)\n  if (typeof ents[0] === 'string') {\n    return Promise.all(ents.map(async ent => {\n      return Object.assign(await lstat(path + '/' + ent), { name: ent })\n    }))\n  }\n  return ents\n}\n\nconst { resolve, basename } = require('path')\nconst specFromLock = require('./spec-from-lock.js')\nconst versionFromTgz = require('./version-from-tgz.js')\nconst npa = require('npm-package-arg')\nconst rpj = require('read-package-json-fast')\nconst parseJSON = require('parse-conflict-json')\n\nconst stringify = require('json-stringify-nice')\nconst swKeyOrder = [\n  'name',\n  'version',\n  'lockfileVersion',\n  'resolved',\n  'integrity',\n  'requires',\n  'packages',\n  'dependencies',\n]\n\n// used to rewrite from yarn registry to npm registry\nconst yarnRegRe = /^https?:\\/\\/registry\\.yarnpkg\\.com\\//\nconst npmRegRe = /^https?:\\/\\/registry\\.npmjs\\.org\\//\n\n// sometimes resolved: is weird or broken, or something npa can't handle\nconst specFromResolved = resolved => {\n  try {\n    return npa(resolved)\n  } catch (er) {\n    return {}\n  }\n}\n\nconst relpath = require('./relpath.js')\n\nconst consistentResolve = require('./consistent-resolve.js')\n\nconst maybeReadFile = file => {\n  return readFile(file, 'utf8').then(d => d, er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return ''\n    } else {\n      throw er\n    }\n  })\n}\n\nconst maybeStatFile = file => {\n  return stat(file).then(st => st.isFile(), er => {\n    /* istanbul ignore else - can't test without breaking module itself */\n    if (er.code === 'ENOENT') {\n      return null\n    } else {\n      throw er\n    }\n  })\n}\n\nconst pkgMetaKeys = [\n  // note: name is included if necessary, for alias packages\n  'version',\n  'dependencies',\n  'peerDependencies',\n  'peerDependenciesMeta',\n  'optionalDependencies',\n  'bundleDependencies',\n  'acceptDependencies',\n  'funding',\n  'engines',\n  'os',\n  'cpu',\n  '_integrity',\n  'license',\n  '_hasShrinkwrap',\n  'hasInstallScript',\n  'bin',\n  'deprecated',\n  'workspaces',\n]\n\nconst nodeMetaKeys = [\n  'integrity',\n  'inBundle',\n  'hasShrinkwrap',\n  'hasInstallScript',\n]\n\nconst metaFieldFromPkg = (pkg, key) => {\n  const val = pkg[key]\n  // get the license type, not an object\n  return (key === 'license' && val && typeof val === 'object' && val.type)\n    ? val.type\n    // skip empty objects and falsey values\n    : (val && !(typeof val === 'object' && !Object.keys(val).length)) ? val\n    : null\n}\n\n// check to make sure that there are no packages newer than the hidden lockfile\nconst assertNoNewer = async (path, data, lockTime, dir = path, seen = null) => {\n  const base = basename(dir)\n  const isNM = dir !== path && base === 'node_modules'\n  const isScope = dir !== path && !isNM && base.charAt(0) === '@'\n  const isParent = dir === path || isNM || isScope\n\n  const rel = relpath(path, dir)\n  if (dir !== path) {\n    const dirTime = (await stat(dir)).mtime\n    if (dirTime > lockTime) {\n      throw 'out of date, updated: ' + rel\n    }\n    if (!isScope && !isNM && !data.packages[rel]) {\n      throw 'missing from lockfile: ' + rel\n    }\n    seen.add(rel)\n  } else {\n    seen = new Set([rel])\n  }\n\n  const parent = isParent ? dir : resolve(dir, 'node_modules')\n  const children = dir === path\n    ? Promise.resolve([{ name: 'node_modules', isDirectory: () => true }])\n    : readdir(parent, { withFileTypes: true })\n\n  return children.catch(() => [])\n    .then(ents => Promise.all(ents.map(async ent => {\n      const child = resolve(parent, ent.name)\n      if (ent.isDirectory() && !/^\\./.test(ent.name)) {\n        await assertNoNewer(path, data, lockTime, child, seen)\n      } else if (ent.isSymbolicLink()) {\n        const target = resolve(parent, await readlink(child))\n        const tstat = await stat(target).catch(\n          /* istanbul ignore next - windows */ () => null)\n        seen.add(relpath(path, child))\n        /* istanbul ignore next - windows cannot do this */\n        if (tstat && tstat.isDirectory() && !seen.has(relpath(path, target))) {\n          await assertNoNewer(path, data, lockTime, target, seen)\n        }\n      }\n    })))\n    .then(() => {\n      if (dir !== path) {\n        return\n      }\n\n      // assert that all the entries in the lockfile were seen\n      for (const loc of new Set(Object.keys(data.packages))) {\n        if (!seen.has(loc)) {\n          throw 'missing from node_modules: ' + loc\n        }\n      }\n    })\n}\n\nconst _awaitingUpdate = Symbol('_awaitingUpdate')\nconst _updateWaitingNode = Symbol('_updateWaitingNode')\nconst _lockFromLoc = Symbol('_lockFromLoc')\nconst _pathToLoc = Symbol('_pathToLoc')\nconst _loadAll = Symbol('_loadAll')\nconst _metaFromLock = Symbol('_metaFromLock')\nconst _resolveMetaNode = Symbol('_resolveMetaNode')\nconst _fixDependencies = Symbol('_fixDependencies')\nconst _buildLegacyLockfile = Symbol('_buildLegacyLockfile')\nconst _filenameSet = Symbol('_filenameSet')\nconst _maybeRead = Symbol('_maybeRead')\nconst _maybeStat = Symbol('_maybeStat')\nclass Shrinkwrap {\n  static get defaultLockfileVersion () {\n    return defaultLockfileVersion\n  }\n\n  static load (options) {\n    return new Shrinkwrap(options).load()\n  }\n\n  static get keyOrder () {\n    return swKeyOrder\n  }\n\n  static async reset (options) {\n    // still need to know if it was loaded from the disk, but don't\n    // bother reading it if we're gonna just throw it away.\n    const s = new Shrinkwrap(options)\n    s.reset()\n\n    const [sw, lock] = await s[_maybeStat]()\n\n    s.filename = resolve(s.path,\n      (s.hiddenLockfile ? 'node_modules/.package-lock'\n      : s.shrinkwrapOnly || sw ? 'npm-shrinkwrap'\n      : 'package-lock') + '.json')\n    s.loadedFromDisk = !!(sw || lock)\n    s.type = basename(s.filename)\n\n    try {\n      if (s.loadedFromDisk && !s.lockfileVersion) {\n        const json = parseJSON(await maybeReadFile(s.filename))\n        if (json.lockfileVersion > defaultLockfileVersion) {\n          s.lockfileVersion = json.lockfileVersion\n        }\n      }\n    } catch (e) {}\n\n    return s\n  }\n\n  static metaFromNode (node, path) {\n    if (node.isLink) {\n      return {\n        resolved: relpath(path, node.realpath),\n        link: true,\n      }\n    }\n\n    const meta = {}\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(node.package, key)\n      if (val) {\n        meta[key.replace(/^_/, '')] = val\n      }\n    })\n    // we only include name if different from the node path name, and for the\n    // root to help prevent churn based on the name of the directory the\n    // project is in\n    const pname = node.packageName\n    if (pname && (node === node.root || pname !== node.name)) {\n      meta.name = pname\n    }\n\n    if (node.isTop && node.package.devDependencies) {\n      meta.devDependencies = node.package.devDependencies\n    }\n\n    nodeMetaKeys.forEach(key => {\n      if (node[key]) {\n        meta[key] = node[key]\n      }\n    })\n\n    const resolved = consistentResolve(node.resolved, node.path, path, true)\n    if (resolved) {\n      meta.resolved = resolved\n    }\n\n    if (node.extraneous) {\n      meta.extraneous = true\n    } else {\n      if (node.peer) {\n        meta.peer = true\n      }\n      if (node.dev) {\n        meta.dev = true\n      }\n      if (node.optional) {\n        meta.optional = true\n      }\n      if (node.devOptional && !node.dev && !node.optional) {\n        meta.devOptional = true\n      }\n    }\n    return meta\n  }\n\n  constructor (options = {}) {\n    const {\n      path,\n      indent = 2,\n      newline = '\\n',\n      shrinkwrapOnly = false,\n      hiddenLockfile = false,\n      lockfileVersion,\n    } = options\n\n    this.lockfileVersion = hiddenLockfile ? 3\n      : lockfileVersion ? parseInt(lockfileVersion, 10)\n      : null\n    this[_awaitingUpdate] = new Map()\n    this.tree = null\n    this.path = resolve(path || '.')\n    this.filename = null\n    this.data = null\n    this.indent = indent\n    this.newline = newline\n    this.loadedFromDisk = false\n    this.type = null\n    this.yarnLock = null\n    this.hiddenLockfile = hiddenLockfile\n    this.loadingError = null\n    // only load npm-shrinkwrap.json in dep trees, not package-lock\n    this.shrinkwrapOnly = shrinkwrapOnly\n  }\n\n  // check to see if a spec is present in the yarn.lock file, and if so,\n  // if we should use it, and what it should resolve to.  This is only\n  // done when we did not load a shrinkwrap from disk.  Also, decorate\n  // the options object if provided with the resolved and integrity that\n  // we expect.\n  checkYarnLock (spec, options = {}) {\n    spec = npa(spec)\n    const { yarnLock, loadedFromDisk } = this\n    const useYarnLock = yarnLock && !loadedFromDisk\n    const fromYarn = useYarnLock && yarnLock.entries.get(spec.raw)\n    if (fromYarn && fromYarn.version) {\n      // if it's the yarn or npm default registry, use the version as\n      // our effective spec.  if it's any other kind of thing, use that.\n      const { resolved, version, integrity } = fromYarn\n      const isYarnReg = spec.registry && yarnRegRe.test(resolved)\n      const isnpmReg = spec.registry && !isYarnReg && npmRegRe.test(resolved)\n      const isReg = isnpmReg || isYarnReg\n      // don't use the simple version if the \"registry\" url is\n      // something else entirely!\n      const tgz = isReg && versionFromTgz(spec.name, resolved) || {}\n      const yspec = tgz.name === spec.name && tgz.version === version ? version\n        : isReg && tgz.name && tgz.version ? `npm:${tgz.name}@${tgz.version}`\n        : resolved\n      if (yspec) {\n        options.resolved = resolved.replace(yarnRegRe, 'https://registry.npmjs.org/')\n        options.integrity = integrity\n        return npa(`${spec.name}@${yspec}`)\n      }\n    }\n    return spec\n  }\n\n  // throw away the shrinkwrap data so we can start fresh\n  // still worth doing a load() first so we know which files to write.\n  reset () {\n    this.tree = null\n    this[_awaitingUpdate] = new Map()\n    const lockfileVersion = this.lockfileVersion || defaultLockfileVersion\n    this.originalLockfileVersion = lockfileVersion\n    this.data = {\n      lockfileVersion,\n      requires: true,\n      packages: {},\n      dependencies: {},\n    }\n  }\n\n  [_filenameSet] () {\n    return this.shrinkwrapOnly ? [\n      this.path + '/npm-shrinkwrap.json',\n    ] : this.hiddenLockfile ? [\n      null,\n      this.path + '/node_modules/.package-lock.json',\n    ] : [\n      this.path + '/npm-shrinkwrap.json',\n      this.path + '/package-lock.json',\n      this.path + '/yarn.lock',\n    ]\n  }\n\n  [_maybeRead] () {\n    return Promise.all(this[_filenameSet]().map(fn => fn && maybeReadFile(fn)))\n  }\n\n  [_maybeStat] () {\n    // throw away yarn, we only care about lock or shrinkwrap when checking\n    // this way, since we're not actually loading the full lock metadata\n    return Promise.all(this[_filenameSet]().slice(0, 2)\n      .map(fn => fn && maybeStatFile(fn)))\n  }\n\n  inferFormattingOptions (packageJSONData) {\n    // don't use detect-indent, just pick the first line.\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // which will default to 2 at save time.\n    const {\n      [Symbol.for('indent')]: indent,\n      [Symbol.for('newline')]: newline,\n    } = packageJSONData\n    this.indent = indent !== undefined ? indent : this.indent\n    this.newline = newline !== undefined ? newline : this.newline\n  }\n\n  load () {\n    // we don't need to load package-lock.json except for top of tree nodes,\n    // only npm-shrinkwrap.json.\n    return this[_maybeRead]().then(([sw, lock, yarn]) => {\n      const data = sw || lock || ''\n\n      // use shrinkwrap only for deps, otherwise prefer package-lock\n      // and ignore npm-shrinkwrap if both are present.\n      // TODO: emit a warning here or something if both are present.\n      this.filename = resolve(this.path,\n        (this.hiddenLockfile ? 'node_modules/.package-lock'\n        : this.shrinkwrapOnly || sw ? 'npm-shrinkwrap'\n        : 'package-lock') + '.json')\n\n      this.type = basename(this.filename)\n      this.loadedFromDisk = !!data\n\n      if (yarn) {\n        this.yarnLock = new YarnLock()\n        // ignore invalid yarn data.  we'll likely clobber it later anyway.\n        try {\n          this.yarnLock.parse(yarn)\n        } catch (_) {}\n      }\n\n      return data ? parseJSON(data) : {}\n    }).then(async data => {\n      this.inferFormattingOptions(data)\n\n      if (!this.hiddenLockfile || !data.packages) {\n        return data\n      }\n\n      // add a few ms just to account for jitter\n      const lockTime = +(await stat(this.filename)).mtime + 10\n      await assertNoNewer(this.path, data, lockTime)\n\n      // all good!  hidden lockfile is the newest thing in here.\n      return data\n    }).catch(er => {\n      /* istanbul ignore else */\n      if (typeof this.filename === 'string') {\n        const rel = relpath(this.path, this.filename)\n        log.verbose('shrinkwrap', `failed to load ${rel}`, er)\n      } else {\n        log.verbose('shrinkwrap', `failed to load ${this.path}`, er)\n      }\n      this.loadingError = er\n      this.loadedFromDisk = false\n      this.ancientLockfile = false\n      return {}\n    }).then(lock => {\n      const lockfileVersion = this.lockfileVersion ? this.lockfileVersion\n        : Math.max(lock.lockfileVersion || 0, defaultLockfileVersion)\n      this.data = {\n        ...lock,\n        lockfileVersion: lockfileVersion,\n        requires: true,\n        packages: lock.packages || {},\n        dependencies: lock.dependencies || {},\n      }\n\n      this.originalLockfileVersion = lock.lockfileVersion\n      // use default if it wasn't explicitly set, and the current file is\n      // less than our default.  otherwise, keep whatever is in the file,\n      // unless we had an explicit setting already.\n      if (!this.lockfileVersion) {\n        this.lockfileVersion = this.data.lockfileVersion = lockfileVersion\n      }\n      this.ancientLockfile = this.loadedFromDisk &&\n        !(lock.lockfileVersion >= 2) && !lock.requires\n\n      // load old lockfile deps into the packages listing\n      if (lock.dependencies && !lock.packages) {\n        return rpj(this.path + '/package.json').then(pkg => pkg, er => ({}))\n          .then(pkg => {\n            this[_loadAll]('', null, this.data)\n            this[_fixDependencies](pkg)\n          })\n      }\n    })\n      .then(() => this)\n  }\n\n  [_loadAll] (location, name, lock) {\n    // migrate a v1 package lock to the new format.\n    const meta = this[_metaFromLock](location, name, lock)\n    // dependencies nested under a link are actually under the link target\n    if (meta.link) {\n      location = meta.resolved\n    }\n    if (lock.dependencies) {\n      for (const [name, dep] of Object.entries(lock.dependencies)) {\n        const loc = location + (location ? '/' : '') + 'node_modules/' + name\n        this[_loadAll](loc, name, dep)\n      }\n    }\n  }\n\n  // v1 lockfiles track the optional/dev flags, but they don't tell us\n  // which thing had what kind of dep on what other thing, so we need\n  // to correct that now, or every link will be considered prod\n  [_fixDependencies] (pkg) {\n    // we need the root package.json because legacy shrinkwraps just\n    // have requires:true at the root level, which is even less useful\n    // than merging all dep types into one object.\n    const root = this.data.packages['']\n    pkgMetaKeys.forEach(key => {\n      const val = metaFieldFromPkg(pkg, key)\n      const k = key.replace(/^_/, '')\n      if (val) {\n        root[k] = val\n      }\n    })\n\n    for (const [loc, meta] of Object.entries(this.data.packages)) {\n      if (!meta.requires || !loc) {\n        continue\n      }\n\n      // resolve each require to a meta entry\n      // if this node isn't optional, but the dep is, then it's an optionalDep\n      // likewise for dev deps.\n      // This isn't perfect, but it's a pretty good approximation, and at\n      // least gets us out of having all 'prod' edges, which throws off the\n      // buildIdealTree process\n      for (const [name, spec] of Object.entries(meta.requires)) {\n        const dep = this[_resolveMetaNode](loc, name)\n        // this overwrites the false value set above\n        const depType = dep && dep.optional && !meta.optional\n          ? 'optionalDependencies'\n          : /* istanbul ignore next - dev deps are only for the root level */\n          dep && dep.dev && !meta.dev ? 'devDependencies'\n          // also land here if the dep just isn't in the tree, which maybe\n          // should be an error, since it means that the shrinkwrap is\n          // invalid, but we can't do much better without any info.\n          : 'dependencies'\n        meta[depType] = meta[depType] || {}\n        meta[depType][name] = spec\n      }\n      delete meta.requires\n    }\n  }\n\n  [_resolveMetaNode] (loc, name) {\n    for (let path = loc; true; path = path.replace(/(^|\\/)[^/]*$/, '')) {\n      const check = `${path}${path ? '/' : ''}node_modules/${name}`\n      if (this.data.packages[check]) {\n        return this.data.packages[check]\n      }\n\n      if (!path) {\n        break\n      }\n    }\n    return null\n  }\n\n  [_lockFromLoc] (lock, path, i = 0) {\n    if (!lock) {\n      return null\n    }\n\n    if (path[i] === '') {\n      i++\n    }\n\n    if (i >= path.length) {\n      return lock\n    }\n\n    if (!lock.dependencies) {\n      return null\n    }\n\n    return this[_lockFromLoc](lock.dependencies[path[i]], path, i + 1)\n  }\n\n  // pass in a path relative to the root path, or an absolute path,\n  // get back a /-normalized location based on root path.\n  [_pathToLoc] (path) {\n    return relpath(this.path, resolve(this.path, path))\n  }\n\n  delete (nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n    const location = this[_pathToLoc](nodePath)\n    this[_awaitingUpdate].delete(location)\n\n    delete this.data.packages[location]\n    const path = location.split(/(?:^|\\/)node_modules\\//)\n    const name = path.pop()\n    const pLock = this[_lockFromLoc](this.data, path)\n    if (pLock && pLock.dependencies) {\n      delete pLock.dependencies[name]\n    }\n  }\n\n  get (nodePath) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n\n    const location = this[_pathToLoc](nodePath)\n    if (this[_awaitingUpdate].has(location)) {\n      this[_updateWaitingNode](location)\n    }\n\n    // first try to get from the newer spot, which we know has\n    // all the things we need.\n    if (this.data.packages[location]) {\n      return this.data.packages[location]\n    }\n\n    // otherwise, fall back to the legacy metadata, and hope for the best\n    // get the node in the shrinkwrap corresponding to this spot\n    const path = location.split(/(?:^|\\/)node_modules\\//)\n    const name = path[path.length - 1]\n    const lock = this[_lockFromLoc](this.data, path)\n\n    return this[_metaFromLock](location, name, lock)\n  }\n\n  [_metaFromLock] (location, name, lock) {\n    // This function tries as hard as it can to figure out the metadata\n    // from a lockfile which may be outdated or incomplete.  Since v1\n    // lockfiles used the \"version\" field to contain a variety of\n    // different possible types of data, this gets a little complicated.\n    if (!lock) {\n      return {}\n    }\n\n    // try to figure out a npm-package-arg spec from the lockfile entry\n    // This will return null if we could not get anything valid out of it.\n    const spec = specFromLock(name, lock, this.path)\n\n    if (spec.type === 'directory') {\n      // the \"version\" was a file: url to a non-tarball path\n      // this is a symlink dep.  We don't store much metadata\n      // about symlinks, just the target.\n      const target = relpath(this.path, spec.fetchSpec)\n      this.data.packages[location] = {\n        link: true,\n        resolved: target,\n      }\n      // also save the link target, omitting version since we don't know\n      // what it is, but we know it isn't a link to itself!\n      if (!this.data.packages[target]) {\n        this[_metaFromLock](target, name, { ...lock, version: null })\n      }\n      return this.data.packages[location]\n    }\n\n    const meta = {}\n    // when calling loadAll we'll change these into proper dep objects\n    if (lock.requires && typeof lock.requires === 'object') {\n      meta.requires = lock.requires\n    }\n\n    if (lock.optional) {\n      meta.optional = true\n    }\n    if (lock.dev) {\n      meta.dev = true\n    }\n\n    // the root will typically have a name from the root project's\n    // package.json file.\n    if (location === '') {\n      meta.name = lock.name\n    }\n\n    // if we have integrity, save it now.\n    if (lock.integrity) {\n      meta.integrity = lock.integrity\n    }\n\n    if (lock.version && !lock.integrity) {\n      // this is usually going to be a git url or symlink, but it could\n      // also be a registry dependency that did not have integrity at\n      // the time it was saved.\n      // Symlinks were already handled above, so that leaves git.\n      //\n      // For git, always save the full SSH url.  we'll actually fetch the\n      // tgz most of the time, since it's faster, but it won't work for\n      // private repos, and we can't get back to the ssh from the tgz,\n      // so we store the ssh instead.\n      // For unknown git hosts, just resolve to the raw spec in lock.version\n      if (spec.type === 'git') {\n        meta.resolved = consistentResolve(spec, this.path, this.path)\n\n        // return early because there is nothing else we can do with this\n        return this.data.packages[location] = meta\n      } else if (spec.registry) {\n        // registry dep that didn't save integrity.  grab the version, and\n        // fall through to pick up the resolved and potentially name.\n        meta.version = lock.version\n      }\n      // only other possible case is a tarball without integrity.\n      // fall through to do what we can with the filename later.\n    }\n\n    // at this point, we know that the spec is either a registry dep\n    // (ie, version, because locking, which means a resolved url),\n    // or a remote dep, or file: url.  Remote deps and file urls\n    // have a fetchSpec equal to the fully resolved thing.\n    // Registry deps, we take what's in the lockfile.\n    if (lock.resolved || (spec.type && !spec.registry)) {\n      if (spec.registry) {\n        meta.resolved = lock.resolved\n      } else if (spec.type === 'file') {\n        meta.resolved = consistentResolve(spec, this.path, this.path, true)\n      } else if (spec.fetchSpec) {\n        meta.resolved = spec.fetchSpec\n      }\n    }\n\n    // at this point, if still we don't have a version, do our best to\n    // infer it from the tarball url/file.  This works a surprising\n    // amount of the time, even though it's not guaranteed.\n    if (!meta.version) {\n      if (spec.type === 'file' || spec.type === 'remote') {\n        const fromTgz = versionFromTgz(spec.name, spec.fetchSpec) ||\n          versionFromTgz(spec.name, meta.resolved)\n        if (fromTgz) {\n          meta.version = fromTgz.version\n          if (fromTgz.name !== name) {\n            meta.name = fromTgz.name\n          }\n        }\n      } else if (spec.type === 'alias') {\n        meta.name = spec.subSpec.name\n        meta.version = spec.subSpec.fetchSpec\n      } else if (spec.type === 'version') {\n        meta.version = spec.fetchSpec\n      }\n      // ok, I did my best!  good luck!\n    }\n\n    if (lock.bundled) {\n      meta.inBundle = true\n    }\n\n    // save it for next time\n    return this.data.packages[location] = meta\n  }\n\n  add (node) {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n\n    // will be actually updated on read\n    const loc = relpath(this.path, node.path)\n    if (node.path === this.path) {\n      this.tree = node\n    }\n\n    // if we have metadata about this node, and it's a match, then\n    // try to decorate it.\n    if (node.resolved === null || node.integrity === null) {\n      const {\n        resolved,\n        integrity,\n        hasShrinkwrap,\n        version,\n      } = this.get(node.path)\n\n      const pathFixed = !resolved ? null\n        : !/^file:/.test(resolved) ? resolved\n        // resolve onto the metadata path\n        : `file:${resolve(this.path, resolved.substr(5))}`\n\n      // if we have one, only set the other if it matches\n      // otherwise it could be for a completely different thing.\n      const resolvedOk = !resolved || !node.resolved ||\n        node.resolved === pathFixed\n      const integrityOk = !integrity || !node.integrity ||\n        node.integrity === integrity\n      const versionOk = !version || !node.version || version === node.version\n\n      const allOk = (resolved || integrity || version) &&\n        resolvedOk && integrityOk && versionOk\n\n      if (allOk) {\n        node.resolved = node.resolved || pathFixed || null\n        node.integrity = node.integrity || integrity || null\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false\n      } else {\n        // try to read off the package or node itself\n        const {\n          resolved,\n          integrity,\n          hasShrinkwrap,\n        } = Shrinkwrap.metaFromNode(node, this.path)\n        node.resolved = node.resolved || resolved || null\n        node.integrity = node.integrity || integrity || null\n        node.hasShrinkwrap = node.hasShrinkwrap || hasShrinkwrap || false\n      }\n    }\n    this[_awaitingUpdate].set(loc, node)\n  }\n\n  addEdge (edge) {\n    if (!this.yarnLock || !edge.valid) {\n      return\n    }\n\n    const { to: node } = edge\n\n    // if it's already set up, nothing to do\n    if (node.resolved !== null && node.integrity !== null) {\n      return\n    }\n\n    // if the yarn lock is empty, nothing to do\n    if (!this.yarnLock.entries || !this.yarnLock.entries.size) {\n      return\n    }\n\n    // we relativize the path here because that's how it shows up in the lock\n    // XXX how is this different from pathFixed above??\n    const pathFixed = !node.resolved ? null\n      : !/file:/.test(node.resolved) ? node.resolved\n      : consistentResolve(node.resolved, node.path, this.path, true)\n\n    const spec = npa(`${node.name}@${edge.spec}`)\n    const entry = this.yarnLock.entries.get(`${node.name}@${edge.spec}`)\n\n    if (!entry ||\n        mismatch(node.version, entry.version) ||\n        mismatch(node.integrity, entry.integrity) ||\n        mismatch(pathFixed, entry.resolved)) {\n      return\n    }\n\n    if (entry.resolved && yarnRegRe.test(entry.resolved) && spec.registry) {\n      entry.resolved = entry.resolved.replace(yarnRegRe, 'https://registry.npmjs.org/')\n    }\n\n    node.integrity = node.integrity || entry.integrity || null\n    node.resolved = node.resolved ||\n      consistentResolve(entry.resolved, this.path, node.path) || null\n\n    this[_awaitingUpdate].set(relpath(this.path, node.path), node)\n  }\n\n  [_updateWaitingNode] (loc) {\n    const node = this[_awaitingUpdate].get(loc)\n    this[_awaitingUpdate].delete(loc)\n    this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path)\n  }\n\n  commit () {\n    if (this.tree) {\n      if (this.yarnLock) {\n        this.yarnLock.fromTree(this.tree)\n      }\n      const root = Shrinkwrap.metaFromNode(this.tree.target, this.path)\n      this.data.packages = {}\n      if (Object.keys(root).length) {\n        this.data.packages[''] = root\n      }\n      for (const node of this.tree.root.inventory.values()) {\n        // only way this.tree is not root is if the root is a link to it\n        if (node === this.tree || node.isRoot || node.location === '') {\n          continue\n        }\n        const loc = relpath(this.path, node.path)\n        this.data.packages[loc] = Shrinkwrap.metaFromNode(node, this.path)\n      }\n    } else if (this[_awaitingUpdate].size > 0) {\n      for (const loc of this[_awaitingUpdate].keys()) {\n        this[_updateWaitingNode](loc)\n      }\n    }\n\n    // if we haven't set it by now, use the default\n    if (!this.lockfileVersion) {\n      this.lockfileVersion = defaultLockfileVersion\n    }\n    this.data.lockfileVersion = this.lockfileVersion\n\n    // hidden lockfiles don't include legacy metadata or a root entry\n    if (this.hiddenLockfile) {\n      delete this.data.packages['']\n      delete this.data.dependencies\n    } else if (this.tree && this.lockfileVersion <= 3) {\n      this[_buildLegacyLockfile](this.tree, this.data)\n    }\n\n    // lf version 1 = dependencies only\n    // lf version 2 = dependencies and packages\n    // lf version 3 = packages only\n    if (this.lockfileVersion >= 3) {\n      const { dependencies, ...data } = this.data\n      return data\n    } else if (this.lockfileVersion < 2) {\n      const { packages, ...data } = this.data\n      return data\n    } else {\n      return { ...this.data }\n    }\n  }\n\n  [_buildLegacyLockfile] (node, lock, path = []) {\n    if (node === this.tree) {\n      // the root node\n      lock.name = node.packageName || node.name\n      if (node.version) {\n        lock.version = node.version\n      }\n    }\n\n    // npm v6 and before tracked 'from', meaning \"the request that led\n    // to this package being installed\".  However, that's inherently\n    // racey and non-deterministic in a world where deps are deduped\n    // ahead of fetch time.  In order to maintain backwards compatibility\n    // with v6 in the lockfile, we do this trick where we pick a valid\n    // dep link out of the edgesIn set.  Choose the edge with the fewest\n    // number of `node_modules` sections in the requestor path, and then\n    // lexically sort afterwards.\n    const edge = [...node.edgesIn].filter(e => e.valid).sort((a, b) => {\n      const aloc = a.from.location.split('node_modules')\n      const bloc = b.from.location.split('node_modules')\n      /* istanbul ignore next - sort calling order is indeterminate */\n      return aloc.length > bloc.length ? 1\n        : bloc.length > aloc.length ? -1\n        : localeCompare(aloc[aloc.length - 1], bloc[bloc.length - 1])\n    })[0]\n\n    const res = consistentResolve(node.resolved, this.path, this.path, true)\n    const rSpec = specFromResolved(res)\n\n    // if we don't have anything (ie, it's extraneous) then use the resolved\n    // value as if that was where we got it from, since at least it's true.\n    // if we don't have either, just an empty object so nothing matches below.\n    // This will effectively just save the version and resolved, as if it's\n    // a standard version/range dep, which is a reasonable default.\n    const spec = !edge ? rSpec\n      : npa.resolve(node.name, edge.spec, edge.from.realpath)\n\n    if (node.isLink) {\n      lock.version = `file:${relpath(this.path, node.realpath)}`\n    } else if (spec && (spec.type === 'file' || spec.type === 'remote')) {\n      lock.version = spec.saveSpec\n    } else if (spec && spec.type === 'git' || rSpec.type === 'git') {\n      lock.version = node.resolved\n      /* istanbul ignore else - don't think there are any cases where a git\n       * spec (or indeed, ANY npa spec) doesn't have a .raw member */\n      if (spec.raw) {\n        lock.from = spec.raw\n      }\n    } else if (!node.isRoot &&\n        node.package &&\n        node.packageName &&\n        node.packageName !== node.name) {\n      lock.version = `npm:${node.packageName}@${node.version}`\n    } else if (node.package && node.version) {\n      lock.version = node.version\n    }\n\n    if (node.inDepBundle) {\n      lock.bundled = true\n    }\n\n    // when we didn't resolve to git, file, or dir, and didn't request\n    // git, file, dir, or remote, then the resolved value is necessary.\n    if (node.resolved &&\n        !node.isLink &&\n        rSpec.type !== 'git' &&\n        rSpec.type !== 'file' &&\n        rSpec.type !== 'directory' &&\n        spec.type !== 'directory' &&\n        spec.type !== 'git' &&\n        spec.type !== 'file' &&\n        spec.type !== 'remote') {\n      lock.resolved = node.resolved\n    }\n\n    if (node.integrity) {\n      lock.integrity = node.integrity\n    }\n\n    if (node.extraneous) {\n      lock.extraneous = true\n    } else if (!node.isLink) {\n      if (node.peer) {\n        lock.peer = true\n      }\n\n      if (node.devOptional && !node.dev && !node.optional) {\n        lock.devOptional = true\n      }\n\n      if (node.dev) {\n        lock.dev = true\n      }\n\n      if (node.optional) {\n        lock.optional = true\n      }\n    }\n\n    const depender = node.target\n    if (depender.edgesOut.size > 0) {\n      if (node !== this.tree) {\n        const entries = [...depender.edgesOut.entries()]\n        lock.requires = entries.reduce((set, [k, v]) => {\n          // omit peer deps from legacy lockfile requires field, because\n          // npm v6 doesn't handle peer deps, and this triggers some bad\n          // behavior if the dep can't be found in the dependencies list.\n          const { spec, peer } = v\n          if (peer) {\n            return set\n          }\n          if (spec.startsWith('file:')) {\n            // turn absolute file: paths into relative paths from the node\n            // this especially shows up with workspace edges when the root\n            // node is also a workspace in the set.\n            const p = resolve(node.realpath, spec.substr('file:'.length))\n            set[k] = `file:${relpath(node.realpath, p)}`\n          } else {\n            set[k] = spec\n          }\n          return set\n        }, {})\n      } else {\n        lock.requires = true\n      }\n    }\n\n    // now we walk the children, putting them in the 'dependencies' object\n    const { children } = node.target\n    if (!children.size) {\n      delete lock.dependencies\n    } else {\n      const kidPath = [...path, node.realpath]\n      const dependencies = {}\n      // skip any that are already in the descent path, so cyclical link\n      // dependencies don't blow up with ELOOP.\n      let found = false\n      for (const [name, kid] of children.entries()) {\n        if (path.includes(kid.realpath)) {\n          continue\n        }\n        dependencies[name] = this[_buildLegacyLockfile](kid, {}, kidPath)\n        found = true\n      }\n      if (found) {\n        lock.dependencies = dependencies\n      }\n    }\n    return lock\n  }\n\n  toJSON () {\n    if (!this.data) {\n      throw new Error('run load() before getting or setting data')\n    }\n\n    return this.commit()\n  }\n\n  toString (options = {}) {\n    const data = this.toJSON()\n    const { format = true } = options\n    const defaultIndent = this.indent || 2\n    const indent = format === true ? defaultIndent\n      : format || 0\n    const eol = format ? this.newline || '\\n' : ''\n    return stringify(data, swKeyOrder, indent).replace(/\\n/g, eol)\n  }\n\n  save (options = {}) {\n    if (!this.data) {\n      throw new Error('run load() before saving data')\n    }\n    const json = this.toString(options)\n    return Promise.all([\n      writeFile(this.filename, json).catch(er => {\n        if (this.hiddenLockfile) {\n          // well, we did our best.\n          // if we reify, and there's nothing there, then it might be lacking\n          // a node_modules folder, but then the lockfile is not important.\n          // Remove the file, so that in case there WERE deps, but we just\n          // failed to update the file for some reason, it's not out of sync.\n          return rimraf(this.filename)\n        }\n        throw er\n      }),\n      this.yarnLock && this.yarnLock.entries.size &&\n        writeFile(this.path + '/yarn.lock', this.yarnLock.toString()),\n    ])\n  }\n}\n\nmodule.exports = Shrinkwrap\n","// parse a yarn lock file\n// basic format\n//\n// <request spec>[, <request spec> ...]:\n//   <key> <value>\n//   <subkey>:\n//     <key> <value>\n//\n// Assume that any key or value might be quoted, though that's only done\n// in practice if certain chars are in the string.  Quoting unnecessarily\n// does not cause problems for yarn, so that's what we do when we write\n// it back.\n//\n// The data format would support nested objects, but at this time, it\n// appears that yarn does not use that for anything, so in the interest\n// of a simpler parser algorithm, this implementation only supports a\n// single layer of sub objects.\n//\n// This doesn't deterministically define the shape of the tree, and so\n// cannot be used (on its own) for Arborist.loadVirtual.\n// But it can give us resolved, integrity, and version, which is useful\n// for Arborist.loadActual and for building the ideal tree.\n//\n// At the very least, when a yarn.lock file is present, we update it\n// along the way, and save it back in Shrinkwrap.save()\n//\n// NIHing this rather than using @yarnpkg/lockfile because that module\n// is an impenetrable 10kloc of webpack flow output, which is overkill\n// for something relatively simple and tailored to Arborist's use case.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst consistentResolve = require('./consistent-resolve.js')\nconst { dirname } = require('path')\nconst { breadth } = require('treeverse')\n\n// sort a key/value object into a string of JSON stringified keys and vals\nconst sortKV = obj => Object.keys(obj)\n  .sort(localeCompare)\n  .map(k => `    ${JSON.stringify(k)} ${JSON.stringify(obj[k])}`)\n  .join('\\n')\n\n// for checking against previous entries\nconst match = (p, n) =>\n  p.integrity && n.integrity ? p.integrity === n.integrity\n  : p.resolved && n.resolved ? p.resolved === n.resolved\n  : p.version && n.version ? p.version === n.version\n  : true\n\nconst prefix =\n`# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n# yarn lockfile v1\n\n\n`\n\nconst nullSymbol = Symbol('null')\nclass YarnLock {\n  static parse (data) {\n    return new YarnLock().parse(data)\n  }\n\n  static fromTree (tree) {\n    return new YarnLock().fromTree(tree)\n  }\n\n  constructor () {\n    this.entries = null\n    this.endCurrent()\n  }\n\n  endCurrent () {\n    this.current = null\n    this.subkey = nullSymbol\n  }\n\n  parse (data) {\n    const ENTRY_START = /^[^\\s].*:$/\n    const SUBKEY = /^ {2}[^\\s]+:$/\n    const SUBVAL = /^ {4}[^\\s]+ .+$/\n    const METADATA = /^ {2}[^\\s]+ .+$/\n    this.entries = new Map()\n    this.current = null\n    const linere = /([^\\r\\n]*)\\r?\\n/gm\n    let match\n    let lineNum = 0\n    if (!/\\n$/.test(data)) {\n      data += '\\n'\n    }\n    while (match = linere.exec(data)) {\n      const line = match[1]\n      lineNum++\n      if (line.charAt(0) === '#') {\n        continue\n      }\n      if (line === '') {\n        this.endCurrent()\n        continue\n      }\n      if (ENTRY_START.test(line)) {\n        this.endCurrent()\n        const specs = this.splitQuoted(line.slice(0, -1), /, */)\n        this.current = new YarnLockEntry(specs)\n        specs.forEach(spec => this.entries.set(spec, this.current))\n        continue\n      }\n      if (SUBKEY.test(line)) {\n        this.subkey = line.slice(2, -1)\n        this.current[this.subkey] = {}\n        continue\n      }\n      if (SUBVAL.test(line) && this.current && this.current[this.subkey]) {\n        const subval = this.splitQuoted(line.trimLeft(), ' ')\n        if (subval.length === 2) {\n          this.current[this.subkey][subval[0]] = subval[1]\n          continue\n        }\n      }\n      // any other metadata\n      if (METADATA.test(line) && this.current) {\n        const metadata = this.splitQuoted(line.trimLeft(), ' ')\n        if (metadata.length === 2) {\n          // strip off the legacy shasum hashes\n          if (metadata[0] === 'resolved') {\n            metadata[1] = metadata[1].replace(/#.*/, '')\n          }\n          this.current[metadata[0]] = metadata[1]\n          continue\n        }\n      }\n\n      throw Object.assign(new Error('invalid or corrupted yarn.lock file'), {\n        position: match.index,\n        content: match[0],\n        line: lineNum,\n      })\n    }\n    this.endCurrent()\n    return this\n  }\n\n  splitQuoted (str, delim) {\n    // a,\"b,c\",d\"e,f => ['a','\"b','c\"','d\"e','f'] => ['a','b,c','d\"e','f']\n    const split = str.split(delim)\n    const out = []\n    let o = 0\n    for (let i = 0; i < split.length; i++) {\n      const chunk = split[i]\n      if (/^\".*\"$/.test(chunk)) {\n        out[o++] = chunk.trim().slice(1, -1)\n      } else if (/^\"/.test(chunk)) {\n        let collect = chunk.trimLeft().slice(1)\n        while (++i < split.length) {\n          const n = split[i]\n          // something that is not a slash, followed by an even number\n          // of slashes then a \" then end => ending on an unescaped \"\n          if (/[^\\\\](\\\\\\\\)*\"$/.test(n)) {\n            collect += n.trimRight().slice(0, -1)\n            break\n          } else {\n            collect += n\n          }\n        }\n        out[o++] = collect\n      } else {\n        out[o++] = chunk.trim()\n      }\n    }\n    return out\n  }\n\n  toString () {\n    return prefix + [...new Set([...this.entries.values()])]\n      .map(e => e.toString())\n      .sort(localeCompare).join('\\n\\n') + '\\n'\n  }\n\n  fromTree (tree) {\n    this.entries = new Map()\n    // walk the tree in a deterministic order, breadth-first, alphabetical\n    breadth({\n      tree,\n      visit: node => this.addEntryFromNode(node),\n      getChildren: node => [...node.children.values(), ...node.fsChildren]\n        .sort((a, b) => a.depth - b.depth || localeCompare(a.name, b.name)),\n    })\n    return this\n  }\n\n  addEntryFromNode (node) {\n    const specs = [...node.edgesIn]\n      .map(e => `${node.name}@${e.spec}`)\n      .sort(localeCompare)\n\n    // Note:\n    // yarn will do excessive duplication in a case like this:\n    // root -> (x@1.x, y@1.x, z@1.x)\n    // y@1.x -> (x@1.1, z@2.x)\n    // z@1.x -> ()\n    // z@2.x -> (x@1.x)\n    //\n    // where x@1.2 exists, because the \"x@1.x\" spec will *always* resolve\n    // to x@1.2, which doesn't work for y's dep on x@1.1, so you'll get this:\n    //\n    // root\n    // +-- x@1.2.0\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2\n    // |       +-- x@1.2.0\n    // +-- z@1\n    //\n    // instead of this more deduped tree that arborist builds by default:\n    //\n    // root\n    // +-- x@1.2.0 (dep is x@1.x, from root)\n    // +-- y\n    // |   +-- x@1.1.0\n    // |   +-- z@2 (dep on x@1.x deduped to x@1.1.0 under y)\n    // +-- z@1\n    //\n    // In order to not create an invalid yarn.lock file with conflicting\n    // entries, AND not tell yarn to create an invalid tree, we need to\n    // ignore the x@1.x spec coming from z, since it's already in the entries.\n    //\n    // So, if the integrity and resolved don't match a previous entry, skip it.\n    // We call this method on shallower nodes first, so this is fine.\n    const n = this.entryDataFromNode(node)\n    let priorEntry = null\n    const newSpecs = []\n    for (const s of specs) {\n      const prev = this.entries.get(s)\n      // no previous entry for this spec at all, so it's new\n      if (!prev) {\n        // if we saw a match already, then assign this spec to it as well\n        if (priorEntry) {\n          priorEntry.addSpec(s)\n        } else {\n          newSpecs.push(s)\n        }\n        continue\n      }\n\n      const m = match(prev, n)\n      // there was a prior entry, but a different thing.  skip this one\n      if (!m) {\n        continue\n      }\n\n      // previous matches, but first time seeing it, so already has this spec.\n      // go ahead and add all the previously unseen specs, though\n      if (!priorEntry) {\n        priorEntry = prev\n        for (const s of newSpecs) {\n          priorEntry.addSpec(s)\n          this.entries.set(s, priorEntry)\n        }\n        newSpecs.length = 0\n        continue\n      }\n\n      // have a prior entry matching n, and matching the prev we just saw\n      // add the spec to it\n      priorEntry.addSpec(s)\n      this.entries.set(s, priorEntry)\n    }\n\n    // if we never found a matching prior, then this is a whole new thing\n    if (!priorEntry) {\n      const entry = Object.assign(new YarnLockEntry(newSpecs), n)\n      for (const s of newSpecs) {\n        this.entries.set(s, entry)\n      }\n    } else {\n      // pick up any new info that we got for this node, so that we can\n      // decorate with integrity/resolved/etc.\n      Object.assign(priorEntry, n)\n    }\n  }\n\n  entryDataFromNode (node) {\n    const n = {}\n    if (node.package.dependencies) {\n      n.dependencies = node.package.dependencies\n    }\n    if (node.package.optionalDependencies) {\n      n.optionalDependencies = node.package.optionalDependencies\n    }\n    if (node.version) {\n      n.version = node.version\n    }\n    if (node.resolved) {\n      n.resolved = consistentResolve(\n        node.resolved,\n        node.isLink ? dirname(node.path) : node.path,\n        node.root.path,\n        true\n      )\n    }\n    if (node.integrity) {\n      n.integrity = node.integrity\n    }\n\n    return n\n  }\n\n  static get Entry () {\n    return YarnLockEntry\n  }\n}\n\nconst _specs = Symbol('_specs')\nclass YarnLockEntry {\n  constructor (specs) {\n    this[_specs] = new Set(specs)\n    this.resolved = null\n    this.version = null\n    this.integrity = null\n    this.dependencies = null\n    this.optionalDependencies = null\n  }\n\n  toString () {\n    // sort objects to the bottom, then alphabetical\n    return ([...this[_specs]]\n      .sort(localeCompare)\n      .map(JSON.stringify).join(', ') +\n      ':\\n' +\n      Object.getOwnPropertyNames(this)\n        .filter(prop => this[prop] !== null)\n        .sort(\n          (a, b) =>\n          /* istanbul ignore next - sort call order is unpredictable */\n            (typeof this[a] === 'object') === (typeof this[b] === 'object')\n              ? localeCompare(a, b)\n              : typeof this[a] === 'object' ? 1 : -1)\n        .map(prop =>\n          typeof this[prop] !== 'object'\n            ? `  ${JSON.stringify(prop)} ${JSON.stringify(this[prop])}\\n`\n            : Object.keys(this[prop]).length === 0 ? ''\n            : `  ${prop}:\\n` + sortKV(this[prop]) + '\\n')\n        .join('')).trim()\n  }\n\n  addSpec (spec) {\n    this[_specs].add(spec)\n  }\n}\n\nmodule.exports = YarnLock\n","const npa = require('npm-package-arg')\n\n// extracted from npm v6 lib/install/realize-shrinkwrap-specifier.js\nconst specFromLock = (name, lock, where) => {\n  try {\n    if (lock.version) {\n      const spec = npa.resolve(name, lock.version, where)\n      if (lock.integrity || spec.type === 'git') {\n        return spec\n      }\n    }\n    if (lock.from) {\n      // legacy metadata includes \"from\", but not integrity\n      const spec = npa.resolve(name, lock.from, where)\n      if (spec.registry && lock.version) {\n        return npa.resolve(name, lock.version, where)\n      } else if (!lock.resolved) {\n        return spec\n      }\n    }\n    if (lock.resolved) {\n      return npa.resolve(name, lock.resolved, where)\n    }\n  } catch (_) { }\n  try {\n    return npa.resolve(name, lock.version, where)\n  } catch (_) {\n    return {}\n  }\n}\n\nmodule.exports = specFromLock\n","/* eslint node/no-deprecated-api: \"off\" */\nconst semver = require('semver')\nconst { basename } = require('path')\nconst { parse } = require('url')\nmodule.exports = (name, tgz) => {\n  const base = basename(tgz)\n  if (!base.endsWith('.tgz')) {\n    return null\n  }\n\n  const u = parse(tgz)\n  if (/^https?:/.test(u.protocol)) {\n    // registry url?  check for most likely pattern.\n    // either /@foo/bar/-/bar-1.2.3.tgz or\n    // /foo/-/foo-1.2.3.tgz, and fall through to\n    // basename checking.  Note that registries can\n    // be mounted below the root url, so /a/b/-/x/y/foo/-/foo-1.2.3.tgz\n    // is a potential option.\n    const tfsplit = u.path.substr(1).split('/-/')\n    if (tfsplit.length > 1) {\n      const afterTF = tfsplit.pop()\n      if (afterTF === base) {\n        const pre = tfsplit.pop()\n        const preSplit = pre.split(/\\/|%2f/i)\n        const project = preSplit.pop()\n        const scope = preSplit.pop()\n        return versionFromBaseScopeName(base, scope, project)\n      }\n    }\n  }\n\n  const split = name.split(/\\/|%2f/i)\n  const project = split.pop()\n  const scope = split.pop()\n  return versionFromBaseScopeName(base, scope, project)\n}\n\nconst versionFromBaseScopeName = (base, scope, name) => {\n  if (!base.startsWith(name + '-')) {\n    return null\n  }\n\n  const parsed = semver.parse(base.substring(name.length + 1, base.length - 4))\n  return parsed ? {\n    name: scope && scope.charAt(0) === '@' ? `${scope}/${name}` : name,\n    version: parsed.version,\n  } : null\n}\n","// when an optional dep fails to install, we need to remove the branch of the\n// graph up to the first optionalDependencies, as well as any nodes that are\n// only required by other nodes in the set.\n//\n// This function finds the set of nodes that will need to be removed in that\n// case.\n//\n// Note that this is *only* going to work with trees where calcDepFlags\n// has been called, because we rely on the node.optional flag.\n\nconst gatherDepSet = require('./gather-dep-set.js')\nconst optionalSet = node => {\n  if (!node.optional) {\n    return new Set()\n  }\n\n  // start with the node, then walk up the dependency graph until we\n  // get to the boundaries that define the optional set.  since the\n  // node is optional, we know that all paths INTO this area of the\n  // graph are optional, but there may be non-optional dependencies\n  // WITHIN the area.\n  const set = new Set([node])\n  for (const node of set) {\n    for (const edge of node.edgesIn) {\n      if (!edge.optional) {\n        set.add(edge.from)\n      }\n    }\n  }\n\n  // now that we've hit the boundary, gather the rest of the nodes in\n  // the optional section.  that's the set of dependencies that are only\n  // depended upon by other nodes within the set, or optional dependencies\n  // from outside the set.\n  return gatherDepSet(set, edge => !edge.optional)\n}\n\nmodule.exports = optionalSet\n","// Sometimes we need to actually do a walk from the root, because you can\n// have a cycle of deps that all depend on each other, but no path from root.\n// Also, since the ideal tree is loaded from the shrinkwrap, it had extraneous\n// flags set false that might now be actually extraneous, and dev/optional\n// flags that are also now incorrect.  This method sets all flags to true, so\n// we can find the set that is actually extraneous.\nmodule.exports = tree => {\n  for (const node of tree.inventory.values()) {\n    node.extraneous = true\n    node.dev = true\n    node.devOptional = true\n    node.peer = true\n    node.optional = true\n  }\n}\n","const mapWorkspaces = require('@npmcli/map-workspaces')\n\nconst _appendWorkspaces = Symbol('appendWorkspaces')\n// shared ref used by other mixins/Arborist\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual')\n\nmodule.exports = cls => class MapWorkspaces extends cls {\n  [_appendWorkspaces] (node, workspaces) {\n    if (node && workspaces.size) {\n      node.workspaces = workspaces\n    }\n\n    return node\n  }\n\n  async [_loadWorkspaces] (node) {\n    if (node.workspaces) {\n      return node\n    }\n\n    const workspaces = await mapWorkspaces({\n      cwd: node.path,\n      pkg: node.package,\n    })\n\n    return this[_appendWorkspaces](node, workspaces)\n  }\n\n  [_loadWorkspacesVirtual] (opts) {\n    return mapWorkspaces.virtual(opts)\n  }\n}\n","// mix-in implementing the loadActual method\n\nconst { relative, dirname, resolve, join, normalize } = require('path')\n\nconst rpj = require('read-package-json-fast')\nconst { promisify } = require('util')\nconst readdir = promisify(require('readdir-scoped-modules'))\nconst walkUp = require('walk-up-path')\nconst ancestorPath = require('common-ancestor-path')\nconst treeCheck = require('../tree-check.js')\n\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst realpath = require('../realpath.js')\n\nconst _loadFSNode = Symbol('loadFSNode')\nconst _newNode = Symbol('newNode')\nconst _newLink = Symbol('newLink')\nconst _loadFSTree = Symbol('loadFSTree')\nconst _loadFSChildren = Symbol('loadFSChildren')\nconst _findMissingEdges = Symbol('findMissingEdges')\nconst _findFSParents = Symbol('findFSParents')\nconst _resetDepFlags = Symbol('resetDepFlags')\n\nconst _actualTreeLoaded = Symbol('actualTreeLoaded')\nconst _rpcache = Symbol.for('realpathCache')\nconst _stcache = Symbol.for('statCache')\nconst _topNodes = Symbol('linkTargets')\nconst _cache = Symbol('nodeLoadingCache')\nconst _loadActual = Symbol('loadActual')\nconst _loadActualVirtually = Symbol('loadActualVirtually')\nconst _loadActualActually = Symbol('loadActualActually')\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _loadWorkspaceTargets = Symbol('loadWorkspaceTargets')\nconst _actualTreePromise = Symbol('actualTreePromise')\nconst _actualTree = Symbol('actualTree')\nconst _transplant = Symbol('transplant')\nconst _transplantFilter = Symbol('transplantFilter')\n\nconst _filter = Symbol('filter')\nconst _global = Symbol.for('global')\nconst _changePath = Symbol.for('_changePath')\n\nmodule.exports = cls => class ActualLoader extends cls {\n  constructor (options) {\n    super(options)\n\n    this[_global] = !!options.global\n\n    // the tree of nodes on disk\n    this.actualTree = options.actualTree\n\n    // ensure when walking the tree that we don't call loadTree on the\n    // same actual node more than one time.\n    this[_actualTreeLoaded] = new Set()\n\n    // caches for cached realpath calls\n    const cwd = process.cwd()\n    // assume that the cwd is real enough for our purposes\n    this[_rpcache] = new Map([[cwd, cwd]])\n    this[_stcache] = new Map()\n\n    // cache of nodes when loading the actualTree, so that we avoid\n    // loaded the same node multiple times when symlinks attack.\n    this[_cache] = new Map()\n\n    // cache of link targets for setting fsParent links\n    // We don't do fsParent as a magic getter/setter, because\n    // it'd be too costly to keep up to date along the walk.\n    // And, we know that it can ONLY be relevant when the node\n    // is a target of a link, otherwise it'd be in a node_modules\n    // folder, so take advantage of that to limit the scans later.\n    this[_topNodes] = new Set()\n  }\n\n  [_resetDepFlags] (tree, root) {\n    // reset all deps to extraneous prior to recalc\n    if (!root) {\n      for (const node of tree.inventory.values()) {\n        node.extraneous = true\n      }\n    }\n\n    // only reset root flags if we're not re-rooting,\n    // otherwise leave as-is\n    calcDepFlags(tree, !root)\n    return tree\n  }\n\n  // public method\n  async loadActual (options = {}) {\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = { ...this.options, ...options }\n\n    // stash the promise so that we don't ever have more than one\n    // going at the same time.  This is so that buildIdealTree can\n    // default to the actualTree if no shrinkwrap present, but\n    // reify() can still call buildIdealTree and loadActual in parallel\n    // safely.\n    return this.actualTree ? this.actualTree\n      : this[_actualTreePromise] ? this[_actualTreePromise]\n      : this[_actualTreePromise] = this[_loadActual](options)\n        .then(tree => this[_resetDepFlags](tree, options.root))\n        .then(tree => this.actualTree = treeCheck(tree))\n  }\n\n  async [_loadActual] (options) {\n    // mostly realpath to throw if the root doesn't exist\n    const {\n      global = false,\n      filter = () => true,\n      root = null,\n      transplantFilter = () => true,\n      ignoreMissing = false,\n    } = options\n    this[_filter] = filter\n    this[_transplantFilter] = transplantFilter\n\n    if (global) {\n      const real = await realpath(this.path, this[_rpcache], this[_stcache])\n      const newNodeOrLink = this.path === real ? _newNode : _newLink\n      this[_actualTree] = await this[newNodeOrLink]({\n        path: this.path,\n        realpath: real,\n        pkg: {},\n        global,\n        loadOverrides: true,\n      })\n      return this[_loadActualActually]({ root, ignoreMissing, global })\n    }\n\n    // not in global mode, hidden lockfile is allowed, load root pkg too\n    this[_actualTree] = await this[_loadFSNode]({\n      path: this.path,\n      real: await realpath(this.path, this[_rpcache], this[_stcache]),\n      loadOverrides: true,\n    })\n\n    this[_actualTree].assertRootOverrides()\n\n    // Note: hidden lockfile will be rejected if it's not the latest thing\n    // in the folder, or if any of the entries in the hidden lockfile are\n    // missing.\n    const meta = await Shrinkwrap.load({\n      path: this[_actualTree].path,\n      hiddenLockfile: true,\n    })\n    if (meta.loadedFromDisk) {\n      this[_actualTree].meta = meta\n      return this[_loadActualVirtually]({ root })\n    } else {\n      const meta = await Shrinkwrap.load({\n        path: this[_actualTree].path,\n        lockfileVersion: this.options.lockfileVersion,\n      })\n      this[_actualTree].meta = meta\n      return this[_loadActualActually]({ root, ignoreMissing })\n    }\n  }\n\n  async [_loadActualVirtually] ({ root }) {\n    // have to load on a new Arborist object, so we don't assign\n    // the virtualTree on this one!  Also, the weird reference is because\n    // we can't easily get a ref to Arborist in this module, without\n    // creating a circular reference, since this class is a mixin used\n    // to build up the Arborist class itself.\n    await new this.constructor({ ...this.options }).loadVirtual({\n      root: this[_actualTree],\n    })\n    await this[_loadWorkspaces](this[_actualTree])\n\n    this[_transplant](root)\n    return this[_actualTree]\n  }\n\n  async [_loadActualActually] ({ root, ignoreMissing, global }) {\n    await this[_loadFSTree](this[_actualTree])\n    await this[_loadWorkspaces](this[_actualTree])\n    await this[_loadWorkspaceTargets](this[_actualTree])\n    if (!ignoreMissing) {\n      await this[_findMissingEdges]()\n    }\n    this[_findFSParents]()\n    this[_transplant](root)\n\n    if (global) {\n      // need to depend on the children, or else all of them\n      // will end up being flagged as extraneous, since the\n      // global root isn't a \"real\" project\n      const tree = this[_actualTree]\n      const actualRoot = tree.isLink ? tree.target : tree\n      const { dependencies = {} } = actualRoot.package\n      for (const [name, kid] of actualRoot.children.entries()) {\n        const def = kid.isLink ? `file:${kid.realpath}` : '*'\n        dependencies[name] = dependencies[name] || def\n      }\n      actualRoot.package = { ...actualRoot.package, dependencies }\n    }\n    return this[_actualTree]\n  }\n\n  // if there are workspace targets without Link nodes created, load\n  // the targets, so that we know what they are.\n  async [_loadWorkspaceTargets] (tree) {\n    if (!tree.workspaces || !tree.workspaces.size) {\n      return\n    }\n\n    const promises = []\n    for (const path of tree.workspaces.values()) {\n      if (!this[_cache].has(path)) {\n        // workspace overrides use the root overrides\n        const p = this[_loadFSNode]({ path, root: this[_actualTree], useRootOverrides: true })\n          .then(node => this[_loadFSTree](node))\n        promises.push(p)\n      }\n    }\n    await Promise.all(promises)\n  }\n\n  [_transplant] (root) {\n    if (!root || root === this[_actualTree]) {\n      return\n    }\n\n    this[_actualTree][_changePath](root.path)\n    for (const node of this[_actualTree].children.values()) {\n      if (!this[_transplantFilter](node)) {\n        node.root = null\n      }\n    }\n\n    root.replace(this[_actualTree])\n    for (const node of this[_actualTree].fsChildren) {\n      node.root = this[_transplantFilter](node) ? root : null\n    }\n\n    this[_actualTree] = root\n  }\n\n  [_loadFSNode] ({ path, parent, real, root, loadOverrides, useRootOverrides }) {\n    if (!real) {\n      return realpath(path, this[_rpcache], this[_stcache])\n        .then(\n          real => this[_loadFSNode]({\n            path,\n            parent,\n            real,\n            root,\n            loadOverrides,\n            useRootOverrides,\n          }),\n          // if realpath fails, just provide a dummy error node\n          error => new Node({\n            error,\n            path,\n            realpath: path,\n            parent,\n            root,\n            loadOverrides,\n          })\n        )\n    }\n\n    // cache temporarily holds a promise placeholder so we don't try to create\n    // the same node multiple times.  this is rare to encounter, given the\n    // aggressive caching on realpath and lstat calls, but it's possible that\n    // it's already loaded as a tree top, and then gets its parent loaded\n    // later, if a symlink points deeper in the tree.\n    const cached = this[_cache].get(path)\n    if (cached && !cached.dummy) {\n      return Promise.resolve(cached).then(node => {\n        node.parent = parent\n        return node\n      })\n    }\n\n    const p = rpj(join(real, 'package.json'))\n      // soldier on if read-package-json raises an error\n      .then(pkg => [pkg, null], error => [null, error])\n      .then(([pkg, error]) => {\n        return this[normalize(path) === real ? _newNode : _newLink]({\n          legacyPeerDeps: this.legacyPeerDeps,\n          path,\n          realpath: real,\n          pkg,\n          error,\n          parent,\n          root,\n          loadOverrides,\n          ...(useRootOverrides && root.overrides\n            ? { overrides: root.overrides.getNodeRule({ name: pkg.name, version: pkg.version }) }\n            : {}),\n        })\n      })\n      .then(node => {\n        this[_cache].set(path, node)\n        return node\n      })\n\n    this[_cache].set(path, p)\n    return p\n  }\n\n  // this is the way it is to expose a timing issue which is difficult to\n  // test otherwise.  The creation of a Node may take slightly longer than\n  // the creation of a Link that targets it.  If the Node has _begun_ its\n  // creation phase (and put a Promise in the cache) then the Link will\n  // get a Promise as its cachedTarget instead of an actual Node object.\n  // This is not a problem, because it gets resolved prior to returning\n  // the tree or attempting to load children.  However, it IS remarkably\n  // difficult to get to happen in a test environment to verify reliably.\n  // Hence this kludge.\n  [_newNode] (options) {\n    // check it for an fsParent if it's a tree top.  there's a decent chance\n    // it'll get parented later, making the fsParent scan a no-op, but better\n    // safe than sorry, since it's cheap.\n    const { parent, realpath } = options\n    if (!parent) {\n      this[_topNodes].add(realpath)\n    }\n    return process.env._TEST_ARBORIST_SLOW_LINK_TARGET_ === '1'\n      ? new Promise(res => setTimeout(() => res(new Node(options)), 100))\n      : new Node(options)\n  }\n\n  [_newLink] (options) {\n    const { realpath } = options\n    this[_topNodes].add(realpath)\n    const target = this[_cache].get(realpath)\n    const link = new Link({ ...options, target })\n\n    if (!target) {\n      this[_cache].set(realpath, link.target)\n      // if a link target points at a node outside of the root tree's\n      // node_modules hierarchy, then load that node as well.\n      return this[_loadFSTree](link.target).then(() => link)\n    } else if (target.then) {\n      target.then(node => link.target = node)\n    }\n\n    return link\n  }\n\n  [_loadFSTree] (node) {\n    const did = this[_actualTreeLoaded]\n    node = node.target\n\n    // if a Link target has started, but not completed, then\n    // a Promise will be in the cache to indicate this.\n    if (node.then) {\n      return node.then(node => this[_loadFSTree](node))\n    }\n\n    // impossible except in pathological ELOOP cases\n    /* istanbul ignore if */\n    if (did.has(node.realpath)) {\n      return Promise.resolve(node)\n    }\n\n    did.add(node.realpath)\n    return this[_loadFSChildren](node)\n      .then(() => Promise.all(\n        [...node.children.entries()]\n          .filter(([name, kid]) => !did.has(kid.realpath))\n          .map(([name, kid]) => this[_loadFSTree](kid))))\n  }\n\n  // create child nodes for all the entries in node_modules\n  // and attach them to the node as a parent\n  [_loadFSChildren] (node) {\n    const nm = resolve(node.realpath, 'node_modules')\n    return readdir(nm).then(kids => {\n      return Promise.all(\n      // ignore . dirs and retired scoped package folders\n        kids.filter(kid => !/^(@[^/]+\\/)?\\./.test(kid))\n          .filter(kid => this[_filter](node, kid))\n          .map(kid => this[_loadFSNode]({\n            parent: node,\n            path: resolve(nm, kid),\n          })))\n    },\n    // error in the readdir is not fatal, just means no kids\n    () => {})\n  }\n\n  async [_findMissingEdges] () {\n    // try to resolve any missing edges by walking up the directory tree,\n    // checking for the package in each node_modules folder.  stop at the\n    // root directory.\n    // The tricky move here is that we load a \"dummy\" node for the folder\n    // containing the node_modules folder, so that it can be assigned as\n    // the fsParent.  It's a bad idea to *actually* load that full node,\n    // because people sometimes develop in ~/projects/node_modules/...\n    // so we'd end up loading a massive tree with lots of unrelated junk.\n    const nmContents = new Map()\n    const tree = this[_actualTree]\n    for (const node of tree.inventory.values()) {\n      const ancestor = ancestorPath(node.realpath, this.path)\n\n      const depPromises = []\n      for (const [name, edge] of node.edgesOut.entries()) {\n        const notMissing = !edge.missing &&\n          !(edge.to && (edge.to.dummy || edge.to.parent !== node))\n        if (notMissing) {\n          continue\n        }\n\n        // start the walk from the dirname, because we would have found\n        // the dep in the loadFSTree step already if it was local.\n        for (const p of walkUp(dirname(node.realpath))) {\n          // only walk as far as the nearest ancestor\n          // this keeps us from going into completely unrelated\n          // places when a project is just missing something, but\n          // allows for finding the transitive deps of link targets.\n          // ie, if it has to go up and back out to get to the path\n          // from the nearest common ancestor, we've gone too far.\n          if (ancestor && /^\\.\\.(?:[\\\\/]|$)/.test(relative(ancestor, p))) {\n            break\n          }\n\n          const entries = nmContents.get(p) ||\n            await readdir(p + '/node_modules').catch(() => [])\n          nmContents.set(p, entries)\n          if (!entries.includes(name)) {\n            continue\n          }\n\n          const d = this[_cache].has(p) ? await this[_cache].get(p)\n            : new Node({ path: p, root: node.root, dummy: true })\n          this[_cache].set(p, d)\n          if (d.dummy) {\n            // it's a placeholder, so likely would not have loaded this dep,\n            // unless another dep in the tree also needs it.\n            const depPath = normalize(`${p}/node_modules/${name}`)\n            const cached = this[_cache].get(depPath)\n            if (!cached || cached.dummy) {\n              depPromises.push(this[_loadFSNode]({\n                path: depPath,\n                root: node.root,\n                parent: d,\n              }).then(node => this[_loadFSTree](node)))\n            }\n          }\n          break\n        }\n      }\n      await Promise.all(depPromises)\n    }\n  }\n\n  // try to find a node that is the parent in a fs tree sense, but not a\n  // node_modules tree sense, of any link targets.  this allows us to\n  // resolve deps that node will find, but a legacy npm view of the\n  // world would not have noticed.\n  [_findFSParents] () {\n    for (const path of this[_topNodes]) {\n      const node = this[_cache].get(path)\n      if (node && !node.parent && !node.fsParent) {\n        for (const p of walkUp(dirname(path))) {\n          if (this[_cache].has(p)) {\n            node.fsParent = this[_cache].get(p)\n            break\n          }\n        }\n      }\n    }\n  }\n}\n","// mixin providing the loadVirtual method\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\n\nconst { resolve } = require('path')\n\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst consistentResolve = require('../consistent-resolve.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst relpath = require('../relpath.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst rpj = require('read-package-json-fast')\nconst treeCheck = require('../tree-check.js')\n\nconst loadFromShrinkwrap = Symbol('loadFromShrinkwrap')\nconst resolveNodes = Symbol('resolveNodes')\nconst resolveLinks = Symbol('resolveLinks')\nconst assignBundles = Symbol('assignBundles')\nconst loadRoot = Symbol('loadRoot')\nconst loadNode = Symbol('loadVirtualNode')\nconst loadLink = Symbol('loadVirtualLink')\nconst loadWorkspaces = Symbol.for('loadWorkspaces')\nconst loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual')\nconst flagsSuspect = Symbol.for('flagsSuspect')\nconst reCalcDepFlags = Symbol('reCalcDepFlags')\nconst checkRootEdges = Symbol('checkRootEdges')\nconst rootOptionProvided = Symbol('rootOptionProvided')\n\nconst depsToEdges = (type, deps) =>\n  Object.entries(deps).map(d => [type, ...d])\n\nmodule.exports = cls => class VirtualLoader extends cls {\n  constructor (options) {\n    super(options)\n\n    // the virtual tree we load from a shrinkwrap\n    this.virtualTree = options.virtualTree\n    this[flagsSuspect] = false\n  }\n\n  // public method\n  async loadVirtual (options = {}) {\n    if (this.virtualTree) {\n      return this.virtualTree\n    }\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    if (options.root && options.root.meta) {\n      await this[loadFromShrinkwrap](options.root.meta, options.root)\n      return treeCheck(this.virtualTree)\n    }\n\n    const s = await Shrinkwrap.load({\n      path: this.path,\n      lockfileVersion: this.options.lockfileVersion,\n    })\n    if (!s.loadedFromDisk && !options.root) {\n      const er = new Error('loadVirtual requires existing shrinkwrap file')\n      throw Object.assign(er, { code: 'ENOLOCK' })\n    }\n\n    // when building the ideal tree, we pass in a root node to this function\n    // otherwise, load it from the root package json or the lockfile\n    const {\n      root = await this[loadRoot](s),\n    } = options\n\n    this[rootOptionProvided] = options.root\n\n    await this[loadFromShrinkwrap](s, root)\n    root.assertRootOverrides()\n    return treeCheck(this.virtualTree)\n  }\n\n  async [loadRoot] (s) {\n    const pj = this.path + '/package.json'\n    const pkg = await rpj(pj).catch(() => s.data.packages['']) || {}\n    return this[loadWorkspaces](this[loadNode]('', pkg))\n  }\n\n  async [loadFromShrinkwrap] (s, root) {\n    if (!this[rootOptionProvided]) {\n      // root is never any of these things, but might be a brand new\n      // baby Node object that never had its dep flags calculated.\n      root.extraneous = false\n      root.dev = false\n      root.optional = false\n      root.devOptional = false\n      root.peer = false\n    } else {\n      this[flagsSuspect] = true\n    }\n\n    this[checkRootEdges](s, root)\n    root.meta = s\n    this.virtualTree = root\n    const { links, nodes } = this[resolveNodes](s, root)\n    await this[resolveLinks](links, nodes)\n    if (!(s.originalLockfileVersion >= 2)) {\n      this[assignBundles](nodes)\n    }\n    if (this[flagsSuspect]) {\n      this[reCalcDepFlags](nodes.values())\n    }\n    return root\n  }\n\n  [reCalcDepFlags] (nodes) {\n    // reset all dep flags\n    // can't use inventory here, because virtualTree might not be root\n    for (const node of nodes) {\n      if (node.isRoot || node === this[rootOptionProvided]) {\n        continue\n      }\n      node.extraneous = true\n      node.dev = true\n      node.optional = true\n      node.devOptional = true\n      node.peer = true\n    }\n    calcDepFlags(this.virtualTree, !this[rootOptionProvided])\n  }\n\n  // check the lockfile deps, and see if they match.  if they do not\n  // then we have to reset dep flags at the end.  for example, if the\n  // user manually edits their package.json file, then we need to know\n  // that the idealTree is no longer entirely trustworthy.\n  [checkRootEdges] (s, root) {\n    // loaded virtually from tree, no chance of being out of sync\n    // ancient lockfiles are critically damaged by this process,\n    // so we need to just hope for the best in those cases.\n    if (!s.loadedFromDisk || s.ancientLockfile) {\n      return\n    }\n\n    const lock = s.get('')\n    const prod = lock.dependencies || {}\n    const dev = lock.devDependencies || {}\n    const optional = lock.optionalDependencies || {}\n    const peer = lock.peerDependencies || {}\n    const peerOptional = {}\n    if (lock.peerDependenciesMeta) {\n      for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {\n        if (meta.optional && peer[name] !== undefined) {\n          peerOptional[name] = peer[name]\n          delete peer[name]\n        }\n      }\n    }\n    for (const name of Object.keys(optional)) {\n      delete prod[name]\n    }\n\n    const lockWS = []\n    const workspaces = this[loadWorkspacesVirtual]({\n      cwd: this.path,\n      lockfile: s.data,\n    })\n    for (const [name, path] of workspaces.entries()) {\n      lockWS.push(['workspace', name, `file:${path}`])\n    }\n\n    const lockEdges = [\n      ...depsToEdges('prod', prod),\n      ...depsToEdges('dev', dev),\n      ...depsToEdges('optional', optional),\n      ...depsToEdges('peer', peer),\n      ...depsToEdges('peerOptional', peerOptional),\n      ...lockWS,\n    ].sort(([atype, aname], [btype, bname]) =>\n      localeCompare(atype, btype) || localeCompare(aname, bname))\n\n    const rootEdges = [...root.edgesOut.values()]\n      .map(e => [e.type, e.name, e.spec])\n      .sort(([atype, aname], [btype, bname]) =>\n        localeCompare(atype, btype) || localeCompare(aname, bname))\n\n    if (rootEdges.length !== lockEdges.length) {\n      // something added or removed\n      return this[flagsSuspect] = true\n    }\n\n    for (let i = 0; i < lockEdges.length; i++) {\n      if (rootEdges[i][0] !== lockEdges[i][0] ||\n          rootEdges[i][1] !== lockEdges[i][1] ||\n          rootEdges[i][2] !== lockEdges[i][2]) {\n        return this[flagsSuspect] = true\n      }\n    }\n  }\n\n  // separate out link metadatas, and create Node objects for nodes\n  [resolveNodes] (s, root) {\n    const links = new Map()\n    const nodes = new Map([['', root]])\n    for (const [location, meta] of Object.entries(s.data.packages)) {\n      // skip the root because we already got it\n      if (!location) {\n        continue\n      }\n\n      if (meta.link) {\n        links.set(location, meta)\n      } else {\n        nodes.set(location, this[loadNode](location, meta))\n      }\n    }\n    return { links, nodes }\n  }\n\n  // links is the set of metadata, and nodes is the map of non-Link nodes\n  // Set the targets to nodes in the set, if we have them (we might not)\n  async [resolveLinks] (links, nodes) {\n    for (const [location, meta] of links.entries()) {\n      const targetPath = resolve(this.path, meta.resolved)\n      const targetLoc = relpath(this.path, targetPath)\n      const target = nodes.get(targetLoc)\n      const link = this[loadLink](location, targetLoc, target, meta)\n      nodes.set(location, link)\n      nodes.set(targetLoc, link.target)\n\n      // we always need to read the package.json for link targets\n      // outside node_modules because they can be changed by the local user\n      if (!link.target.parent) {\n        const pj = link.realpath + '/package.json'\n        const pkg = await rpj(pj).catch(() => null)\n        if (pkg) {\n          link.target.package = pkg\n        }\n      }\n    }\n  }\n\n  [assignBundles] (nodes) {\n    for (const [location, node] of nodes) {\n      // Skip assignment of parentage for the root package\n      if (!location || node.isLink && !node.target.location) {\n        continue\n      }\n      const { name, parent, package: { inBundle } } = node\n\n      if (!parent) {\n        continue\n      }\n\n      // read inBundle from package because 'package' here is\n      // actually a v2 lockfile metadata entry.\n      // If the *parent* is also bundled, though, or if the parent has\n      // no dependency on it, then we assume that it's being pulled in\n      // just by virtue of its parent or a transitive dep being bundled.\n      const { package: ppkg } = parent\n      const { inBundle: parentBundled } = ppkg\n      if (inBundle && !parentBundled && parent.edgesOut.has(node.name)) {\n        if (!ppkg.bundleDependencies) {\n          ppkg.bundleDependencies = [name]\n        } else {\n          ppkg.bundleDependencies.push(name)\n        }\n      }\n    }\n  }\n\n  [loadNode] (location, sw) {\n    const p = this.virtualTree ? this.virtualTree.realpath : this.path\n    const path = resolve(p, location)\n    // shrinkwrap doesn't include package name unless necessary\n    if (!sw.name) {\n      sw.name = nameFromFolder(path)\n    }\n\n    const dev = sw.dev\n    const optional = sw.optional\n    const devOptional = dev || optional || sw.devOptional\n    const peer = sw.peer\n\n    const node = new Node({\n      legacyPeerDeps: this.legacyPeerDeps,\n      root: this.virtualTree,\n      path,\n      realpath: path,\n      integrity: sw.integrity,\n      resolved: consistentResolve(sw.resolved, this.path, path),\n      pkg: sw,\n      hasShrinkwrap: sw.hasShrinkwrap,\n      dev,\n      optional,\n      devOptional,\n      peer,\n    })\n    // cast to boolean because they're undefined in the lock file when false\n    node.extraneous = !!sw.extraneous\n    node.devOptional = !!(sw.devOptional || sw.dev || sw.optional)\n    node.peer = !!sw.peer\n    node.optional = !!sw.optional\n    node.dev = !!sw.dev\n    return node\n  }\n\n  [loadLink] (location, targetLoc, target, meta) {\n    const path = resolve(this.path, location)\n    const link = new Link({\n      legacyPeerDeps: this.legacyPeerDeps,\n      path,\n      realpath: resolve(this.path, targetLoc),\n      target,\n      pkg: target && target.package,\n    })\n    link.extraneous = target.extraneous\n    link.devOptional = target.devOptional\n    link.peer = target.peer\n    link.optional = target.optional\n    link.dev = target.dev\n    return link\n  }\n}\n","// Arborist.rebuild({path = this.path}) will do all the binlinks and\n// bundle building needed.  Called by reify, and by `npm rebuild`.\n\nconst localeCompare = require('@isaacs/string-locale-compare')('en')\nconst { depth: dfwalk } = require('treeverse')\nconst promiseAllRejectLate = require('promise-all-reject-late')\nconst rpj = require('read-package-json-fast')\nconst binLinks = require('bin-links')\nconst runScript = require('@npmcli/run-script')\nconst promiseCallLimit = require('promise-call-limit')\nconst { resolve } = require('path')\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript,\n} = require('@npmcli/node-gyp')\nconst log = require('proc-log')\n\nconst boolEnv = b => b ? '1' : ''\nconst sortNodes = (a, b) =>\n  (a.depth - b.depth) || localeCompare(a.path, b.path)\n\nconst _workspaces = Symbol.for('workspaces')\nconst _build = Symbol('build')\nconst _resetQueues = Symbol('resetQueues')\nconst _rebuildBundle = Symbol('rebuildBundle')\nconst _ignoreScripts = Symbol('ignoreScripts')\nconst _binLinks = Symbol('binLinks')\nconst _oldMeta = Symbol('oldMeta')\nconst _createBinLinks = Symbol('createBinLinks')\nconst _doHandleOptionalFailure = Symbol('doHandleOptionalFailure')\nconst _linkAllBins = Symbol('linkAllBins')\nconst _runScripts = Symbol('runScripts')\nconst _buildQueues = Symbol('buildQueues')\nconst _addToBuildSet = Symbol('addToBuildSet')\nconst _checkBins = Symbol.for('checkBins')\nconst _queues = Symbol('queues')\nconst _scriptShell = Symbol('scriptShell')\nconst _includeWorkspaceRoot = Symbol.for('includeWorkspaceRoot')\nconst _workspacesEnabled = Symbol.for('workspacesEnabled')\n\nconst _force = Symbol.for('force')\n\n// defined by reify mixin\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure')\nconst _trashList = Symbol.for('trashList')\n\nmodule.exports = cls => class Builder extends cls {\n  constructor (options) {\n    super(options)\n\n    const {\n      ignoreScripts = false,\n      scriptShell,\n      binLinks = true,\n      rebuildBundle = true,\n    } = options\n\n    this.scriptsRun = new Set()\n    this[_binLinks] = binLinks\n    this[_ignoreScripts] = !!ignoreScripts\n    this[_scriptShell] = scriptShell\n    this[_rebuildBundle] = !!rebuildBundle\n    this[_resetQueues]()\n    this[_oldMeta] = null\n  }\n\n  async rebuild ({ nodes, handleOptionalFailure = false } = {}) {\n    // nothing to do if we're not building anything!\n    if (this[_ignoreScripts] && !this[_binLinks]) {\n      return\n    }\n\n    // when building for the first time, as part of reify, we ignore\n    // failures in optional nodes, and just delete them.  however, when\n    // running JUST a rebuild, we treat optional failures as real fails\n    this[_doHandleOptionalFailure] = handleOptionalFailure\n\n    // if we don't have a set of nodes, then just rebuild\n    // the actual tree on disk.\n    if (!nodes) {\n      const tree = await this.loadActual()\n      let filterSet\n      if (!this[_workspacesEnabled]) {\n        filterSet = this.excludeWorkspacesDependencySet(tree)\n        nodes = tree.inventory.filter(node =>\n          filterSet.has(node) || node.isProjectRoot\n        )\n      } else if (this[_workspaces] && this[_workspaces].length) {\n        filterSet = this.workspaceDependencySet(\n          tree,\n          this[_workspaces],\n          this[_includeWorkspaceRoot]\n        )\n        nodes = tree.inventory.filter(node => filterSet.has(node))\n      } else {\n        nodes = tree.inventory.values()\n      }\n    }\n\n    // separates links nodes so that it can run\n    // prepare scripts and link bins in the expected order\n    process.emit('time', 'build')\n    const depNodes = new Set()\n    const linkNodes = new Set()\n    for (const node of nodes) {\n      // we skip the target nodes to that workspace in order to make sure\n      // we only run lifecycle scripts / place bin links once per workspace\n      if (node.isLink) {\n        linkNodes.add(node)\n      } else {\n        depNodes.add(node)\n      }\n    }\n\n    await this[_build](depNodes, {})\n\n    if (linkNodes.size) {\n      this[_resetQueues]()\n      await this[_build](linkNodes, { type: 'links' })\n    }\n\n    process.emit('timeEnd', 'build')\n  }\n\n  [_resetQueues] () {\n    this[_queues] = {\n      preinstall: [],\n      install: [],\n      postinstall: [],\n      prepare: [],\n      bin: [],\n    }\n  }\n\n  async [_build] (nodes, { type = 'deps' }) {\n    process.emit('time', `build:${type}`)\n\n    await this[_buildQueues](nodes)\n    // links should run prepare scripts and only link bins after that\n    if (type !== 'links') {\n      if (!this[_ignoreScripts]) {\n        await this[_runScripts]('preinstall')\n      }\n      if (this[_binLinks]) {\n        await this[_linkAllBins]()\n      }\n      if (!this[_ignoreScripts]) {\n        await this[_runScripts]('install')\n        await this[_runScripts]('postinstall')\n      }\n    } else {\n      await this[_runScripts]('prepare')\n\n      if (this[_binLinks]) {\n        await this[_linkAllBins]()\n      }\n    }\n\n    process.emit('timeEnd', `build:${type}`)\n  }\n\n  async [_buildQueues] (nodes) {\n    process.emit('time', 'build:queue')\n    const set = new Set()\n\n    const promises = []\n    for (const node of nodes) {\n      promises.push(this[_addToBuildSet](node, set))\n\n      // if it has bundle deps, add those too, if rebuildBundle\n      if (this[_rebuildBundle] !== false) {\n        const bd = node.package.bundleDependencies\n        if (bd && bd.length) {\n          dfwalk({\n            tree: node,\n            leave: node => promises.push(this[_addToBuildSet](node, set)),\n            getChildren: node => [...node.children.values()],\n            filter: node => node.inBundle,\n          })\n        }\n      }\n    }\n    await promiseAllRejectLate(promises)\n\n    // now sort into the queues for the 4 things we have to do\n    // run in the same predictable order that buildIdealTree uses\n    // there's no particular reason for doing it in this order rather\n    // than another, but sorting *somehow* makes it consistent.\n    const queue = [...set].sort(sortNodes)\n\n    for (const node of queue) {\n      const { package: { bin, scripts = {} } } = node.target\n      const { preinstall, install, postinstall, prepare } = scripts\n      const tests = { bin, preinstall, install, postinstall, prepare }\n      for (const [key, has] of Object.entries(tests)) {\n        if (has) {\n          this[_queues][key].push(node)\n        }\n      }\n    }\n    process.emit('timeEnd', 'build:queue')\n  }\n\n  async [_checkBins] (node) {\n    // if the node is a global top, and we're not in force mode, then\n    // any existing bins need to either be missing, or a symlink into\n    // the node path.  Otherwise a package can have a preinstall script\n    // that unlinks something, to allow them to silently overwrite system\n    // binaries, which is unsafe and insecure.\n    if (!node.globalTop || this[_force]) {\n      return\n    }\n    const { path, package: pkg } = node\n    await binLinks.checkBins({ pkg, path, top: true, global: true })\n  }\n\n  async [_addToBuildSet] (node, set, refreshed = false) {\n    if (set.has(node)) {\n      return\n    }\n\n    if (this[_oldMeta] === null) {\n      const { root: { meta } } = node\n      this[_oldMeta] = meta && meta.loadedFromDisk &&\n        !(meta.originalLockfileVersion >= 2)\n    }\n\n    const { package: pkg, hasInstallScript } = node.target\n    const { gypfile, bin, scripts = {} } = pkg\n\n    const { preinstall, install, postinstall, prepare } = scripts\n    const anyScript = preinstall || install || postinstall || prepare\n    if (!refreshed && !anyScript && (hasInstallScript || this[_oldMeta])) {\n      // we either have an old metadata (and thus might have scripts)\n      // or we have an indication that there's install scripts (but\n      // don't yet know what they are) so we have to load the package.json\n      // from disk to see what the deal is.  Failure here just means\n      // no scripts to add, probably borked package.json.\n      // add to the set then remove while we're reading the pj, so we\n      // don't accidentally hit it multiple times.\n      set.add(node)\n      const pkg = await rpj(node.path + '/package.json').catch(() => ({}))\n      set.delete(node)\n\n      const { scripts = {} } = pkg\n      node.package.scripts = scripts\n      return this[_addToBuildSet](node, set, true)\n    }\n\n    // Rebuild node-gyp dependencies lacking an install or preinstall script\n    // note that 'scripts' might be missing entirely, and the package may\n    // set gypfile:false to avoid this automatic detection.\n    const isGyp = gypfile !== false &&\n      !install &&\n      !preinstall &&\n      await isNodeGypPackage(node.path)\n\n    if (bin || preinstall || install || postinstall || prepare || isGyp) {\n      if (bin) {\n        await this[_checkBins](node)\n      }\n      if (isGyp) {\n        scripts.install = defaultGypInstallScript\n        node.package.scripts = scripts\n      }\n      set.add(node)\n    }\n  }\n\n  async [_runScripts] (event) {\n    const queue = this[_queues][event]\n\n    if (!queue.length) {\n      return\n    }\n\n    process.emit('time', `build:run:${event}`)\n    const stdio = this.options.foregroundScripts ? 'inherit' : 'pipe'\n    const limit = this.options.foregroundScripts ? 1 : undefined\n    await promiseCallLimit(queue.map(node => async () => {\n      const {\n        path,\n        integrity,\n        resolved,\n        optional,\n        peer,\n        dev,\n        devOptional,\n        package: pkg,\n        location,\n      } = node.target\n\n      // skip any that we know we'll be deleting\n      if (this[_trashList].has(path)) {\n        return\n      }\n\n      const timer = `build:run:${event}:${location}`\n      process.emit('time', timer)\n      log.info('run', pkg._id, event, location, pkg.scripts[event])\n      const env = {\n        npm_package_resolved: resolved,\n        npm_package_integrity: integrity,\n        npm_package_json: resolve(path, 'package.json'),\n        npm_package_optional: boolEnv(optional),\n        npm_package_dev: boolEnv(dev),\n        npm_package_peer: boolEnv(peer),\n        npm_package_dev_optional:\n          boolEnv(devOptional && !dev && !optional),\n      }\n      const runOpts = {\n        event,\n        path,\n        pkg,\n        stdioString: true,\n        stdio,\n        env,\n        scriptShell: this[_scriptShell],\n      }\n      const p = runScript(runOpts).catch(er => {\n        const { code, signal } = er\n        log.info('run', pkg._id, event, { code, signal })\n        throw er\n      }).then(({ args, code, signal, stdout, stderr }) => {\n        this.scriptsRun.add({\n          pkg,\n          path,\n          event,\n          cmd: args && args[args.length - 1],\n          env,\n          code,\n          signal,\n          stdout,\n          stderr,\n        })\n        log.info('run', pkg._id, event, { code, signal })\n      })\n\n      await (this[_doHandleOptionalFailure]\n        ? this[_handleOptionalFailure](node, p)\n        : p)\n\n      process.emit('timeEnd', timer)\n    }), limit)\n    process.emit('timeEnd', `build:run:${event}`)\n  }\n\n  async [_linkAllBins] () {\n    const queue = this[_queues].bin\n    if (!queue.length) {\n      return\n    }\n\n    process.emit('time', 'build:link')\n    const promises = []\n    // sort the queue by node path, so that the module-local collision\n    // detector in bin-links will always resolve the same way.\n    for (const node of queue.sort(sortNodes)) {\n      promises.push(this[_createBinLinks](node))\n    }\n\n    await promiseAllRejectLate(promises)\n    process.emit('timeEnd', 'build:link')\n  }\n\n  async [_createBinLinks] (node) {\n    if (this[_trashList].has(node.path)) {\n      return\n    }\n\n    process.emit('time', `build:link:${node.location}`)\n\n    const p = binLinks({\n      pkg: node.package,\n      path: node.path,\n      top: !!(node.isTop || node.globalTop),\n      force: this[_force],\n      global: !!node.globalTop,\n    })\n\n    await (this[_doHandleOptionalFailure]\n      ? this[_handleOptionalFailure](node, p)\n      : p)\n\n    process.emit('timeEnd', `build:link:${node.location}`)\n  }\n}\n","// Get the actual nodes corresponding to a root node's child workspaces,\n// given a list of workspace names.\n\nconst log = require('proc-log')\nconst relpath = require('./relpath.js')\n\nconst getWorkspaceNodes = (tree, workspaces) => {\n  const wsMap = tree.workspaces\n  if (!wsMap) {\n    log.warn('workspaces', 'filter set, but no workspaces present')\n    return []\n  }\n\n  const nodes = []\n  for (const name of workspaces) {\n    const path = wsMap.get(name)\n    if (!path) {\n      log.warn('workspaces', `${name} in filter set, but not in workspaces`)\n      continue\n    }\n\n    const loc = relpath(tree.realpath, path)\n    const node = tree.inventory.get(loc)\n\n    if (!node) {\n      log.warn('workspaces', `${name} in filter set, but no workspace folder present`)\n      continue\n    }\n\n    nodes.push(node)\n  }\n\n  return nodes\n}\n\nmodule.exports = getWorkspaceNodes\n"]}