{"version":3,"sources":["run-script.js","run-script-pkg.js","make-spawn-args.js","is-windows.js","set-path.js","package-envs.js","signal-manager.js","is-server-package.js","validate-options.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AGRA,ADGA,ADGA,ADGA;AELA,ADGA,ADGA,AIZA;AFOA,ADGA,ADGA,AIZA;AFOA,ADGA,AGTA;AFOA,AGTA,AJYA,AGTA;AFOA,AGTA,AJYA,AGTA;AFOA,AGTA,AJYA,AGTA;AFOA,AGTA,AJYA,AGTA,AENA;AJaA,AGTA,AJYA,AGTA,AENA;AJaA,AGTA,AJYA,AGTA,AENA;ACFA,ALeA,AGTA,AJYA,AGTA,AENA;ACFA,ALeA,AGTA,AJYA,AGTA,AENA;ACFA,ALeA,AGTA,AJYA,AGTA,AENA;ACFA,ALeA,AGTA,AJYA,AGTA,AENA,AENA;ADIA,ALeA,AGTA,AJYA,AGTA,AENA,AENA;ADIA,ALeA,AGTA,AJYA,AGTA,AENA,AENA;ADIA,ALeA,AGTA,AJYA,AGTA,AENA,AENA;ADIA,ALeA,AGTA,AJYA,AGTA,AENA,AENA;ADIA,ALeA,AGTA,AJYA,AGTA,AENA,AENA;ADIA,ALeA,AGTA,AJYA,AGTA,AENA,AENA;ADIA,ALeA,AGTA,AJYA,AGTA,AENA,AENA;ADIA,ALeA,AGTA,AJYA,AGTA,AENA,AENA;ADIA,ALeA,AGTA,AJYA,AGTA,AENA,AENA;ANmBA,AGTA,AJYA,AGTA,AENA,AENA;ANmBA,AGTA,AJYA,AGTA,AENA,AENA;ANmBA,AGTA,AJYA,AGTA,AENA,AENA;ANmBA,AGTA,AJYA,AGTA,AENA,AENA;ANmBA,AGTA,AJYA,AGTA,AENA,AENA;ANmBA,AGTA,AJYA,AGTA,AENA,AENA;ANmBA,AGTA,AJYA,AGTA,AENA,AENA;ANmBA,AGTA,AJYA,AGTA,AENA,AENA;ANmBA,ADGA,AGTA,AENA,AENA;ANmBA,ADGA,AGTA,AENA,AENA;ANmBA,ADGA,AGTA,AENA,AENA;ANmBA,ADGA,AGTA,AENA,AENA;ANmBA,ADGA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AGTA,AENA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA;ALgBA,AKfA;ALgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const rpj = require('read-package-json-fast')\nconst runScriptPkg = require('./run-script-pkg.js')\nconst validateOptions = require('./validate-options.js')\nconst isServerPackage = require('./is-server-package.js')\n\nconst runScript = options => {\n  validateOptions(options)\n  const { pkg, path } = options\n  return pkg ? runScriptPkg(options)\n    : rpj(path + '/package.json').then(pkg => runScriptPkg({ ...options, pkg }))\n}\n\nmodule.exports = Object.assign(runScript, { isServerPackage })\n","const makeSpawnArgs = require('./make-spawn-args.js')\nconst promiseSpawn = require('@npmcli/promise-spawn')\nconst packageEnvs = require('./package-envs.js')\nconst { isNodeGypPackage, defaultGypInstallScript } = require('@npmcli/node-gyp')\nconst signalManager = require('./signal-manager.js')\nconst isServerPackage = require('./is-server-package.js')\n\n// you wouldn't like me when I'm angry...\nconst bruce = (id, event, cmd) =>\n  `\\n> ${id ? id + ' ' : ''}${event}\\n> ${cmd.trim().replace(/\\n/g, '\\n> ')}\\n`\n\nconst runScriptPkg = async options => {\n  const {\n    event,\n    path,\n    scriptShell,\n    env = {},\n    stdio = 'pipe',\n    pkg,\n    args = [],\n    stdioString = false,\n    // note: only used when stdio:inherit\n    banner = true,\n    // how long to wait for a process.kill signal\n    // only exposed here so that we can make the test go a bit faster.\n    signalTimeout = 500,\n  } = options\n\n  const { scripts = {}, gypfile } = pkg\n  let cmd = null\n  if (options.cmd) {\n    cmd = options.cmd\n  } else if (pkg.scripts && pkg.scripts[event]) {\n    cmd = pkg.scripts[event] + args.map(a => ` ${JSON.stringify(a)}`).join('')\n  } else if (\n    // If there is no preinstall or install script, default to rebuilding node-gyp packages.\n    event === 'install' &&\n    !scripts.install &&\n    !scripts.preinstall &&\n    gypfile !== false &&\n    await isNodeGypPackage(path)\n  ) {\n    cmd = defaultGypInstallScript\n  } else if (event === 'start' && await isServerPackage(path)) {\n    cmd = 'node server.js' + args.map(a => ` ${JSON.stringify(a)}`).join('')\n  }\n\n  if (!cmd) {\n    return { code: 0, signal: null }\n  }\n\n  if (stdio === 'inherit' && banner !== false) {\n    // we're dumping to the parent's stdout, so print the banner\n    console.log(bruce(pkg._id, event, cmd))\n  }\n\n  const p = promiseSpawn(...makeSpawnArgs({\n    event,\n    path,\n    scriptShell,\n    env: packageEnvs(env, pkg),\n    stdio,\n    cmd,\n    stdioString,\n  }), {\n    event,\n    script: cmd,\n    pkgid: pkg._id,\n    path,\n  })\n\n  if (stdio === 'inherit') {\n    signalManager.add(p.process)\n  }\n\n  if (p.stdin) {\n    p.stdin.end()\n  }\n\n  return p.catch(er => {\n    const { signal } = er\n    if (stdio === 'inherit' && signal) {\n      process.kill(process.pid, signal)\n      // just in case we don't die, reject after 500ms\n      // this also keeps the node process open long enough to actually\n      // get the signal, rather than terminating gracefully.\n      return new Promise((res, rej) => setTimeout(() => rej(er), signalTimeout))\n    } else {\n      throw er\n    }\n  })\n}\n\nmodule.exports = runScriptPkg\n","/* eslint camelcase: \"off\" */\nconst isWindows = require('./is-windows.js')\nconst setPATH = require('./set-path.js')\nconst { resolve } = require('path')\nconst npm_config_node_gyp = require.resolve('node-gyp/bin/node-gyp.js')\n\nconst makeSpawnArgs = options => {\n  const {\n    event,\n    path,\n    scriptShell = isWindows ? process.env.ComSpec || 'cmd' : 'sh',\n    env = {},\n    stdio,\n    cmd,\n    stdioString = false,\n  } = options\n\n  const isCmd = /(?:^|\\\\)cmd(?:\\.exe)?$/i.test(scriptShell)\n  const args = isCmd ? ['/d', '/s', '/c', cmd] : ['-c', cmd]\n\n  const spawnOpts = {\n    env: setPATH(path, {\n      // we need to at least save the PATH environment var\n      ...process.env,\n      ...env,\n      npm_package_json: resolve(path, 'package.json'),\n      npm_lifecycle_event: event,\n      npm_lifecycle_script: cmd,\n      npm_config_node_gyp,\n    }),\n    stdioString,\n    stdio,\n    cwd: path,\n    ...(isCmd ? { windowsVerbatimArguments: true } : {}),\n  }\n\n  return [scriptShell, args, spawnOpts]\n}\n\nmodule.exports = makeSpawnArgs\n","const platform = process.env.__FAKE_TESTING_PLATFORM__ || process.platform\nmodule.exports = platform === 'win32'\n","const { resolve, dirname } = require('path')\nconst isWindows = require('./is-windows.js')\n// the path here is relative, even though it does not need to be\n// in order to make the posix tests pass in windows\nconst nodeGypPath = resolve(__dirname, '../lib/node-gyp-bin')\n\n// Windows typically calls its PATH environ 'Path', but this is not\n// guaranteed, nor is it guaranteed to be the only one.  Merge them\n// all together in the order they appear in the object.\nconst setPATH = (projectPath, env) => {\n  // not require('path').delimiter, because we fake this for testing\n  const delimiter = isWindows ? ';' : ':'\n  const PATH = Object.keys(env).filter(p => /^path$/i.test(p) && env[p])\n    .map(p => env[p].split(delimiter))\n    .reduce((set, p) => set.concat(p.filter(p => !set.includes(p))), [])\n    .join(delimiter)\n\n  const pathArr = []\n  // unshift the ./node_modules/.bin from every folder\n  // walk up until dirname() does nothing, at the root\n  // XXX should we specify a cwd that we don't go above?\n  let p = projectPath\n  let pp\n  do {\n    pathArr.push(resolve(p, 'node_modules', '.bin'))\n    pp = p\n    p = dirname(p)\n  } while (p !== pp)\n  pathArr.push(nodeGypPath, PATH)\n\n  const pathVal = pathArr.join(delimiter)\n\n  // XXX include the node-gyp-bin path somehow?  Probably better for\n  // npm or arborist or whoever to just provide that by putting it in\n  // the PATH environ, since that's preserved anyway.\n  for (const key of Object.keys(env)) {\n    if (/^path$/i.test(key)) {\n      env[key] = pathVal\n    }\n  }\n\n  return env\n}\n\nmodule.exports = setPATH\n","// https://github.com/npm/rfcs/pull/183\n\nconst envVal = val => Array.isArray(val) ? val.map(v => envVal(v)).join('\\n\\n')\n  : val === null || val === false ? ''\n  : String(val)\n\nconst packageEnvs = (env, vals, prefix) => {\n  for (const [key, val] of Object.entries(vals)) {\n    if (val === undefined) {\n      continue\n    } else if (val && !Array.isArray(val) && typeof val === 'object') {\n      packageEnvs(env, val, `${prefix}${key}_`)\n    } else {\n      env[`${prefix}${key}`] = envVal(val)\n    }\n  }\n  return env\n}\n\nmodule.exports = (env, pkg) => packageEnvs({ ...env }, {\n  name: pkg.name,\n  version: pkg.version,\n  config: pkg.config,\n  engines: pkg.engines,\n  bin: pkg.bin,\n}, 'npm_package_')\n","const runningProcs = new Set()\nlet handlersInstalled = false\n\nconst forwardedSignals = [\n  'SIGINT',\n  'SIGTERM',\n]\n\nconst handleSignal = signal => {\n  for (const proc of runningProcs) {\n    proc.kill(signal)\n  }\n}\n\nconst setupListeners = () => {\n  for (const signal of forwardedSignals) {\n    process.on(signal, handleSignal)\n  }\n  handlersInstalled = true\n}\n\nconst cleanupListeners = () => {\n  if (runningProcs.size === 0) {\n    for (const signal of forwardedSignals) {\n      process.removeListener(signal, handleSignal)\n    }\n    handlersInstalled = false\n  }\n}\n\nconst add = proc => {\n  runningProcs.add(proc)\n  if (!handlersInstalled) {\n    setupListeners()\n  }\n\n  proc.once('exit', () => {\n    runningProcs.delete(proc)\n    cleanupListeners()\n  })\n}\n\nmodule.exports = {\n  add,\n  handleSignal,\n  forwardedSignals,\n}\n","const util = require('util')\nconst fs = require('fs')\nconst { stat } = fs.promises || { stat: util.promisify(fs.stat) }\nconst { resolve } = require('path')\nmodule.exports = async path => {\n  try {\n    const st = await stat(resolve(path, 'server.js'))\n    return st.isFile()\n  } catch (er) {\n    return false\n  }\n}\n","const validateOptions = options => {\n  if (typeof options !== 'object' || !options) {\n    throw new TypeError('invalid options object provided to runScript')\n  }\n\n  const {\n    event,\n    path,\n    scriptShell,\n    env = {},\n    stdio = 'pipe',\n    args = [],\n    cmd,\n  } = options\n\n  if (!event || typeof event !== 'string') {\n    throw new TypeError('valid event not provided to runScript')\n  }\n  if (!path || typeof path !== 'string') {\n    throw new TypeError('valid path not provided to runScript')\n  }\n  if (scriptShell !== undefined && typeof scriptShell !== 'string') {\n    throw new TypeError('invalid scriptShell option provided to runScript')\n  }\n  if (typeof env !== 'object' || !env) {\n    throw new TypeError('invalid env option provided to runScript')\n  }\n  if (typeof stdio !== 'string' && !Array.isArray(stdio)) {\n    throw new TypeError('invalid stdio option provided to runScript')\n  }\n  if (!Array.isArray(args) || args.some(a => typeof a !== 'string')) {\n    throw new TypeError('invalid args option provided to runScript')\n  }\n  if (cmd !== undefined && typeof cmd !== 'string') {\n    throw new TypeError('invalid cmd option provided to runScript')\n  }\n}\n\nmodule.exports = validateOptions\n"]}