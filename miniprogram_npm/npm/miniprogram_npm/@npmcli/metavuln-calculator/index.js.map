{"version":3,"sources":["index.js","advisory.js","hash.js","get-dep-spec.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,AENA,AHSA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// this is the public class that is used by consumers.\n// the Advisory class handles all the calculation, and this\n// class handles all the IO with the registry and cache.\nconst pacote = require('pacote')\nconst cacache = require('cacache')\nconst Advisory = require('./advisory.js')\nconst { homedir } = require('os')\nconst jsonParse = require('json-parse-even-better-errors')\n\nconst _packument = Symbol('packument')\nconst _cachePut = Symbol('cachePut')\nconst _cacheGet = Symbol('cacheGet')\nconst _cacheData = Symbol('cacheData')\nconst _packuments = Symbol('packuments')\nconst _cache = Symbol('cache')\nconst _options = Symbol('options')\nconst _advisories = Symbol('advisories')\nconst _calculate = Symbol('calculate')\n\nclass Calculator {\n  constructor (options = {}) {\n    this[_options] = { ...options }\n    this[_cache] = this[_options].cache || (homedir() + '/.npm/_cacache')\n    this[_options].cache = this[_cache]\n    this[_packuments] = new Map()\n    this[_cacheData] = new Map()\n    this[_advisories] = new Map()\n  }\n\n  get cache () {\n    return this[_cache]\n  }\n\n  get options () {\n    return { ...this[_options] }\n  }\n\n  async calculate (name, source) {\n    const k = `security-advisory:${name}:${source.id}`\n    if (this[_advisories].has(k)) {\n      return this[_advisories].get(k)\n    }\n\n    const p = this[_calculate](name, source)\n    this[_advisories].set(k, p)\n    return p\n  }\n\n  async [_calculate] (name, source) {\n    const k = `security-advisory:${name}:${source.id}`\n    const t = `metavuln:calculate:${k}`\n    process.emit('time', t)\n    const advisory = new Advisory(name, source, this[_options])\n    // load packument and cached advisory\n    const [cached, packument] = await Promise.all([\n      this[_cacheGet](advisory),\n      this[_packument](name),\n    ])\n    process.emit('time', `metavuln:load:${k}`)\n    advisory.load(cached, packument)\n    process.emit('timeEnd', `metavuln:load:${k}`)\n    if (advisory.updated) {\n      await this[_cachePut](advisory)\n    }\n    this[_advisories].set(k, advisory)\n    process.emit('timeEnd', t)\n    return advisory\n  }\n\n  async [_cachePut] (advisory) {\n    const { name, id } = advisory\n    const key = `security-advisory:${name}:${id}`\n    process.emit('time', `metavuln:cache:put:${key}`)\n    const data = JSON.stringify(advisory)\n    const options = { ...this[_options] }\n    this[_cacheData].set(key, jsonParse(data))\n    await cacache.put(this[_cache], key, data, options).catch(() => {})\n    process.emit('timeEnd', `metavuln:cache:put:${key}`)\n  }\n\n  async [_cacheGet] (advisory) {\n    const { name, id } = advisory\n    const key = `security-advisory:${name}:${id}`\n    /* istanbul ignore if - should be impossible, since we memoize the\n     * advisory object itself using the same key, just being cautious */\n    if (this[_cacheData].has(key)) {\n      return this[_cacheData].get(key)\n    }\n\n    process.emit('time', `metavuln:cache:get:${key}`)\n    const p = cacache.get(this[_cache], key, { ...this[_options] })\n      .catch(() => ({ data: '{}' }))\n      .then(({ data }) => {\n        data = jsonParse(data)\n        process.emit('timeEnd', `metavuln:cache:get:${key}`)\n        this[_cacheData].set(key, data)\n        return data\n      })\n    this[_cacheData].set(key, p)\n    return p\n  }\n\n  async [_packument] (name) {\n    if (this[_packuments].has(name)) {\n      return this[_packuments].get(name)\n    }\n\n    process.emit('time', `metavuln:packument:${name}`)\n    const p = pacote.packument(name, { ...this[_options] })\n      .catch((er) => {\n        // presumably not something from the registry.\n        // an empty packument will have an effective range of *\n        return {\n          name,\n          versions: {},\n        }\n      })\n      .then(paku => {\n        process.emit('timeEnd', `metavuln:packument:${name}`)\n        this[_packuments].set(name, paku)\n        return paku\n      })\n    this[_packuments].set(name, p)\n    return p\n  }\n}\n\nmodule.exports = Calculator\n","const hash = require('./hash.js')\nconst semver = require('semver')\nconst semverOpt = { includePrerelease: true, loose: true }\nconst getDepSpec = require('./get-dep-spec.js')\n\n// any fields that we don't want in the cache need to be hidden\nconst _source = Symbol('source')\nconst _packument = Symbol('packument')\nconst _versionVulnMemo = Symbol('versionVulnMemo')\nconst _updated = Symbol('updated')\nconst _options = Symbol('options')\nconst _specVulnMemo = Symbol('specVulnMemo')\nconst _testVersion = Symbol('testVersion')\nconst _testVersions = Symbol('testVersions')\nconst _calculateRange = Symbol('calculateRange')\nconst _markVulnerable = Symbol('markVulnerable')\nconst _testSpec = Symbol('testSpec')\n\nclass Advisory {\n  constructor (name, source, options = {}) {\n    this.source = source.id\n    this[_source] = source\n    this[_options] = options\n    this.name = name\n    if (!source.name) {\n      source.name = name\n    }\n\n    this.dependency = source.name\n\n    if (this.type === 'advisory') {\n      this.title = source.title\n      this.url = source.url\n    } else {\n      this.title = `Depends on vulnerable versions of ${source.name}`\n      this.url = null\n    }\n\n    this.severity = source.severity || 'high'\n    this.versions = []\n    this.vulnerableVersions = []\n\n    // advisories have the range, metavulns do not\n    // if an advisory doesn't specify range, assume all are vulnerable\n    this.range = this.type === 'advisory' ? source.vulnerable_versions || '*'\n      : null\n\n    this.id = hash(this)\n\n    this[_packument] = null\n    // memoized list of which versions are vulnerable\n    this[_versionVulnMemo] = new Map()\n    // memoized list of which dependency specs are vulnerable\n    this[_specVulnMemo] = new Map()\n    this[_updated] = false\n  }\n\n  // true if we updated from what we had in cache\n  get updated () {\n    return this[_updated]\n  }\n\n  get type () {\n    return this.dependency === this.name ? 'advisory' : 'metavuln'\n  }\n\n  get packument () {\n    return this[_packument]\n  }\n\n  // load up the data from a cache entry and a fetched packument\n  load (cached, packument) {\n    // basic data integrity gutcheck\n    if (!cached || typeof cached !== 'object') {\n      throw new TypeError('invalid cached data, expected object')\n    }\n\n    if (!packument || typeof packument !== 'object') {\n      throw new TypeError('invalid packument data, expected object')\n    }\n\n    if (cached.id && cached.id !== this.id) {\n      throw Object.assign(new Error('loading from incorrect cache entry'), {\n        expected: this.id,\n        actual: cached.id,\n      })\n    }\n    if (packument.name !== this.name) {\n      throw Object.assign(new Error('loading from incorrect packument'), {\n        expected: this.name,\n        actual: packument.name,\n      })\n    }\n    if (this[_packument]) {\n      throw new Error('advisory object already loaded')\n    }\n\n    // if we have a range from the initialization, and the cached\n    // data has a *different* range, then we know we have to recalc.\n    // just don't use the cached data, so we will definitely not match later\n    if (!this.range || cached.range && cached.range === this.range) {\n      Object.assign(this, cached)\n    }\n\n    this[_packument] = packument\n\n    const pakuVersions = Object.keys(packument.versions)\n    const allVersions = new Set([...pakuVersions, ...this.versions])\n    const versionsAdded = []\n    const versionsRemoved = []\n    for (const v of allVersions) {\n      if (!this.versions.includes(v)) {\n        versionsAdded.push(v)\n        this.versions.push(v)\n      } else if (!pakuVersions.includes(v)) {\n        versionsRemoved.push(v)\n      }\n    }\n\n    // strip out any removed versions from our lists, and sort by semver\n    this.versions = semver.sort(this.versions.filter(v =>\n      !versionsRemoved.includes(v)), semverOpt)\n\n    // if no changes, then just return what we got from cache\n    // versions added or removed always means we changed\n    // otherwise, advisories change if the range changes, and\n    // metavulns change if the source was updated\n    const unchanged = this.type === 'advisory'\n      ? this.range && this.range === cached.range\n      : !this[_source].updated\n\n    // if the underlying source changed, by an advisory updating the\n    // range, or a source advisory being updated, then we have to re-check\n    // otherwise, only recheck the new ones.\n    this.vulnerableVersions = !unchanged ? []\n      : semver.sort(this.vulnerableVersions.filter(v =>\n        !versionsRemoved.includes(v)), semverOpt)\n\n    if (unchanged && !versionsAdded.length && !versionsRemoved.length) {\n      // nothing added or removed, nothing to do here.  use the cached copy.\n      return this\n    }\n\n    this[_updated] = true\n\n    // test any versions newly added\n    if (!unchanged || versionsAdded.length) {\n      this[_testVersions](unchanged ? versionsAdded : this.versions)\n    }\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions, semverOpt)\n\n    // metavulns have to calculate their range, since cache is invalidated\n    // advisories just get their range from the advisory above\n    if (this.type === 'metavuln') {\n      this[_calculateRange]()\n    }\n\n    return this\n  }\n\n  [_calculateRange] () {\n    // calling semver.simplifyRange with a massive list of versions, and those\n    // versions all concatenated with `||` is a geometric CPU explosion!\n    // we can try to be a *little* smarter up front by doing x-y for all\n    // contiguous version sets in the list\n    const ranges = []\n    this.versions = semver.sort(this.versions)\n    this.vulnerableVersions = semver.sort(this.vulnerableVersions)\n    for (let v = 0, vulnVer = 0; v < this.versions.length; v++) {\n      // figure out the vulnerable subrange\n      const vr = [this.versions[v]]\n      while (v < this.versions.length) {\n        if (this.versions[v] !== this.vulnerableVersions[vulnVer]) {\n          // we don't test prerelease versions, so just skip past it\n          if (/-/.test(this.versions[v])) {\n            v++\n            continue\n          }\n          break\n        }\n        if (vr.length > 1) {\n          vr[1] = this.versions[v]\n        } else {\n          vr.push(this.versions[v])\n        }\n        v++\n        vulnVer++\n      }\n      // it'll either be just the first version, which means no overlap,\n      // or the start and end versions, which might be the same version\n      if (vr.length > 1) {\n        const tail = this.versions[this.versions.length - 1]\n        ranges.push(vr[1] === tail ? `>=${vr[0]}`\n          : vr[0] === vr[1] ? vr[0]\n          : vr.join(' - '))\n      }\n    }\n    const metavuln = ranges.join(' || ').trim()\n    this.range = !metavuln ? '<0.0.0-0'\n      : semver.simplifyRange(this.versions, metavuln, semverOpt)\n  }\n\n  // returns true if marked as vulnerable, false if ok\n  // spec is a dependency specifier, for metavuln cases\n  // where the version might not be in the packument.  if\n  // we have the packument and spec is not provided, then\n  // we use the dependency version from the manifest.\n  testVersion (version, spec = null) {\n    const sv = String(version)\n    if (this[_versionVulnMemo].has(sv)) {\n      return this[_versionVulnMemo].get(sv)\n    }\n\n    const result = this[_testVersion](version, spec)\n    if (result) {\n      this[_markVulnerable](version)\n    }\n    this[_versionVulnMemo].set(sv, !!result)\n    return result\n  }\n\n  [_markVulnerable] (version) {\n    const sv = String(version)\n    if (!this.vulnerableVersions.includes(sv)) {\n      this.vulnerableVersions.push(sv)\n    }\n  }\n\n  [_testVersion] (version, spec) {\n    const sv = String(version)\n    if (this.vulnerableVersions.includes(sv)) {\n      return true\n    }\n\n    if (this.type === 'advisory') {\n      // advisory, just test range\n      return semver.satisfies(version, this.range, semverOpt)\n    }\n\n    // check the dependency of this version on the vulnerable dep\n    // if we got a version that's not in the packument, fall back on\n    // the spec provided, if possible.\n    const mani = this[_packument].versions[version] || {\n      dependencies: {\n        [this.dependency]: spec,\n      },\n    }\n\n    if (!spec) {\n      spec = getDepSpec(mani, this.dependency)\n    }\n\n    // no dep, no vuln\n    if (spec === null) {\n      return false\n    }\n\n    if (!semver.validRange(spec, semverOpt)) {\n      // not a semver range, nothing we can hope to do about it\n      return true\n    }\n\n    const bd = mani.bundleDependencies\n    const bundled = bd && bd.includes(this[_source].name)\n    // XXX if bundled, then semver.intersects() means vulnerable\n    // else, pick a manifest and see if it can't be avoided\n    // try to pick a version of the dep that isn't vulnerable\n    const avoid = this[_source].range\n\n    if (bundled) {\n      return semver.intersects(spec, avoid, semverOpt)\n    }\n\n    return this[_source].testSpec(spec)\n  }\n\n  testSpec (spec) {\n    // testing all the versions is a bit costly, and the spec tends to stay\n    // consistent across multiple versions, so memoize this as well, in case\n    // we're testing lots of versions.\n    const memo = this[_specVulnMemo]\n    if (memo.has(spec)) {\n      return memo.get(spec)\n    }\n\n    const res = this[_testSpec](spec)\n    memo.set(spec, res)\n    return res\n  }\n\n  [_testSpec] (spec) {\n    for (const v of this.versions) {\n      const satisfies = semver.satisfies(v, spec)\n      if (!satisfies) {\n        continue\n      }\n      if (!this.testVersion(v)) {\n        return false\n      }\n    }\n    // either vulnerable, or not installable because nothing satisfied\n    // either way, best avoided.\n    return true\n  }\n\n  [_testVersions] (versions) {\n    if (!versions.length) {\n      return\n    }\n\n    // set of lists of versions\n    const versionSets = new Set()\n    versions = semver.sort(versions.map(v => semver.parse(v, semverOpt)))\n\n    // start out with the versions grouped by major and minor\n    let last = versions[0].major + '.' + versions[0].minor\n    let list = []\n    versionSets.add(list)\n    for (const v of versions) {\n      const k = v.major + '.' + v.minor\n      if (k !== last) {\n        last = k\n        list = []\n        versionSets.add(list)\n      }\n      list.push(v)\n    }\n\n    for (const list of versionSets) {\n      // it's common to have version lists like:\n      // 1.0.0\n      // 1.0.1-alpha.0\n      // 1.0.1-alpha.1\n      // ...\n      // 1.0.1-alpha.999\n      // 1.0.1\n      // 1.0.2-alpha.0\n      // ...\n      // 1.0.2-alpha.99\n      // 1.0.2\n      // with a huge number of prerelease versions that are not installable\n      // anyway.\n      // If mid has a prerelease tag, and list[0] does not, then walk it\n      // back until we hit a non-prerelease version\n      // If mid has a prerelease tag, and list[list.length-1] does not,\n      // then walk it forward until we hit a version without a prerelease tag\n      // Similarly, if the head/tail is a prerelease, but there is a non-pr\n      // version in the list, then start there instead.\n      let h = 0\n      const origHeadVuln = this.testVersion(list[h])\n      while (h < list.length && /-/.test(String(list[h]))) {\n        h++\n      }\n\n      // don't filter out the whole list!  they might all be pr's\n      if (h === list.length) {\n        h = 0\n      } else if (origHeadVuln) {\n        // if the original was vulnerable, assume so are all of these\n        for (let hh = 0; hh < h; hh++) {\n          this[_markVulnerable](list[hh])\n        }\n      }\n\n      let t = list.length - 1\n      const origTailVuln = this.testVersion(list[t])\n      while (t > h && /-/.test(String(list[t]))) {\n        t--\n      }\n\n      // don't filter out the whole list!  might all be pr's\n      if (t === h) {\n        t = list.length - 1\n      } else if (origTailVuln) {\n        // if original tail was vulnerable, assume these are as well\n        for (let tt = list.length - 1; tt > t; tt--) {\n          this[_markVulnerable](list[tt])\n        }\n      }\n\n      const headVuln = h === 0 ? origHeadVuln\n        : this.testVersion(list[h])\n\n      const tailVuln = t === list.length - 1 ? origTailVuln\n        : this.testVersion(list[t])\n\n      // if head and tail both vulnerable, whole list is thrown out\n      if (headVuln && tailVuln) {\n        for (let v = h; v < t; v++) {\n          this[_markVulnerable](list[v])\n        }\n        continue\n      }\n\n      // if length is 2 or 1, then we marked them all already\n      if (t < h + 2) {\n        continue\n      }\n\n      const mid = Math.floor(list.length / 2)\n      const pre = list.slice(0, mid)\n      const post = list.slice(mid)\n\n      // if the parent list wasn't prereleases, then drop pr tags\n      // from end of the pre list, and beginning of the post list,\n      // marking as vulnerable if the midpoint item we picked is.\n      if (!/-/.test(String(pre[0]))) {\n        const midVuln = this.testVersion(pre[pre.length - 1])\n        while (/-/.test(String(pre[pre.length - 1]))) {\n          const v = pre.pop()\n          if (midVuln) {\n            this[_markVulnerable](v)\n          }\n        }\n      }\n\n      if (!/-/.test(String(post[post.length - 1]))) {\n        const midVuln = this.testVersion(post[0])\n        while (/-/.test(String(post[0]))) {\n          const v = post.shift()\n          if (midVuln) {\n            this[_markVulnerable](v)\n          }\n        }\n      }\n\n      versionSets.add(pre)\n      versionSets.add(post)\n    }\n  }\n}\n\nmodule.exports = Advisory\n","const { createHash } = require('crypto')\n\nmodule.exports = ({ name, source }) => createHash('sha512')\n  .update(JSON.stringify([name, source]))\n  .digest('base64')\n","module.exports = (mani, name) => {\n  // skip dev because that only matters at the root,\n  // where we aren't fetching a manifest from the registry\n  // with multiple versions anyway.\n  const {\n    dependencies: deps = {},\n    optionalDependencies: optDeps = {},\n    peerDependencies: peerDeps = {},\n  } = mani\n\n  return deps && typeof deps[name] === 'string' ? deps[name]\n    : optDeps && typeof optDeps[name] === 'string' ? optDeps[name]\n    : peerDeps && typeof peerDeps[name] === 'string' ? peerDeps[name]\n    : null\n}\n"]}