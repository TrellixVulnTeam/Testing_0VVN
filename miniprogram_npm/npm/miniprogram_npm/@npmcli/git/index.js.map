{"version":3,"sources":["index.js","clone.js","revs.js","spawn.js","make-error.js","errors.js","which.js","opts.js","lines-to-revs.js","utils.js","is.js","find.js","is-clean.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AIZA,ADGA,AFMA,ACHA;AFOA,AIZA,ADGA,AFMA,ACHA;AFOA,AIZA,ADGA,AFMA,ACHA;AFOA,AIZA,ADGA,AFMA,ACHA,AGTA;ALgBA,AIZA,ADGA,AFMA,ACHA,AGTA;ALgBA,AIZA,ADGA,AFMA,ACHA,AGTA;ALgBA,AIZA,ADGA,AGTA,ALeA,ACHA,AGTA;ALgBA,AIZA,ADGA,AGTA,ALeA,ACHA,AGTA;ALgBA,AIZA,ADGA,AGTA,ALeA,ACHA,AGTA;ALgBA,AIZA,AGTA,AJYA,AGTA,ALeA,ACHA,AGTA;ALgBA,AIZA,AGTA,AJYA,AGTA,ALeA,ACHA,AGTA;ALgBA,AIZA,AGTA,AJYA,AGTA,ALeA,ACHA,AGTA;ALgBA,AIZA,AGTA,AJYA,AGTA,ALeA,ACHA,AMlBA,AHSA;ALgBA,AIZA,AGTA,AJYA,AGTA,ALeA,ACHA,AMlBA,AHSA;ALgBA,AIZA,AGTA,AJYA,AGTA,ALeA,ACHA,AMlBA,AHSA;ALgBA,AIZA,AKfA,AFMA,AJYA,AGTA,ALeA,ACHA,AMlBA,AHSA;ALgBA,AIZA,AKfA,AFMA,AJYA,AGTA,ALeA,ACHA,AGTA;ALgBA,AIZA,AKfA,AFMA,AJYA,AGTA,ALeA,ACHA,AGTA;ALgBA,AIZA,AMlBA,ADGA,AFMA,AJYA,AGTA,ALeA,ACHA,AGTA;ALgBA,AIZA,AMlBA,ADGA,AFMA,AJYA,AFMA,ACHA,AGTA;ALgBA,AIZA,AMlBA,ADGA,AFMA,AJYA,ADGA;AFOA,AIZA,AMlBA,ACHA,AFMA,AFMA,AJYA,ADGA;AFOA,AIZA,AMlBA,ACHA,AJYA,AJYA,ADGA;AFOA,AIZA,AMlBA,ACHA,AJYA,AJYA,ADGA;AFOA,AIZA,AMlBA,ACHA,AJYA,AJYA,ADGA;AFOA,AIZA,AMlBA,ACHA,AJYA,AJYA,ADGA;AFOA,AIZA,AMlBA,ACHA,AJYA,AJYA,ADGA;AFOA,AIZA,AMlBA,ACHA,AJYA,AJYA,ADGA;AFOA,AIZA,AMlBA,AHSA,AJYA,ADGA;AFOA,AIZA,AMlBA,AHSA,AJYA,ADGA;AFOA,AIZA,AMlBA,AHSA,AJYA,ADGA;AFOA,AIZA,AMlBA,AHSA,ALeA;AFOA,AIZA,AMlBA,AHSA,ALeA;AFOA,AIZA,AMlBA,AHSA,ALeA;AFOA,AIZA,AGTA,ALeA;AFOA,AIZA,AGTA,ALeA;AFOA,AIZA,AGTA,ALeA;AFOA,AOrBA,ALeA;AFOA,AOrBA,ALeA;AFOA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = {\n  clone: require('./clone.js'),\n  revs: require('./revs.js'),\n  spawn: require('./spawn.js'),\n  is: require('./is.js'),\n  find: require('./find.js'),\n  isClean: require('./is-clean.js'),\n  errors: require('./errors.js'),\n}\n","// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set([\n  'github.com',\n  'gist.github.com',\n  'gitlab.com',\n  'bitbucket.com',\n  'bitbucket.org',\n])\n// we have to use url.parse until we add the same shim that hosted-git-info has\n// to handle scp:// urls\nconst { parse } = require('url') // eslint-disable-line node/no-deprecated-api\nconst { basename, resolve } = require('path')\n\nconst revs = require('./revs.js')\nconst spawn = require('./spawn.js')\nconst { isWindows } = require('./utils.js')\n\nconst pickManifest = require('npm-pick-manifest')\nconst fs = require('fs')\nconst mkdirp = require('mkdirp')\n\nmodule.exports = (repo, ref = 'HEAD', target = null, opts = {}) =>\n  revs(repo, opts).then(revs => clone(\n    repo,\n    revs,\n    ref,\n    resolveRef(revs, ref, opts),\n    target || defaultTarget(repo, opts.cwd),\n    opts\n  ))\n\nconst maybeShallow = (repo, opts) => {\n  if (opts.gitShallow === false || opts.gitShallow) {\n    return opts.gitShallow\n  }\n  return shallowHosts.has(parse(repo).host)\n}\n\nconst defaultTarget = (repo, /* istanbul ignore next */ cwd = process.cwd()) =>\n  resolve(cwd, basename(repo.replace(/[/\\\\]?\\.git$/, '')))\n\nconst clone = (repo, revs, ref, revDoc, target, opts) => {\n  if (!revDoc) {\n    return unresolved(repo, ref, target, opts)\n  }\n  if (revDoc.sha === revs.refs.HEAD.sha) {\n    return plain(repo, revDoc, target, opts)\n  }\n  if (revDoc.type === 'tag' || revDoc.type === 'branch') {\n    return branch(repo, revDoc, target, opts)\n  }\n  return other(repo, revDoc, target, opts)\n}\n\nconst resolveRef = (revs, ref, opts) => {\n  const { spec = {} } = opts\n  ref = spec.gitCommittish || ref\n  /* istanbul ignore next - will fail anyway, can't pull */\n  if (!revs) {\n    return null\n  }\n  if (spec.gitRange) {\n    return pickManifest(revs, spec.gitRange, opts)\n  }\n  if (!ref) {\n    return revs.refs.HEAD\n  }\n  if (revs.refs[ref]) {\n    return revs.refs[ref]\n  }\n  if (revs.shas[ref]) {\n    return revs.refs[revs.shas[ref][0]]\n  }\n  return null\n}\n\n// pull request or some other kind of advertised ref\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts)\n\n  const fetchOrigin = ['fetch', 'origin', revDoc.rawRef]\n    .concat(shallow ? ['--depth=1'] : [])\n\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return mkdirp(target)\n    .then(() => git(['init']))\n    .then(() => isWindows(opts)\n      ? git(['config', '--local', '--add', 'core.longpaths', 'true'])\n      : null)\n    .then(() => git(['remote', 'add', 'origin', repo]))\n    .then(() => git(fetchOrigin))\n    .then(() => git(['checkout', revDoc.sha]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => revDoc.sha)\n}\n\n// tag or branches.  use -b\nconst branch = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    '-b',\n    revDoc.ref,\n    repo,\n    target,\n    '--recurse-submodules',\n  ]\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1')\n  }\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true')\n  }\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\n// just the head.  clone it\nconst plain = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    repo,\n    target,\n    '--recurse-submodules',\n  ]\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1')\n  }\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true')\n  }\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\nconst updateSubmodules = (target, opts) => new Promise(resolve =>\n  fs.stat(target + '/.gitmodules', er => {\n    if (er) {\n      return resolve(null)\n    }\n    return resolve(spawn([\n      'submodule',\n      'update',\n      '-q',\n      '--init',\n      '--recursive',\n    ], { ...opts, cwd: target }))\n  }))\n\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : []\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git']\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return mkdirp(target)\n    .then(() => git(cloneArgs.concat(lp)))\n    .then(() => git(['init']))\n    .then(() => git(['checkout', ref]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => git(['rev-parse', '--revs-only', 'HEAD']))\n    .then(({ stdout }) => stdout.trim())\n}\n","const pinflight = require('promise-inflight')\nconst spawn = require('./spawn.js')\nconst LRU = require('lru-cache')\n\nconst revsCache = new LRU({\n  max: 100,\n  ttl: 5 * 60 * 1000,\n})\n\nconst linesToRevs = require('./lines-to-revs.js')\n\nmodule.exports = async (repo, opts = {}) => {\n  if (!opts.noGitRevCache) {\n    const cached = revsCache.get(repo)\n    if (cached) {\n      return cached\n    }\n  }\n\n  return pinflight(`ls-remote:${repo}`, () =>\n    spawn(['ls-remote', repo], opts)\n      .then(({ stdout }) => linesToRevs(stdout.trim().split('\\n')))\n      .then(revs => {\n        revsCache.set(repo, revs)\n        return revs\n      })\n  )\n}\n","const spawn = require('@npmcli/promise-spawn')\nconst promiseRetry = require('promise-retry')\nconst log = require('proc-log')\nconst makeError = require('./make-error.js')\nconst whichGit = require('./which.js')\nconst makeOpts = require('./opts.js')\n\nmodule.exports = (gitArgs, opts = {}) => {\n  const gitPath = whichGit(opts)\n\n  if (gitPath instanceof Error) {\n    return Promise.reject(gitPath)\n  }\n\n  // undocumented option, mostly only here for tests\n  const args = opts.allowReplace || gitArgs[0] === '--no-replace-objects'\n    ? gitArgs\n    : ['--no-replace-objects', ...gitArgs]\n\n  let retry = opts.retry\n  if (retry === null || retry === undefined) {\n    retry = {\n      retries: opts.fetchRetries || 2,\n      factor: opts.fetchRetryFactor || 10,\n      maxTimeout: opts.fetchRetryMaxtimeout || 60000,\n      minTimeout: opts.fetchRetryMintimeout || 1000,\n    }\n  }\n  return promiseRetry((retry, number) => {\n    if (number !== 1) {\n      log.silly('git', `Retrying git command: ${\n        args.join(' ')} attempt # ${number}`)\n    }\n\n    return spawn(gitPath, args, makeOpts(opts))\n      .catch(er => {\n        const gitError = makeError(er)\n        if (!gitError.shouldRetry(number)) {\n          throw gitError\n        }\n        retry(gitError)\n      })\n  }, retry)\n}\n","const {\n  GitConnectionError,\n  GitPathspecError,\n  GitUnknownError,\n} = require('./errors.js')\n\nconst connectionErrorRe = new RegExp([\n  'remote error: Internal Server Error',\n  'The remote end hung up unexpectedly',\n  'Connection timed out',\n  'Operation timed out',\n  'Failed to connect to .* Timed out',\n  'Connection reset by peer',\n  'SSL_ERROR_SYSCALL',\n  'The requested URL returned error: 503',\n].join('|'))\n\nconst missingPathspecRe = /pathspec .* did not match any file\\(s\\) known to git/\n\nfunction makeError (er) {\n  const message = er.stderr\n  let gitEr\n  if (connectionErrorRe.test(message)) {\n    gitEr = new GitConnectionError(message)\n  } else if (missingPathspecRe.test(message)) {\n    gitEr = new GitPathspecError(message)\n  } else {\n    gitEr = new GitUnknownError(message)\n  }\n  return Object.assign(gitEr, er)\n}\n\nmodule.exports = makeError\n","\nconst maxRetry = 3\n\nclass GitError extends Error {\n  shouldRetry () {\n    return false\n  }\n}\n\nclass GitConnectionError extends GitError {\n  constructor (message) {\n    super('A git connection error occurred')\n  }\n\n  shouldRetry (number) {\n    return number < maxRetry\n  }\n}\n\nclass GitPathspecError extends GitError {\n  constructor (message) {\n    super('The git reference could not be found')\n  }\n}\n\nclass GitUnknownError extends GitError {\n  constructor (message) {\n    super('An unknown git error occurred')\n  }\n}\n\nmodule.exports = {\n  GitConnectionError,\n  GitPathspecError,\n  GitUnknownError,\n}\n","const which = require('which')\n\nlet gitPath\ntry {\n  gitPath = which.sync('git')\n} catch (e) {}\n\nmodule.exports = (opts = {}) => {\n  if (opts.git) {\n    return opts.git\n  }\n  if (!gitPath || opts.git === false) {\n    return Object.assign(new Error('No git binary found in $PATH'), { code: 'ENOGIT' })\n  }\n  return gitPath\n}\n","// Values we want to set if they're not already defined by the end user\n// This defaults to accepting new ssh host key fingerprints\nconst gitEnv = {\n  GIT_ASKPASS: 'echo',\n  GIT_SSH_COMMAND: 'ssh -oStrictHostKeyChecking=accept-new',\n}\nmodule.exports = (opts = {}) => ({\n  stdioString: true,\n  ...opts,\n  shell: false,\n  env: opts.env || { ...gitEnv, ...process.env },\n})\n","// turn an array of lines from `git ls-remote` into a thing\n// vaguely resembling a packument, where docs are a resolved ref\n\nconst semver = require('semver')\n\nmodule.exports = lines => finish(lines.reduce(linesToRevsReducer, {\n  versions: {},\n  'dist-tags': {},\n  refs: {},\n  shas: {},\n}))\n\nconst finish = revs => distTags(shaList(peelTags(revs)))\n\n// We can check out shallow clones on specific SHAs if we have a ref\nconst shaList = revs => {\n  Object.keys(revs.refs).forEach(ref => {\n    const doc = revs.refs[ref]\n    if (!revs.shas[doc.sha]) {\n      revs.shas[doc.sha] = [ref]\n    } else {\n      revs.shas[doc.sha].push(ref)\n    }\n  })\n  return revs\n}\n\n// Replace any tags with their ^{} counterparts, if those exist\nconst peelTags = revs => {\n  Object.keys(revs.refs).filter(ref => ref.endsWith('^{}')).forEach(ref => {\n    const peeled = revs.refs[ref]\n    const unpeeled = revs.refs[ref.replace(/\\^\\{\\}$/, '')]\n    if (unpeeled) {\n      unpeeled.sha = peeled.sha\n      delete revs.refs[ref]\n    }\n  })\n  return revs\n}\n\nconst distTags = revs => {\n  // not entirely sure what situations would result in an\n  // ichabod repo, but best to be careful in Sleepy Hollow anyway\n  const HEAD = revs.refs.HEAD || /* istanbul ignore next */ {}\n  const versions = Object.keys(revs.versions)\n  versions.forEach(v => {\n    // simulate a dist-tags with latest pointing at the\n    // 'latest' branch if one exists and is a version,\n    // or HEAD if not.\n    const ver = revs.versions[v]\n    if (revs.refs.latest && ver.sha === revs.refs.latest.sha) {\n      revs['dist-tags'].latest = v\n    } else if (ver.sha === HEAD.sha) {\n      revs['dist-tags'].HEAD = v\n      if (!revs.refs.latest) {\n        revs['dist-tags'].latest = v\n      }\n    }\n  })\n  return revs\n}\n\nconst refType = ref => {\n  if (ref.startsWith('refs/tags/')) {\n    return 'tag'\n  }\n  if (ref.startsWith('refs/heads/')) {\n    return 'branch'\n  }\n  if (ref.startsWith('refs/pull/')) {\n    return 'pull'\n  }\n  if (ref === 'HEAD') {\n    return 'head'\n  }\n  // Could be anything, ignore for now\n  /* istanbul ignore next */\n  return 'other'\n}\n\n// return the doc, or null if we should ignore it.\nconst lineToRevDoc = line => {\n  const split = line.trim().split(/\\s+/, 2)\n  if (split.length < 2) {\n    return null\n  }\n\n  const sha = split[0].trim()\n  const rawRef = split[1].trim()\n  const type = refType(rawRef)\n\n  if (type === 'tag') {\n    // refs/tags/foo^{} is the 'peeled tag', ie the commit\n    // that is tagged by refs/tags/foo they resolve to the same\n    // content, just different objects in git's data structure.\n    // But, we care about the thing the tag POINTS to, not the tag\n    // object itself, so we only look at the peeled tag refs, and\n    // ignore the pointer.\n    // For now, though, we have to save both, because some tags\n    // don't have peels, if they were not annotated.\n    const ref = rawRef.substr('refs/tags/'.length)\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'branch') {\n    const ref = rawRef.substr('refs/heads/'.length)\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'pull') {\n    // NB: merged pull requests installable with #pull/123/merge\n    // for the merged pr, or #pull/123 for the PR head\n    const ref = rawRef.substr('refs/'.length).replace(/\\/head$/, '')\n    return { sha, ref, rawRef, type }\n  }\n\n  if (type === 'head') {\n    const ref = 'HEAD'\n    return { sha, ref, rawRef, type }\n  }\n\n  // at this point, all we can do is leave the ref un-munged\n  return { sha, ref: rawRef, rawRef, type }\n}\n\nconst linesToRevsReducer = (revs, line) => {\n  const doc = lineToRevDoc(line)\n\n  if (!doc) {\n    return revs\n  }\n\n  revs.refs[doc.ref] = doc\n  revs.refs[doc.rawRef] = doc\n\n  if (doc.type === 'tag') {\n    // try to pull a semver value out of tags like `release-v1.2.3`\n    // which is a pretty common pattern.\n    const match = !doc.ref.endsWith('^{}') &&\n      doc.ref.match(/v?(\\d+\\.\\d+\\.\\d+(?:[-+].+)?)$/)\n    if (match && semver.valid(match[1], true)) {\n      revs.versions[semver.clean(match[1], true)] = doc\n    }\n  }\n\n  return revs\n}\n","const isWindows = opts => (opts.fakePlatform || process.platform) === 'win32'\n\nexports.isWindows = isWindows\n","// not an airtight indicator, but a good gut-check to even bother trying\nconst { promisify } = require('util')\nconst fs = require('fs')\nconst stat = promisify(fs.stat)\nmodule.exports = ({ cwd = process.cwd() } = {}) =>\n  stat(cwd + '/.git').then(() => true, () => false)\n","const is = require('./is.js')\nconst { dirname } = require('path')\n\nmodule.exports = async ({ cwd = process.cwd() } = {}) => {\n  if (await is({ cwd })) {\n    return cwd\n  }\n  while (cwd !== dirname(cwd)) {\n    cwd = dirname(cwd)\n    if (await is({ cwd })) {\n      return cwd\n    }\n  }\n  return null\n}\n","const spawn = require('./spawn.js')\n\nmodule.exports = (opts = {}) =>\n  spawn(['status', '--porcelain=v1', '-uno'], opts)\n    .then(res => !res.stdout.trim().split(/\\r?\\n+/)\n      .map(l => l.trim()).filter(l => l).length)\n"]}