{"version":3,"sources":["index.js","type-defs.js","umask.js","nerf-dart.js","env-replace.js","parse-field.js","type-description.js","set-envs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AELA,AJYA,AGTA,AFMA,ACHA;AELA,AJYA,AGTA,AFMA,ACHA;AELA,AJYA,AGTA,AFMA,ACHA;AELA,AJYA,AGTA,AENA,AJYA,ACHA;AELA,AJYA,AGTA,AENA,AJYA,ACHA;AELA,AJYA,AGTA,AENA,AJYA,ACHA;AELA,AJYA,AGTA,AENA,AJYA,AKfA,AJYA;AELA,AJYA,AGTA,AENA,AJYA,AKfA,AJYA;AELA,AJYA,AGTA,AENA,AJYA,AKfA,AJYA;AELA,AJYA,AGTA,AENA,AENA,ANkBA,AKfA,AJYA;AELA,AJYA,AGTA,AENA,AENA,ANkBA,AKfA,AJYA;AELA,AJYA,AGTA,AENA,AENA,ANkBA,AKfA,AJYA;AELA,AJYA,AGTA,AENA,AENA,ANkBA,AKfA,AJYA;AELA,AJYA,AGTA,AENA,AENA,ANkBA,AKfA,AJYA;AELA,AJYA,AGTA,AENA,AENA,ANkBA,AKfA,AJYA;AFOA,AGTA,AENA,AENA,ANkBA,AKfA,AJYA;AFOA,AKfA,AENA,ANkBA,AKfA,AJYA;AFOA,AKfA,AENA,ANkBA,AKfA,AJYA;AFOA,AKfA,AENA,ANkBA,AKfA,AJYA;AFOA,AKfA,AENA,ANkBA,AKfA,AJYA;AFOA,AKfA,AENA,ANkBA,AKfA,AJYA;AFOA,AKfA,AENA,ANkBA,AKfA,AJYA;AFOA,AKfA,AENA,ANkBA,AKfA,AJYA;AFOA,AKfA,AENA,ANkBA,AKfA,AJYA;AFOA,AKfA,AENA,ANkBA,AKfA,AJYA;AFOA,AKfA,AENA,ANkBA,AKfA,AJYA;AFOA,AKfA,AENA,ANkBA,AKfA;ANmBA,AKfA,AENA,ANkBA,AKfA;ANmBA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA,ANkBA;ADIA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AKfA,AENA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA,AOrBA;APsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// TODO: set the scope config from package.json or explicit cli config\nconst walkUp = require('walk-up-path')\nconst ini = require('ini')\nconst nopt = require('nopt')\nconst mkdirp = require('mkdirp-infer-owner')\nconst mapWorkspaces = require('@npmcli/map-workspaces')\nconst rpj = require('read-package-json-fast')\nconst log = require('proc-log')\n\n/* istanbul ignore next */\nconst myUid = process.getuid && process.getuid()\n/* istanbul ignore next */\nconst myGid = process.getgid && process.getgid()\n\nconst { resolve, dirname, join } = require('path')\nconst { homedir } = require('os')\nconst { promisify } = require('util')\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst writeFile = promisify(fs.writeFile)\nconst chmod = promisify(fs.chmod)\nconst chown = promisify(fs.chown)\nconst unlink = promisify(fs.unlink)\nconst stat = promisify(fs.stat)\n\nconst hasOwnProperty = (obj, key) =>\n  Object.prototype.hasOwnProperty.call(obj, key)\n\n// define a custom getter, but turn into a normal prop\n// if we set it.  otherwise it can't be set on child objects\nconst settableGetter = (obj, key, get) => {\n  Object.defineProperty(obj, key, {\n    get,\n    set (value) {\n      Object.defineProperty(obj, key, {\n        value,\n        configurable: true,\n        writable: true,\n        enumerable: true,\n      })\n    },\n    configurable: true,\n    enumerable: true,\n  })\n}\n\nconst typeDefs = require('./type-defs.js')\nconst nerfDart = require('./nerf-dart.js')\nconst envReplace = require('./env-replace.js')\nconst parseField = require('./parse-field.js')\nconst typeDescription = require('./type-description.js')\nconst setEnvs = require('./set-envs.js')\n\n// types that can be saved back to\nconst confFileTypes = new Set([\n  'global',\n  'user',\n  'project',\n])\n\nconst confTypes = new Set([\n  'default',\n  'builtin',\n  ...confFileTypes,\n  'env',\n  'cli',\n])\n\nconst _loaded = Symbol('loaded')\nconst _get = Symbol('get')\nconst _find = Symbol('find')\nconst _loadObject = Symbol('loadObject')\nconst _loadFile = Symbol('loadFile')\nconst _checkDeprecated = Symbol('checkDeprecated')\nconst _flatten = Symbol('flatten')\nconst _flatOptions = Symbol('flatOptions')\n\nclass Config {\n  static get typeDefs () {\n    return typeDefs\n  }\n\n  constructor ({\n    definitions,\n    shorthands,\n    flatten,\n    npmPath,\n\n    // options just to override in tests, mostly\n    env = process.env,\n    argv = process.argv,\n    platform = process.platform,\n    execPath = process.execPath,\n    cwd = process.cwd(),\n  }) {\n    // turn the definitions into nopt's weirdo syntax\n    this.definitions = definitions\n    const types = {}\n    const defaults = {}\n    this.deprecated = {}\n    for (const [key, def] of Object.entries(definitions)) {\n      defaults[key] = def.default\n      types[key] = def.type\n      if (def.deprecated) {\n        this.deprecated[key] = def.deprecated.trim().replace(/\\n +/, '\\n')\n      }\n    }\n\n    // populated the first time we flatten the object\n    this[_flatOptions] = null\n    this[_flatten] = flatten\n    this.types = types\n    this.shorthands = shorthands\n    this.defaults = defaults\n\n    this.npmPath = npmPath\n    this.argv = argv\n    this.env = env\n    this.execPath = execPath\n    this.platform = platform\n    this.cwd = cwd\n\n    // set when we load configs\n    this.globalPrefix = null\n    this.localPrefix = null\n\n    // defaults to env.HOME, but will always be *something*\n    this.home = null\n\n    // set up the prototype chain of config objects\n    const wheres = [...confTypes]\n    this.data = new Map()\n    let parent = null\n    for (const where of wheres) {\n      this.data.set(where, parent = new ConfigData(parent))\n    }\n\n    this.data.set = () => {\n      throw new Error('cannot change internal config data structure')\n    }\n    this.data.delete = () => {\n      throw new Error('cannot change internal config data structure')\n    }\n\n    this.sources = new Map([])\n\n    this.list = []\n    for (const { data } of this.data.values()) {\n      this.list.unshift(data)\n    }\n    Object.freeze(this.list)\n\n    this[_loaded] = false\n  }\n\n  get loaded () {\n    return this[_loaded]\n  }\n\n  get prefix () {\n    return this[_get]('global') ? this.globalPrefix : this.localPrefix\n  }\n\n  // return the location where key is found.\n  find (key) {\n    if (!this.loaded) {\n      throw new Error('call config.load() before reading values')\n    }\n    return this[_find](key)\n  }\n\n  [_find] (key) {\n    // have to look in reverse order\n    const entries = [...this.data.entries()]\n    for (let i = entries.length - 1; i > -1; i--) {\n      const [where, { data }] = entries[i]\n      if (hasOwnProperty(data, key)) {\n        return where\n      }\n    }\n    return null\n  }\n\n  get (key, where) {\n    if (!this.loaded) {\n      throw new Error('call config.load() before reading values')\n    }\n    return this[_get](key, where)\n  }\n\n  // we need to get values sometimes, so use this internal one to do so\n  // while in the process of loading.\n  [_get] (key, where = null) {\n    if (where !== null && !confTypes.has(where)) {\n      throw new Error('invalid config location param: ' + where)\n    }\n    const { data } = this.data.get(where || 'cli')\n    return where === null || hasOwnProperty(data, key) ? data[key] : undefined\n  }\n\n  set (key, val, where = 'cli') {\n    if (!this.loaded) {\n      throw new Error('call config.load() before setting values')\n    }\n    if (!confTypes.has(where)) {\n      throw new Error('invalid config location param: ' + where)\n    }\n    this[_checkDeprecated](key)\n    const { data } = this.data.get(where)\n    data[key] = val\n\n    // this is now dirty, the next call to this.valid will have to check it\n    this.data.get(where)[_valid] = null\n\n    // the flat options are invalidated, regenerate next time they're needed\n    this[_flatOptions] = null\n  }\n\n  get flat () {\n    if (this[_flatOptions]) {\n      return this[_flatOptions]\n    }\n\n    // create the object for flat options passed to deps\n    process.emit('time', 'config:load:flatten')\n    this[_flatOptions] = {}\n    // walk from least priority to highest\n    for (const { data } of this.data.values()) {\n      this[_flatten](data, this[_flatOptions])\n    }\n    process.emit('timeEnd', 'config:load:flatten')\n\n    return this[_flatOptions]\n  }\n\n  delete (key, where = 'cli') {\n    if (!this.loaded) {\n      throw new Error('call config.load() before deleting values')\n    }\n    if (!confTypes.has(where)) {\n      throw new Error('invalid config location param: ' + where)\n    }\n    delete this.data.get(where).data[key]\n  }\n\n  async load () {\n    if (this.loaded) {\n      throw new Error('attempting to load npm config multiple times')\n    }\n\n    process.emit('time', 'config:load')\n    // first load the defaults, which sets the global prefix\n    process.emit('time', 'config:load:defaults')\n    this.loadDefaults()\n    process.emit('timeEnd', 'config:load:defaults')\n\n    // next load the builtin config, as this sets new effective defaults\n    process.emit('time', 'config:load:builtin')\n    await this.loadBuiltinConfig()\n    process.emit('timeEnd', 'config:load:builtin')\n\n    // cli and env are not async, and can set the prefix, relevant to project\n    process.emit('time', 'config:load:cli')\n    this.loadCLI()\n    process.emit('timeEnd', 'config:load:cli')\n    process.emit('time', 'config:load:env')\n    this.loadEnv()\n    process.emit('timeEnd', 'config:load:env')\n\n    // next project config, which can affect userconfig location\n    process.emit('time', 'config:load:project')\n    await this.loadProjectConfig()\n    process.emit('timeEnd', 'config:load:project')\n    // then user config, which can affect globalconfig location\n    process.emit('time', 'config:load:user')\n    await this.loadUserConfig()\n    process.emit('timeEnd', 'config:load:user')\n    // last but not least, global config file\n    process.emit('time', 'config:load:global')\n    await this.loadGlobalConfig()\n    process.emit('timeEnd', 'config:load:global')\n\n    // warn if anything is not valid\n    process.emit('time', 'config:load:validate')\n    this.validate()\n    process.emit('timeEnd', 'config:load:validate')\n\n    // set this before calling setEnvs, so that we don't have to share\n    // symbols, as that module also does a bunch of get operations\n    this[_loaded] = true\n\n    process.emit('time', 'config:load:credentials')\n    const reg = this.get('registry')\n    const creds = this.getCredentialsByURI(reg)\n    // ignore this error because a failed set will strip out anything that\n    // might be a security hazard, which was the intention.\n    try {\n      this.setCredentialsByURI(reg, creds)\n    } catch (_) {}\n    process.emit('timeEnd', 'config:load:credentials')\n\n    // set proper globalPrefix now that everything is loaded\n    this.globalPrefix = this.get('prefix')\n\n    process.emit('time', 'config:load:setEnvs')\n    this.setEnvs()\n    process.emit('timeEnd', 'config:load:setEnvs')\n\n    process.emit('timeEnd', 'config:load')\n  }\n\n  loadDefaults () {\n    this.loadGlobalPrefix()\n    this.loadHome()\n\n    this[_loadObject]({\n      ...this.defaults,\n      prefix: this.globalPrefix,\n    }, 'default', 'default values')\n\n    const { data } = this.data.get('default')\n\n    // the metrics-registry defaults to the current resolved value of\n    // the registry, unless overridden somewhere else.\n    settableGetter(data, 'metrics-registry', () => this[_get]('registry'))\n\n    // if the prefix is set on cli, env, or userconfig, then we need to\n    // default the globalconfig file to that location, instead of the default\n    // global prefix.  It's weird that `npm get globalconfig --prefix=/foo`\n    // returns `/foo/etc/npmrc`, but better to not change it at this point.\n    settableGetter(data, 'globalconfig', () =>\n      resolve(this[_get]('prefix'), 'etc/npmrc'))\n  }\n\n  loadHome () {\n    if (this.env.HOME) {\n      return this.home = this.env.HOME\n    }\n    this.home = homedir()\n  }\n\n  loadGlobalPrefix () {\n    if (this.globalPrefix) {\n      throw new Error('cannot load default global prefix more than once')\n    }\n\n    if (this.env.PREFIX) {\n      this.globalPrefix = this.env.PREFIX\n    } else if (this.platform === 'win32') {\n    // c:\\node\\node.exe --> prefix=c:\\node\\\n      this.globalPrefix = dirname(this.execPath)\n    } else {\n      // /usr/local/bin/node --> prefix=/usr/local\n      this.globalPrefix = dirname(dirname(this.execPath))\n\n      // destdir only is respected on Unix\n      if (this.env.DESTDIR) {\n        this.globalPrefix = join(this.env.DESTDIR, this.globalPrefix)\n      }\n    }\n  }\n\n  loadEnv () {\n    const conf = Object.create(null)\n    for (const [envKey, envVal] of Object.entries(this.env)) {\n      if (!/^npm_config_/i.test(envKey) || envVal === '') {\n        continue\n      }\n      const key = envKey.substr('npm_config_'.length)\n        .replace(/(?!^)_/g, '-') // don't replace _ at the start of the key\n        .toLowerCase()\n      conf[key] = envVal\n    }\n    this[_loadObject](conf, 'env', 'environment')\n  }\n\n  loadCLI () {\n    nopt.invalidHandler = (k, val, type) =>\n      this.invalidHandler(k, val, type, 'command line options', 'cli')\n    const conf = nopt(this.types, this.shorthands, this.argv)\n    nopt.invalidHandler = null\n    this.parsedArgv = conf.argv\n    delete conf.argv\n    this[_loadObject](conf, 'cli', 'command line options')\n  }\n\n  get valid () {\n    for (const [where, { valid }] of this.data.entries()) {\n      if (valid === false || valid === null && !this.validate(where)) {\n        return false\n      }\n    }\n    return true\n  }\n\n  validate (where) {\n    if (!where) {\n      let valid = true\n      for (const [where] of this.data.entries()) {\n        // no need to validate our defaults, we know they're fine\n        // cli was already validated when parsed the first time\n        if (where === 'default' || where === 'builtin' || where === 'cli') {\n          continue\n        }\n        const ret = this.validate(where)\n        valid = valid && ret\n      }\n      return valid\n    } else {\n      const obj = this.data.get(where)\n      obj[_valid] = true\n\n      nopt.invalidHandler = (k, val, type) =>\n        this.invalidHandler(k, val, type, obj.source, where)\n\n      nopt.clean(obj.data, this.types, this.typeDefs)\n\n      nopt.invalidHandler = null\n      return obj[_valid]\n    }\n  }\n\n  // Returns true if the value is coming directly from the source defined\n  // in default definitions, if the current value for the key config is\n  // coming from any other different source, returns false\n  isDefault (key) {\n    const [defaultType, ...types] = [...confTypes]\n    const defaultData = this.data.get(defaultType).data\n\n    return hasOwnProperty(defaultData, key)\n      && types.every(type => {\n        const typeData = this.data.get(type).data\n        return !hasOwnProperty(typeData, key)\n      })\n  }\n\n  invalidHandler (k, val, type, source, where) {\n    log.warn(\n      'invalid config',\n      k + '=' + JSON.stringify(val),\n      `set in ${source}`\n    )\n    this.data.get(where)[_valid] = false\n\n    if (Array.isArray(type)) {\n      if (type.includes(typeDefs.url.type)) {\n        type = typeDefs.url.type\n      } else {\n        /* istanbul ignore if - no actual configs matching this, but\n         * path types SHOULD be handled this way, like URLs, for the\n         * same reason */\n        if (type.includes(typeDefs.path.type)) {\n          type = typeDefs.path.type\n        }\n      }\n    }\n\n    const typeDesc = typeDescription(type)\n    const oneOrMore = typeDesc.indexOf(Array) !== -1\n    const mustBe = typeDesc\n      .filter(m => m !== undefined && m !== Array)\n    const oneOf = mustBe.length === 1 && oneOrMore ? ' one or more'\n      : mustBe.length > 1 && oneOrMore ? ' one or more of:'\n      : mustBe.length > 1 ? ' one of:'\n      : ''\n    const msg = 'Must be' + oneOf\n    const desc = mustBe.length === 1 ? mustBe[0]\n      : mustBe.filter(m => m !== Array)\n        .map(n => typeof n === 'string' ? n : JSON.stringify(n))\n        .join(', ')\n    log.warn('invalid config', msg, desc)\n  }\n\n  [_loadObject] (obj, where, source, er = null) {\n    const conf = this.data.get(where)\n    if (conf.source) {\n      const m = `double-loading \"${where}\" configs from ${source}, ` +\n        `previously loaded from ${conf.source}`\n      throw new Error(m)\n    }\n\n    if (this.sources.has(source)) {\n      const m = `double-loading config \"${source}\" as \"${where}\", ` +\n        `previously loaded as \"${this.sources.get(source)}\"`\n      throw new Error(m)\n    }\n\n    conf.source = source\n    this.sources.set(source, where)\n    if (er) {\n      conf.loadError = er\n      if (er.code !== 'ENOENT') {\n        log.verbose('config', `error loading ${where} config`, er)\n      }\n    } else {\n      conf.raw = obj\n      for (const [key, value] of Object.entries(obj)) {\n        const k = envReplace(key, this.env)\n        const v = this.parseField(value, k)\n        if (where !== 'default') {\n          this[_checkDeprecated](k, where, obj, [key, value])\n        }\n        conf.data[k] = v\n      }\n    }\n  }\n\n  [_checkDeprecated] (key, where, obj, kv) {\n    // XXX a future npm version will make this a warning.\n    // An even more future npm version will make this an error.\n    if (this.deprecated[key]) {\n      log.verbose('config', key, this.deprecated[key])\n    }\n  }\n\n  // Parse a field, coercing it to the best type available.\n  parseField (f, key, listElement = false) {\n    return parseField(f, key, this, listElement)\n  }\n\n  async [_loadFile] (file, type) {\n    process.emit('time', 'config:load:file:' + file)\n    // only catch the error from readFile, not from the loadObject call\n    await readFile(file, 'utf8').then(\n      data => this[_loadObject](ini.parse(data), type, file),\n      er => this[_loadObject](null, type, file, er)\n    )\n    process.emit('timeEnd', 'config:load:file:' + file)\n  }\n\n  loadBuiltinConfig () {\n    return this[_loadFile](resolve(this.npmPath, 'npmrc'), 'builtin')\n  }\n\n  async loadProjectConfig () {\n    // the localPrefix can be set by the CLI config, but otherwise is\n    // found by walking up the folder tree. either way, we load it before\n    // we return to make sure localPrefix is set\n    await this.loadLocalPrefix()\n\n    if (this[_get]('global') === true || this[_get]('location') === 'global') {\n      this.data.get('project').source = '(global mode enabled, ignored)'\n      this.sources.set(this.data.get('project').source, 'project')\n      return\n    }\n\n    const projectFile = resolve(this.localPrefix, '.npmrc')\n    // if we're in the ~ directory, and there happens to be a node_modules\n    // folder (which is not TOO uncommon, it turns out), then we can end\n    // up loading the \"project\" config where the \"userconfig\" will be,\n    // which causes some calamaties.  So, we only load project config if\n    // it doesn't match what the userconfig will be.\n    if (projectFile !== this[_get]('userconfig')) {\n      return this[_loadFile](projectFile, 'project')\n    } else {\n      this.data.get('project').source = '(same as \"user\" config, ignored)'\n      this.sources.set(this.data.get('project').source, 'project')\n    }\n  }\n\n  async loadLocalPrefix () {\n    const cliPrefix = this[_get]('prefix', 'cli')\n    if (cliPrefix) {\n      this.localPrefix = cliPrefix\n      return\n    }\n\n    const cliWorkspaces = this[_get]('workspaces', 'cli')\n    const isGlobal = this[_get]('global') || this[_get]('location') === 'global'\n\n    for (const p of walkUp(this.cwd)) {\n      const hasNodeModules = await stat(resolve(p, 'node_modules'))\n        .then((st) => st.isDirectory())\n        .catch(() => false)\n\n      const hasPackageJson = await stat(resolve(p, 'package.json'))\n        .then((st) => st.isFile())\n        .catch(() => false)\n\n      if (!this.localPrefix && (hasNodeModules || hasPackageJson)) {\n        this.localPrefix = p\n\n        // if workspaces are disabled, or we're in global mode, return now\n        if (cliWorkspaces === false || isGlobal) {\n          return\n        }\n\n        // otherwise, continue the loop\n        continue\n      }\n\n      if (this.localPrefix && hasPackageJson) {\n        // if we already set localPrefix but this dir has a package.json\n        // then we need to see if `p` is a workspace root by reading its package.json\n        // however, if reading it fails then we should just move on\n        const pkg = await rpj(resolve(p, 'package.json')).catch(() => false)\n        if (!pkg) {\n          continue\n        }\n\n        const workspaces = await mapWorkspaces({ cwd: p, pkg })\n        for (const w of workspaces.values()) {\n          if (w === this.localPrefix) {\n            // see if there's a .npmrc file in the workspace, if so log a warning\n            const hasNpmrc = await stat(resolve(this.localPrefix, '.npmrc'))\n              .then((st) => st.isFile())\n              .catch(() => false)\n\n            if (hasNpmrc) {\n              log.warn(`ignoring workspace config at ${this.localPrefix}/.npmrc`)\n            }\n\n            // set the workspace in the default layer, which allows it to be overridden easily\n            const { data } = this.data.get('default')\n            data.workspace = [this.localPrefix]\n            this.localPrefix = p\n            log.info(`found workspace root at ${this.localPrefix}`)\n            // we found a root, so we return now\n            return\n          }\n        }\n      }\n    }\n\n    if (!this.localPrefix) {\n      this.localPrefix = this.cwd\n    }\n  }\n\n  loadUserConfig () {\n    return this[_loadFile](this[_get]('userconfig'), 'user')\n  }\n\n  loadGlobalConfig () {\n    return this[_loadFile](this[_get]('globalconfig'), 'global')\n  }\n\n  async save (where) {\n    if (!this.loaded) {\n      throw new Error('call config.load() before saving')\n    }\n    if (!confFileTypes.has(where)) {\n      throw new Error('invalid config location param: ' + where)\n    }\n    const conf = this.data.get(where)\n    conf[_raw] = { ...conf.data }\n    conf[_loadError] = null\n\n    // upgrade auth configs to more secure variants before saving\n    if (where === 'user') {\n      const reg = this.get('registry')\n      const creds = this.getCredentialsByURI(reg)\n      // we ignore this error because the failed set already removed\n      // anything that might be a security hazard, and it won't be\n      // saved back to the .npmrc file, so we're good.\n      try {\n        this.setCredentialsByURI(reg, creds)\n      } catch (_) {}\n    }\n\n    const iniData = ini.stringify(conf.data).trim() + '\\n'\n    if (!iniData.trim()) {\n      // ignore the unlink error (eg, if file doesn't exist)\n      await unlink(conf.source).catch(er => {})\n      return\n    }\n    const dir = dirname(conf.source)\n    await mkdirp(dir)\n    await writeFile(conf.source, iniData, 'utf8')\n    // don't leave a root-owned config file lying around\n    /* istanbul ignore if - this is best-effort and a pita to test */\n    if (myUid === 0) {\n      const st = await stat(dir).catch(() => null)\n      if (st && (st.uid !== myUid || st.gid !== myGid)) {\n        await chown(conf.source, st.uid, st.gid).catch(() => {})\n      }\n    }\n    const mode = where === 'user' ? 0o600 : 0o666\n    await chmod(conf.source, mode)\n  }\n\n  clearCredentialsByURI (uri) {\n    const nerfed = nerfDart(uri)\n    const def = nerfDart(this.get('registry'))\n    if (def === nerfed) {\n      // do not delete email, that shouldn't be nerfed any more.\n      // just delete the nerfed copy, if one exists.\n      this.delete(`-authtoken`, 'user')\n      this.delete(`_authToken`, 'user')\n      this.delete(`_authtoken`, 'user')\n      this.delete(`_auth`, 'user')\n      this.delete(`_password`, 'user')\n      this.delete(`username`, 'user')\n    }\n    this.delete(`${nerfed}:-authtoken`, 'user')\n    this.delete(`${nerfed}:_authtoken`, 'user')\n    this.delete(`${nerfed}:_authToken`, 'user')\n    this.delete(`${nerfed}:_auth`, 'user')\n    this.delete(`${nerfed}:_password`, 'user')\n    this.delete(`${nerfed}:username`, 'user')\n    this.delete(`${nerfed}:email`, 'user')\n  }\n\n  setCredentialsByURI (uri, { token, username, password, email }) {\n    const nerfed = nerfDart(uri)\n    const def = nerfDart(this.get('registry'))\n\n    if (def === nerfed) {\n      // remove old style auth info not limited to a single registry\n      this.delete('_password', 'user')\n      this.delete('username', 'user')\n      this.delete('_auth', 'user')\n      this.delete('_authtoken', 'user')\n      this.delete('-authtoken', 'user')\n      this.delete('_authToken', 'user')\n    }\n\n    // email used to be nerfed always.  if we're using the default\n    // registry, de-nerf it.\n    if (nerfed === def) {\n      email = email ||\n        this.get('email', 'user') ||\n        this.get(`${nerfed}:email`, 'user')\n      if (email) {\n        this.set('email', email, 'user')\n      }\n    }\n\n    // field that hasn't been used as documented for a LONG time,\n    // and as of npm 7.10.0, isn't used at all.  We just always\n    // send auth if we have it, only to the URIs under the nerf dart.\n    this.delete(`${nerfed}:always-auth`, 'user')\n\n    this.delete(`${nerfed}:-authtoken`, 'user')\n    this.delete(`${nerfed}:_authtoken`, 'user')\n    this.delete(`${nerfed}:email`, 'user')\n    if (token) {\n      this.set(`${nerfed}:_authToken`, token, 'user')\n      this.delete(`${nerfed}:_password`, 'user')\n      this.delete(`${nerfed}:username`, 'user')\n    } else if (username || password) {\n      if (!username) {\n        throw new Error('must include username')\n      }\n      if (!password) {\n        throw new Error('must include password')\n      }\n      this.delete(`${nerfed}:_authToken`, 'user')\n      this.set(`${nerfed}:username`, username, 'user')\n      // note: not encrypted, no idea why we bothered to do this, but oh well\n      // protects against shoulder-hacks if password is memorable, I guess?\n      const encoded = Buffer.from(password, 'utf8').toString('base64')\n      this.set(`${nerfed}:_password`, encoded, 'user')\n    } else {\n      throw new Error('No credentials to set.')\n    }\n  }\n\n  // this has to be a bit more complicated to support legacy data of all forms\n  getCredentialsByURI (uri) {\n    const nerfed = nerfDart(uri)\n    const creds = {}\n\n    const email = this.get(`${nerfed}:email`) || this.get('email')\n    if (email) {\n      creds.email = email\n    }\n\n    const tokenReg = this.get(`${nerfed}:_authToken`) ||\n      this.get(`${nerfed}:_authtoken`) ||\n      this.get(`${nerfed}:-authtoken`) ||\n      nerfed === nerfDart(this.get('registry')) && this.get('_authToken')\n\n    if (tokenReg) {\n      creds.token = tokenReg\n      return creds\n    }\n\n    const userReg = this.get(`${nerfed}:username`)\n    const passReg = this.get(`${nerfed}:_password`)\n    if (userReg && passReg) {\n      creds.username = userReg\n      creds.password = Buffer.from(passReg, 'base64').toString('utf8')\n      const auth = `${creds.username}:${creds.password}`\n      creds.auth = Buffer.from(auth, 'utf8').toString('base64')\n      return creds\n    }\n\n    const authReg = this.get(`${nerfed}:_auth`)\n    if (authReg) {\n      const authDecode = Buffer.from(authReg, 'base64').toString('utf8')\n      const authSplit = authDecode.split(':')\n      creds.username = authSplit.shift()\n      creds.password = authSplit.join(':')\n      creds.auth = authReg\n      return creds\n    }\n\n    // at this point, we can only use the values if the URI is the\n    // default registry.\n    const defaultNerf = nerfDart(this.get('registry'))\n    if (nerfed !== defaultNerf) {\n      return creds\n    }\n\n    const userDef = this.get('username')\n    const passDef = this.get('_password')\n    if (userDef && passDef) {\n      creds.username = userDef\n      creds.password = Buffer.from(passDef, 'base64').toString('utf8')\n      const auth = `${creds.username}:${creds.password}`\n      creds.auth = Buffer.from(auth, 'utf8').toString('base64')\n      return creds\n    }\n\n    // Handle the old-style _auth=<base64> style for the default\n    // registry, if set.\n    const auth = this.get('_auth')\n    if (!auth) {\n      return creds\n    }\n\n    const authDecode = Buffer.from(auth, 'base64').toString('utf8')\n    const authSplit = authDecode.split(':')\n    creds.username = authSplit.shift()\n    creds.password = authSplit.join(':')\n    creds.auth = auth\n    return creds\n  }\n\n  // set up the environment object we have with npm_config_* environs\n  // for all configs that are different from their default values, and\n  // set EDITOR and HOME.\n  setEnvs () {\n    setEnvs(this)\n  }\n}\n\nconst _data = Symbol('data')\nconst _raw = Symbol('raw')\nconst _loadError = Symbol('loadError')\nconst _source = Symbol('source')\nconst _valid = Symbol('valid')\nclass ConfigData {\n  constructor (parent) {\n    this[_data] = Object.create(parent && parent.data)\n    this[_source] = null\n    this[_loadError] = null\n    this[_raw] = null\n    this[_valid] = true\n  }\n\n  get data () {\n    return this[_data]\n  }\n\n  get valid () {\n    return this[_valid]\n  }\n\n  set source (s) {\n    if (this[_source]) {\n      throw new Error('cannot set ConfigData source more than once')\n    }\n    this[_source] = s\n  }\n\n  get source () {\n    return this[_source]\n  }\n\n  set loadError (e) {\n    if (this[_loadError] || this[_raw]) {\n      throw new Error('cannot set ConfigData loadError after load')\n    }\n    this[_loadError] = e\n  }\n\n  get loadError () {\n    return this[_loadError]\n  }\n\n  set raw (r) {\n    if (this[_raw] || this[_loadError]) {\n      throw new Error('cannot set ConfigData raw after load')\n    }\n    this[_raw] = r\n  }\n\n  get raw () {\n    return this[_raw]\n  }\n}\n\nmodule.exports = Config\n","const nopt = require('nopt')\n\nconst { Umask, validate: validateUmask } = require('./umask.js')\n\nconst semver = require('semver')\nconst validateSemver = (data, k, val) => {\n  const valid = semver.valid(val)\n  if (!valid) {\n    return false\n  }\n  data[k] = valid\n}\n\nconst noptValidatePath = nopt.typeDefs.path.validate\nconst validatePath = (data, k, val) => {\n  if (typeof val !== 'string') {\n    return false\n  }\n  return noptValidatePath(data, k, val)\n}\n\n// add descriptions so we can validate more usefully\nmodule.exports = {\n  ...nopt.typeDefs,\n  semver: {\n    type: semver,\n    validate: validateSemver,\n    description: 'full valid SemVer string',\n  },\n  Umask: {\n    type: Umask,\n    validate: validateUmask,\n    description: 'octal number in range 0o000..0o777 (0..511)',\n  },\n  url: {\n    ...nopt.typeDefs.url,\n    description: 'full url with \"http://\"',\n  },\n  path: {\n    ...nopt.typeDefs.path,\n    validate: validatePath,\n    description: 'valid filesystem path',\n  },\n  Number: {\n    ...nopt.typeDefs.Number,\n    description: 'numeric value',\n  },\n  Boolean: {\n    ...nopt.typeDefs.Boolean,\n    description: 'boolean value (true or false)',\n  },\n  Date: {\n    ...nopt.typeDefs.Date,\n    description: 'valid Date string',\n  },\n}\n\n// TODO: make nopt less of a global beast so this kludge isn't necessary\nnopt.typeDefs = module.exports\n","class Umask {}\nconst parse = val => {\n  if (typeof val === 'string') {\n    if (/^0o?[0-7]+$/.test(val)) {\n      return parseInt(val.replace(/^0o?/, ''), 8)\n    } else if (/^[1-9][0-9]*$/.test(val)) {\n      return parseInt(val, 10)\n    } else {\n      throw new Error(`invalid umask value: ${val}`)\n    }\n  }\n  if (typeof val !== 'number') {\n    throw new Error(`invalid umask value: ${val}`)\n  }\n  val = Math.floor(val)\n  if (val < 0 || val > 511) {\n    throw new Error(`invalid umask value: ${val}`)\n  }\n  return val\n}\n\nconst validate = (data, k, val) => {\n  try {\n    data[k] = parse(val)\n    return true\n  } catch (er) {\n    return false\n  }\n}\n\nmodule.exports = { Umask, parse, validate }\n","const { URL } = require('url')\n\n/**\n * Maps a URL to an identifier.\n *\n * Name courtesy schiffertronix media LLC, a New Jersey corporation\n *\n * @param {String} uri The URL to be nerfed.\n *\n * @returns {String} A nerfed URL.\n */\nmodule.exports = (url) => {\n  const parsed = new URL(url)\n  const from = `${parsed.protocol}//${parsed.host}${parsed.pathname}`\n  const rel = new URL('.', from)\n  const res = `//${rel.host}${rel.pathname}`\n  return res\n}\n","// replace any ${ENV} values with the appropriate environ.\n\nconst envExpr = /(?<!\\\\)(\\\\*)\\$\\{([^${}]+)\\}/g\n\nmodule.exports = (f, env) => f.replace(envExpr, (orig, esc, name) => {\n  const val = env[name] !== undefined ? env[name] : `$\\{${name}}`\n\n  // consume the escape chars that are relevant.\n  if (esc.length % 2) {\n    return orig.substr((esc.length + 1) / 2)\n  }\n\n  return (esc.substr(esc.length / 2)) + val\n})\n","// Parse a field, coercing it to the best type available.\nconst typeDefs = require('./type-defs.js')\nconst envReplace = require('./env-replace.js')\nconst { resolve } = require('path')\n\nconst { parse: umaskParse } = require('./umask.js')\n\nconst parseField = (f, key, opts, listElement = false) => {\n  if (typeof f !== 'string' && !Array.isArray(f)) {\n    return f\n  }\n\n  const { platform, types, home, env } = opts\n\n  // type can be array or a single thing.  coerce to array.\n  const typeList = new Set([].concat(types[key]))\n  const isPath = typeList.has(typeDefs.path.type)\n  const isBool = typeList.has(typeDefs.Boolean.type)\n  const isString = isPath || typeList.has(typeDefs.String.type)\n  const isUmask = typeList.has(typeDefs.Umask.type)\n  const isNumber = typeList.has(typeDefs.Number.type)\n  const isList = !listElement && typeList.has(Array)\n\n  if (Array.isArray(f)) {\n    return !isList ? f : f.map(field => parseField(field, key, opts, true))\n  }\n\n  // now we know it's a string\n  f = f.trim()\n\n  // list types get put in the environment separated by double-\\n\n  // usually a single \\n would suffice, but ca/cert configs can contain\n  // line breaks and multiple entries.\n  if (isList) {\n    return parseField(f.split('\\n\\n'), key, opts)\n  }\n\n  // --foo is like --foo=true for boolean types\n  if (isBool && !isString && f === '') {\n    return true\n  }\n\n  // string types can be the string 'true', 'false', etc.\n  // otherwise, parse these values out\n  if (!isString && !isPath && !isNumber) {\n    switch (f) {\n      case 'true': return true\n      case 'false': return false\n      case 'null': return null\n      case 'undefined': return undefined\n    }\n  }\n\n  f = envReplace(f, env)\n\n  if (isPath) {\n    const homePattern = platform === 'win32' ? /^~(\\/|\\\\)/ : /^~\\//\n    if (homePattern.test(f) && home) {\n      f = resolve(home, f.substr(2))\n    } else {\n      f = resolve(f)\n    }\n  }\n\n  if (isUmask) {\n    try {\n      return umaskParse(f)\n    } catch (er) {\n      // let it warn later when we validate\n      return f\n    }\n  }\n\n  if (isNumber && !isNaN(f)) {\n    f = +f\n  }\n\n  return f\n}\n\nmodule.exports = parseField\n","// return the description of the valid values of a field\n// returns a string for one thing, or an array of descriptions\nconst typeDefs = require('./type-defs.js')\nconst typeDescription = t => {\n  if (!t || typeof t !== 'function' && typeof t !== 'object') {\n    return t\n  }\n\n  if (Array.isArray(t)) {\n    return t.map(t => typeDescription(t))\n  }\n\n  for (const { type, description } of Object.values(typeDefs)) {\n    if (type === t) {\n      return description || type\n    }\n  }\n\n  return t\n}\nmodule.exports = t => [].concat(typeDescription(t)).filter(t => t !== undefined)\n","// Set environment variables for any non-default configs,\n// so that they're already there when we run lifecycle scripts.\n//\n// See https://github.com/npm/rfcs/pull/90\n\n// Return the env key if this is a thing that belongs in the env.\n// Ie, if the key isn't a @scope, //nerf.dart, or _private,\n// and the value is a string or array.  Otherwise return false.\nconst envKey = (key, val) => {\n  return !/^[/@_]/.test(key) &&\n    (typeof envVal(val) === 'string') &&\n      `npm_config_${key.replace(/-/g, '_').toLowerCase()}`\n}\n\nconst envVal = val => Array.isArray(val) ? val.map(v => envVal(v)).join('\\n\\n')\n  : val === null || val === undefined || val === false ? ''\n  : typeof val === 'object' ? null\n  : String(val)\n\nconst sameConfigValue = (def, val) =>\n  !Array.isArray(val) || !Array.isArray(def) ? def === val\n  : sameArrayValue(def, val)\n\nconst sameArrayValue = (def, val) => {\n  if (def.length !== val.length) {\n    return false\n  }\n\n  for (let i = 0; i < def.length; i++) {\n    /* istanbul ignore next - there are no array configs where the default\n     * is not an empty array, so this loop is a no-op, but it's the correct\n     * thing to do if we ever DO add a config like that. */\n    if (def[i] !== val[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nconst setEnv = (env, rawKey, rawVal) => {\n  const val = envVal(rawVal)\n  const key = envKey(rawKey, val)\n  if (key && val !== null) {\n    env[key] = val\n  }\n}\n\nconst setEnvs = (config) => {\n  // This ensures that all npm config values that are not the defaults are\n  // shared appropriately with child processes, without false positives.\n  const {\n    env,\n    defaults,\n    definitions,\n    list: [cliConf, envConf],\n  } = config\n\n  env.INIT_CWD = process.cwd()\n\n  // if the key is deprecated, skip it always.\n  // if the key is the default value,\n  //   if the environ is NOT the default value,\n  //     set the environ\n  //   else skip it, it's fine\n  // if the key is NOT the default value,\n  //   if the env is setting it, then leave it (already set)\n  //   otherwise, set the env\n  const cliSet = new Set(Object.keys(cliConf))\n  const envSet = new Set(Object.keys(envConf))\n  for (const key in cliConf) {\n    const { deprecated, envExport = true } = definitions[key] || {}\n    if (deprecated || envExport === false) {\n      continue\n    }\n\n    if (sameConfigValue(defaults[key], cliConf[key])) {\n      // config is the default, if the env thought different, then we\n      // have to set it BACK to the default in the environment.\n      if (!sameConfigValue(envConf[key], cliConf[key])) {\n        setEnv(env, key, cliConf[key])\n      }\n    } else {\n      // config is not the default.  if the env wasn't the one to set\n      // it that way, then we have to put it in the env\n      if (!(envSet.has(key) && !cliSet.has(key))) {\n        setEnv(env, key, cliConf[key])\n      }\n    }\n  }\n\n  // also set some other common nice envs that we want to rely on\n  env.HOME = config.home\n  env.npm_config_global_prefix = config.globalPrefix\n  env.npm_config_local_prefix = config.localPrefix\n  if (cliConf.editor) {\n    env.EDITOR = cliConf.editor\n  }\n\n  // note: this doesn't afect the *current* node process, of course, since\n  // it's already started, but it does affect the options passed to scripts.\n  if (cliConf['node-options']) {\n    env.NODE_OPTIONS = cliConf['node-options']\n  }\n\n  if (require.main && require.main.filename) {\n    env.npm_execpath = require.main.filename\n  }\n  env.NODE = env.npm_node_execpath = config.execPath\n}\n\nmodule.exports = setEnvs\n"]}