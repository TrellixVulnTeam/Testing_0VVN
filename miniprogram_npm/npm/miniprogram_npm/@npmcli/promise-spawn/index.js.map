{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const {spawn} = require('child_process')\n\nconst inferOwner = require('infer-owner')\n\nconst isPipe = (stdio = 'pipe', fd) =>\n  stdio === 'pipe' || stdio === null ? true\n  : Array.isArray(stdio) ? isPipe(stdio[fd], fd)\n  : false\n\n// 'extra' object is for decorating the error a bit more\nconst promiseSpawn = (cmd, args, opts, extra = {}) => {\n  const cwd = opts.cwd || process.cwd()\n  const isRoot = process.getuid && process.getuid() === 0\n  const { uid, gid } = isRoot ? inferOwner.sync(cwd) : {}\n  return promiseSpawnUid(cmd, args, {\n    ...opts,\n    cwd,\n    uid,\n    gid\n  }, extra)\n}\n\nconst stdioResult = (stdout, stderr, {stdioString, stdio}) =>\n  stdioString ? {\n    stdout: isPipe(stdio, 1) ? Buffer.concat(stdout).toString() : null,\n    stderr: isPipe(stdio, 2) ? Buffer.concat(stderr).toString() : null,\n  }\n  : {\n    stdout: isPipe(stdio, 1) ? Buffer.concat(stdout) : null,\n    stderr: isPipe(stdio, 2) ? Buffer.concat(stderr) : null,\n  }\n\nconst promiseSpawnUid = (cmd, args, opts, extra) => {\n  let proc\n  const p = new Promise((res, rej) => {\n    proc = spawn(cmd, args, opts)\n    const stdout = []\n    const stderr = []\n    const reject = er => rej(Object.assign(er, {\n      cmd,\n      args,\n      ...stdioResult(stdout, stderr, opts),\n      ...extra,\n    }))\n    proc.on('error', reject)\n    if (proc.stdout) {\n      proc.stdout.on('data', c => stdout.push(c)).on('error', reject)\n      proc.stdout.on('error', er => reject(er))\n    }\n    if (proc.stderr) {\n      proc.stderr.on('data', c => stderr.push(c)).on('error', reject)\n      proc.stderr.on('error', er => reject(er))\n    }\n    proc.on('close', (code, signal) => {\n      const result = {\n        cmd,\n        args,\n        code,\n        signal,\n        ...stdioResult(stdout, stderr, opts),\n        ...extra\n      }\n      if (code || signal)\n        rej(Object.assign(new Error('command failed'), result))\n      else\n        res(result)\n    })\n  })\n\n  p.stdin = proc.stdin\n  p.process = proc\n  return p\n}\n\nmodule.exports = promiseSpawn\n"]}