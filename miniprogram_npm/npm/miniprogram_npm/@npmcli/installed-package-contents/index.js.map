{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// to GET CONTENTS for folder at PATH (which may be a PACKAGE):\n// - if PACKAGE, read path/package.json\n//   - if bins in ../node_modules/.bin, add those to result\n// - if depth >= maxDepth, add PATH to result, and finish\n// - readdir(PATH, with file types)\n// - add all FILEs in PATH to result\n// - if PARENT:\n//   - if depth < maxDepth, add GET CONTENTS of all DIRs in PATH\n//   - else, add all DIRs in PATH\n// - if no parent\n//   - if no bundled deps,\n//     - if depth < maxDepth, add GET CONTENTS of DIRs in path except\n//       node_modules\n//     - else, add all DIRs in path other than node_modules\n//   - if has bundled deps,\n//     - get list of bundled deps\n//     - add GET CONTENTS of bundled deps, PACKAGE=true, depth + 1\n\nconst bundled = require('npm-bundled')\nconst {promisify} = require('util')\nconst fs = require('fs')\nconst readFile = promisify(fs.readFile)\nconst readdir = promisify(fs.readdir)\nconst stat = promisify(fs.stat)\nconst lstat = promisify(fs.lstat)\nconst {relative, resolve, basename, dirname} = require('path')\nconst normalizePackageBin = require('npm-normalize-package-bin')\n\nconst readPackage = ({ path, packageJsonCache }) =>\n  packageJsonCache.has(path) ? Promise.resolve(packageJsonCache.get(path))\n  : readFile(path).then(json => {\n      const pkg = normalizePackageBin(JSON.parse(json))\n      packageJsonCache.set(path, pkg)\n      return pkg\n    })\n    .catch(er => null)\n\n// just normalize bundle deps and bin, that's all we care about here.\nconst normalized = Symbol('package data has been normalized')\nconst rpj = ({ path, packageJsonCache }) =>\n  readPackage({path, packageJsonCache})\n  .then(pkg => {\n    if (!pkg || pkg[normalized])\n      return pkg\n    if (pkg.bundledDependencies && !pkg.bundleDependencies) {\n      pkg.bundleDependencies = pkg.bundledDependencies\n      delete pkg.bundledDependencies\n    }\n    const bd = pkg.bundleDependencies\n    if (bd === true) {\n      pkg.bundleDependencies = [\n        ...Object.keys(pkg.dependencies || {}),\n        ...Object.keys(pkg.optionalDependencies || {}),\n      ]\n    }\n    if (typeof bd === 'object' && !Array.isArray(bd)) {\n      pkg.bundleDependencies = Object.keys(bd)\n    }\n    pkg[normalized] = true\n    return pkg\n  })\n\n\nconst pkgContents = async ({\n  path,\n  depth,\n  currentDepth = 0,\n  pkg = null,\n  result = null,\n  packageJsonCache = null,\n}) => {\n  if (!result)\n    result = new Set()\n\n  if (!packageJsonCache)\n    packageJsonCache = new Map()\n\n  if (pkg === true) {\n    return rpj({ path: path + '/package.json', packageJsonCache })\n      .then(pkg => pkgContents({\n        path,\n        depth,\n        currentDepth,\n        pkg,\n        result,\n        packageJsonCache,\n      }))\n  }\n\n  if (pkg) {\n    // add all bins to result if they exist\n    if (pkg.bin) {\n      const dir = dirname(path)\n      const base = basename(path)\n      const scope = basename(dir)\n      const nm = /^@.+/.test(scope) ? dirname(dir) : dir\n\n      const binFiles = []\n      Object.keys(pkg.bin).forEach(b => {\n        const base = resolve(nm, '.bin', b)\n        binFiles.push(base, base + '.cmd', base + '.ps1')\n      })\n\n      const bins = await Promise.all(\n        binFiles.map(b => stat(b).then(() => b).catch((er) => null))\n      )\n      bins.filter(b => b).forEach(b => result.add(b))\n    }\n  }\n\n  if (currentDepth >= depth) {\n    result.add(path)\n    return result\n  }\n\n  // we'll need bundle list later, so get that now in parallel\n  const [dirEntries, bundleDeps] = await Promise.all([\n    readdir(path, { withFileTypes: true }),\n    currentDepth === 0 && pkg && pkg.bundleDependencies\n      ? bundled({ path, packageJsonCache }) : null,\n  ]).catch(() => [])\n\n  // not a thing, probably a missing folder\n  if (!dirEntries)\n    return result\n\n  // empty folder, just add the folder itself to the result\n  if (!dirEntries.length && !bundleDeps && currentDepth !== 0) {\n    result.add(path)\n    return result\n  }\n\n  const recursePromises = []\n\n  // if we didn't get withFileTypes support, tack that on\n  if (typeof dirEntries[0] === 'string') {\n    // use a map so we can return a promise, but we mutate dirEntries in place\n    // this is much slower than getting the entries from the readdir call,\n    // but polyfills support for node versions before 10.10\n    await Promise.all(dirEntries.map(async (name, index) => {\n      const p = resolve(path, name)\n      const st = await lstat(p)\n      dirEntries[index] = Object.assign(st, {name})\n    }))\n  }\n\n  for (const entry of dirEntries) {\n    const p = resolve(path, entry.name)\n    if (entry.isDirectory() === false) {\n      result.add(p)\n      continue\n    }\n\n    if (currentDepth !== 0 || entry.name !== 'node_modules') {\n      if (currentDepth < depth - 1) {\n        recursePromises.push(pkgContents({\n          path: p,\n          packageJsonCache,\n          depth,\n          currentDepth: currentDepth + 1,\n          result,\n        }))\n      } else {\n        result.add(p)\n      }\n      continue\n    }\n  }\n\n  if (bundleDeps) {\n    // bundle deps are all folders\n    // we always recurse to get pkg bins, but if currentDepth is too high,\n    // it'll return early before walking their contents.\n    recursePromises.push(...bundleDeps.map(dep => {\n      const p = resolve(path, 'node_modules', dep)\n      return pkgContents({\n        path: p,\n        packageJsonCache,\n        pkg: true,\n        depth,\n        currentDepth: currentDepth + 1,\n        result,\n      })\n    }))\n  }\n\n  if (recursePromises.length)\n    await Promise.all(recursePromises)\n\n  return result\n}\n\nmodule.exports = ({path, depth = 1, packageJsonCache}) => pkgContents({\n  path: resolve(path),\n  depth,\n  pkg: true,\n  packageJsonCache,\n}).then(results => [...results])\n\n\nif (require.main === module) {\n  const options = { path: null, depth: 1 }\n  const usage = `Usage:\n  installed-package-contents <path> [-d<n> --depth=<n>]\n\nLists the files installed for a package specified by <path>.\n\nOptions:\n  -d<n> --depth=<n>   Provide a numeric value (\"Infinity\" is allowed)\n                      to specify how deep in the file tree to traverse.\n                      Default=1\n  -h --help           Show this usage information`\n\n  process.argv.slice(2).forEach(arg => {\n    let match\n    if ((match = arg.match(/^--depth=([0-9]+|Infinity)/)) ||\n        (match = arg.match(/^-d([0-9]+|Infinity)/)))\n      options.depth = +match[1]\n    else if (arg === '-h' || arg === '--help') {\n      console.log(usage)\n      process.exit(0)\n    } else\n      options.path = arg\n  })\n  if (!options.path)  {\n    console.error('ERROR: no path provided')\n    console.error(usage)\n    process.exit(1)\n  }\n  const cwd = process.cwd()\n  module.exports(options)\n    .then(list => list.sort().forEach(p => console.log(relative(cwd, p))))\n    .catch(/* istanbul ignore next - pretty unusual */ er => {\n      console.error(er)\n      process.exit(1)\n    })\n}\n"]}