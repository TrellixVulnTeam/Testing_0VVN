{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst Minipass = require('minipass')\nconst npa = require('npm-package-arg')\nconst npmFetch = require('npm-registry-fetch')\nconst validate = require('aproba')\n\nconst eu = encodeURIComponent\nconst npar = spec => {\n  spec = npa(spec)\n  if (!spec.registry) {\n    throw new Error('`spec` must be a registry spec')\n  }\n  return spec\n}\nconst mapJSON = (value, [key]) => {\n  if (value === 'read') {\n    return [key, 'read-only']\n  } else if (value === 'write') {\n    return [key, 'read-write']\n  } else {\n    return [key, value]\n  }\n}\n\nconst cmd = module.exports = {}\n\ncmd.public = (spec, opts) => setAccess(spec, 'public', opts)\ncmd.restricted = (spec, opts) => setAccess(spec, 'restricted', opts)\nfunction setAccess (spec, access, opts = {}) {\n  return Promise.resolve().then(() => {\n    spec = npar(spec)\n    validate('OSO', [spec, access, opts])\n    const uri = `/-/package/${eu(spec.name)}/access`\n    return npmFetch(uri, {\n      ...opts,\n      method: 'POST',\n      body: { access },\n      spec,\n    }).then(() => true)\n  })\n}\n\ncmd.grant = (spec, entity, permissions, opts = {}) => {\n  return Promise.resolve().then(() => {\n    spec = npar(spec)\n    const { scope, team } = splitEntity(entity)\n    validate('OSSSO', [spec, scope, team, permissions, opts])\n    if (permissions !== 'read-write' && permissions !== 'read-only') {\n      throw new Error(\n        '`permissions` must be `read-write` or `read-only`. Got `'\n        + permissions + '` instead')\n    }\n    const uri = `/-/team/${eu(scope)}/${eu(team)}/package`\n    return npmFetch(uri, {\n      ...opts,\n      method: 'PUT',\n      body: { package: spec.name, permissions },\n      scope,\n      spec,\n      ignoreBody: true,\n    })\n      .then(() => true)\n  })\n}\n\ncmd.revoke = (spec, entity, opts = {}) => {\n  return Promise.resolve().then(() => {\n    spec = npar(spec)\n    const { scope, team } = splitEntity(entity)\n    validate('OSSO', [spec, scope, team, opts])\n    const uri = `/-/team/${eu(scope)}/${eu(team)}/package`\n    return npmFetch(uri, {\n      ...opts,\n      method: 'DELETE',\n      body: { package: spec.name },\n      scope,\n      spec,\n      ignoreBody: true,\n    })\n      .then(() => true)\n  })\n}\n\ncmd.lsPackages = (entity, opts) => {\n  return cmd.lsPackages.stream(entity, opts)\n    .collect()\n    .then(data => {\n      return data.reduce((acc, [key, val]) => {\n        if (!acc) {\n          acc = {}\n        }\n        acc[key] = val\n        return acc\n      }, null)\n    })\n}\n\ncmd.lsPackages.stream = (entity, opts = {}) => {\n  validate('SO|SZ', [entity, opts])\n  const { scope, team } = splitEntity(entity)\n  let uri\n  if (team) {\n    uri = `/-/team/${eu(scope)}/${eu(team)}/package`\n  } else {\n    uri = `/-/org/${eu(scope)}/package`\n  }\n  const nextOpts = {\n    ...opts,\n    query: { format: 'cli' },\n    mapJSON,\n  }\n  const ret = new Minipass({ objectMode: true })\n  npmFetch.json.stream(uri, '*', nextOpts)\n    .on('error', err => {\n      if (err.code === 'E404' && !team) {\n        uri = `/-/user/${eu(scope)}/package`\n        npmFetch.json.stream(uri, '*', nextOpts)\n          .on('error', err => ret.emit('error', err))\n          .pipe(ret)\n      } else {\n        ret.emit('error', err)\n      }\n    })\n    .pipe(ret)\n  return ret\n}\n\ncmd.lsCollaborators = (spec, user, opts) => {\n  return Promise.resolve().then(() => {\n    return cmd.lsCollaborators.stream(spec, user, opts)\n      .collect()\n      .then(data => {\n        return data.reduce((acc, [key, val]) => {\n          if (!acc) {\n            acc = {}\n          }\n          acc[key] = val\n          return acc\n        }, null)\n      })\n  })\n}\n\ncmd.lsCollaborators.stream = (spec, user, opts) => {\n  if (typeof user === 'object' && !opts) {\n    opts = user\n    user = undefined\n  } else if (!opts) {\n    opts = {}\n  }\n  spec = npar(spec)\n  validate('OSO|OZO', [spec, user, opts])\n  const uri = `/-/package/${eu(spec.name)}/collaborators`\n  return npmFetch.json.stream(uri, '*', {\n    ...opts,\n    query: { format: 'cli', user: user || undefined },\n    mapJSON,\n  })\n}\n\ncmd.tfaRequired = (spec, opts) => setRequires2fa(spec, true, opts)\ncmd.tfaNotRequired = (spec, opts) => setRequires2fa(spec, false, opts)\nfunction setRequires2fa (spec, required, opts = {}) {\n  return Promise.resolve().then(() => {\n    spec = npar(spec)\n    validate('OBO', [spec, required, opts])\n    const uri = `/-/package/${eu(spec.name)}/access`\n    return npmFetch(uri, {\n      ...opts,\n      method: 'POST',\n      body: { publish_requires_tfa: required },\n      spec,\n      ignoreBody: true,\n    }).then(() => true)\n  })\n}\n\ncmd.edit = () => {\n  throw new Error('Not implemented yet')\n}\n\nfunction splitEntity (entity = '') {\n  const [, scope, team] = entity.match(/^@?([^:]+)(?::(.*))?$/) || []\n  return { scope, team }\n}\n"]}