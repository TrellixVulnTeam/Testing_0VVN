{"version":3,"sources":["init-package-json.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nmodule.exports = init\nmodule.exports.yes = yes\n\nvar PZ = require('promzard').PromZard\nvar path = require('path')\nvar def = require.resolve('./default-input.js')\n\nvar fs = require('fs')\nvar semver = require('semver')\nvar read = require('read')\n\n// to validate the data object at the end as a worthwhile package\n// and assign default values for things.\nvar readJson = require('read-package-json')\n\nfunction yes (conf) {\n  return !!(\n    conf.get('yes') || conf.get('y') ||\n    conf.get('force') || conf.get('f')\n  )\n}\n\nfunction init (dir, input, config, cb) {\n  if (typeof config === 'function') {\n    cb = config\n    config = {}\n  }\n\n  // accept either a plain-jane object, or a config object\n  // with a \"get\" method.\n  if (typeof config.get !== 'function') {\n    var data = config\n    config = {\n      get: function (k) {\n        return data[k]\n      },\n      toJSON: function () {\n        return data\n      },\n    }\n  }\n\n  var packageFile = path.resolve(dir, 'package.json')\n  input = path.resolve(input)\n  var pkg\n  var ctx = { yes: yes(config) }\n\n  var es = readJson.extraSet\n  readJson.extraSet = es.filter(function (fn) {\n    return fn.name !== 'authors' && fn.name !== 'mans'\n  })\n  readJson(packageFile, function (er, d) {\n    readJson.extraSet = es\n\n    if (er) {\n      pkg = {}\n    } else {\n      pkg = d\n    }\n\n    ctx.filename = packageFile\n    ctx.dirname = path.dirname(packageFile)\n    ctx.basename = path.basename(ctx.dirname)\n    if (!pkg.version || !semver.valid(pkg.version)) {\n      delete pkg.version\n    }\n\n    ctx.package = pkg\n    ctx.config = config || {}\n\n    // make sure that the input is valid.\n    // if not, use the default\n    var pz = new PZ(input, ctx)\n    pz.backupFile = def\n    pz.on('error', cb)\n    pz.on('data', function (data) {\n      Object.keys(data).forEach(function (k) {\n        if (data[k] !== undefined && data[k] !== null) {\n          pkg[k] = data[k]\n        }\n      })\n\n      // only do a few of these.\n      // no need for mans or contributors if they're in the files\n      var es = readJson.extraSet\n      readJson.extraSet = es.filter(function (fn) {\n        return fn.name !== 'authors' && fn.name !== 'mans'\n      })\n      readJson.extras(packageFile, pkg, function (er, pkg) {\n        if (er) {\n          return cb(er, pkg)\n        }\n        readJson.extraSet = es\n        pkg = unParsePeople(pkg)\n        // no need for the readme now.\n        delete pkg.readme\n        delete pkg.readmeFilename\n\n        // really don't want to have this lying around in the file\n        delete pkg._id\n\n        // ditto\n        delete pkg.gitHead\n\n        // if the repo is empty, remove it.\n        if (!pkg.repository) {\n          delete pkg.repository\n        }\n\n        // readJson filters out empty descriptions, but init-package-json\n        // traditionally leaves them alone\n        if (!pkg.description) {\n          pkg.description = data.description\n        }\n\n        var d = JSON.stringify(updateDeps(pkg), null, 2) + '\\n'\n        function write (yes) {\n          fs.writeFile(packageFile, d, 'utf8', function (er) {\n            if (!er && yes && !config.get('silent')) {\n              console.log('Wrote to %s:\\n\\n%s\\n', packageFile, d)\n            }\n            return cb(er, pkg)\n          })\n        }\n        if (ctx.yes) {\n          return write(true)\n        }\n        console.log('About to write to %s:\\n\\n%s\\n', packageFile, d)\n        read({ prompt: 'Is this OK? ', default: 'yes' }, function (er, ok) {\n          if (er) {\n            return cb(er)\n          }\n          if (!ok || ok.toLowerCase().charAt(0) !== 'y') {\n            console.log('Aborted.')\n          } else {\n            return write()\n          }\n        })\n      })\n    })\n  })\n}\n\nfunction updateDeps (depsData) {\n  // optionalDependencies don't need to be repeated in two places\n  if (depsData.dependencies) {\n    if (depsData.optionalDependencies) {\n      for (const name of Object.keys(depsData.optionalDependencies)) {\n        delete depsData.dependencies[name]\n      }\n    }\n    if (Object.keys(depsData.dependencies).length === 0) {\n      delete depsData.dependencies\n    }\n  }\n\n  return depsData\n}\n\n// turn the objects into somewhat more humane strings.\nfunction unParsePeople (data) {\n  if (data.author) {\n    data.author = unParsePerson(data.author)\n  }['maintainers', 'contributors'].forEach(function (set) {\n    if (!Array.isArray(data[set])) {\n      return\n    }\n    data[set] = data[set].map(unParsePerson)\n  })\n  return data\n}\n\nfunction unParsePerson (person) {\n  if (typeof person === 'string') {\n    return person\n  }\n  var name = person.name || ''\n  var u = person.url || person.web\n  var url = u ? (' (' + u + ')') : ''\n  var e = person.email || person.mail\n  var email = e ? (' <' + e + '>') : ''\n  return name + email + url\n}\n"]}