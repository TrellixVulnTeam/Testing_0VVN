{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst fetch = require('npm-registry-fetch')\nconst { HttpErrorBase } = require('npm-registry-fetch/lib/errors')\nconst os = require('os')\nconst { URL } = require('url')\nconst log = require('proc-log')\n\n// try loginWeb, catch the \"not supported\" message and fall back to couch\nconst login = (opener, prompter, opts = {}) => {\n  const { creds } = opts\n  return loginWeb(opener, opts).catch(er => {\n    if (er instanceof WebLoginNotSupported) {\n      log.verbose('web login not supported, trying couch')\n      return prompter(creds)\n        .then(data => loginCouch(data.username, data.password, opts))\n    } else {\n      throw er\n    }\n  })\n}\n\nconst adduser = (opener, prompter, opts = {}) => {\n  const { creds } = opts\n  return adduserWeb(opener, opts).catch(er => {\n    if (er instanceof WebLoginNotSupported) {\n      log.verbose('web adduser not supported, trying couch')\n      return prompter(creds)\n        .then(data => adduserCouch(data.username, data.email, data.password, opts))\n    } else {\n      throw er\n    }\n  })\n}\n\nconst adduserWeb = (opener, opts = {}) => {\n  log.verbose('web adduser', 'before first POST')\n  return webAuth(opener, opts, { create: true })\n}\n\nconst loginWeb = (opener, opts = {}) => {\n  log.verbose('web login', 'before first POST')\n  return webAuth(opener, opts, {})\n}\n\nconst isValidUrl = u => {\n  try {\n    return /^https?:$/.test(new URL(u).protocol)\n  } catch (er) {\n    return false\n  }\n}\n\nconst webAuth = (opener, opts, body) => {\n  const { hostname } = opts\n  body.hostname = hostname || os.hostname()\n  const target = '/-/v1/login'\n  return fetch(target, {\n    ...opts,\n    method: 'POST',\n    body,\n  }).then(res => {\n    return Promise.all([res, res.json()])\n  }).then(([res, content]) => {\n    const { doneUrl, loginUrl } = content\n    log.verbose('web auth', 'got response', content)\n    if (!isValidUrl(doneUrl) || !isValidUrl(loginUrl)) {\n      throw new WebLoginInvalidResponse('POST', res, content)\n    }\n    return content\n  }).then(({ doneUrl, loginUrl }) => {\n    log.verbose('web auth', 'opening url pair')\n    return opener(loginUrl).then(\n      () => webAuthCheckLogin(doneUrl, { ...opts, cache: false })\n    )\n  }).catch(er => {\n    if ((er.statusCode >= 400 && er.statusCode <= 499) || er.statusCode === 500) {\n      throw new WebLoginNotSupported('POST', {\n        status: er.statusCode,\n        headers: { raw: () => er.headers },\n      }, er.body)\n    } else {\n      throw er\n    }\n  })\n}\n\nconst webAuthCheckLogin = (doneUrl, opts) => {\n  return fetch(doneUrl, opts).then(res => {\n    return Promise.all([res, res.json()])\n  }).then(([res, content]) => {\n    if (res.status === 200) {\n      if (!content.token) {\n        throw new WebLoginInvalidResponse('GET', res, content)\n      } else {\n        return content\n      }\n    } else if (res.status === 202) {\n      const retry = +res.headers.get('retry-after') * 1000\n      if (retry > 0) {\n        return sleep(retry).then(() => webAuthCheckLogin(doneUrl, opts))\n      } else {\n        return webAuthCheckLogin(doneUrl, opts)\n      }\n    } else {\n      throw new WebLoginInvalidResponse('GET', res, content)\n    }\n  })\n}\n\nconst adduserCouch = (username, email, password, opts = {}) => {\n  const body = {\n    _id: 'org.couchdb.user:' + username,\n    name: username,\n    password: password,\n    email: email,\n    type: 'user',\n    roles: [],\n    date: new Date().toISOString(),\n  }\n  const logObj = {\n    ...body,\n    password: 'XXXXX',\n  }\n  log.verbose('adduser', 'before first PUT', logObj)\n\n  const target = '/-/user/org.couchdb.user:' + encodeURIComponent(username)\n  return fetch.json(target, {\n    ...opts,\n    method: 'PUT',\n    body,\n  }).then(result => {\n    result.username = username\n    return result\n  })\n}\n\nconst loginCouch = (username, password, opts = {}) => {\n  const body = {\n    _id: 'org.couchdb.user:' + username,\n    name: username,\n    password: password,\n    type: 'user',\n    roles: [],\n    date: new Date().toISOString(),\n  }\n  const logObj = {\n    ...body,\n    password: 'XXXXX',\n  }\n  log.verbose('login', 'before first PUT', logObj)\n\n  const target = '/-/user/org.couchdb.user:' + encodeURIComponent(username)\n  return fetch.json(target, {\n    ...opts,\n    method: 'PUT',\n    body,\n  }).catch(err => {\n    if (err.code === 'E400') {\n      err.message = `There is no user with the username \"${username}\".`\n      throw err\n    }\n    if (err.code !== 'E409') {\n      throw err\n    }\n    return fetch.json(target, {\n      ...opts,\n      query: { write: true },\n    }).then(result => {\n      Object.keys(result).forEach(k => {\n        if (!body[k] || k === 'roles') {\n          body[k] = result[k]\n        }\n      })\n      const { otp } = opts\n      return fetch.json(`${target}/-rev/${body._rev}`, {\n        ...opts,\n        method: 'PUT',\n        body,\n        forceAuth: {\n          username,\n          password: Buffer.from(password, 'utf8').toString('base64'),\n          otp,\n        },\n      })\n    })\n  }).then(result => {\n    result.username = username\n    return result\n  })\n}\n\nconst get = (opts = {}) => fetch.json('/-/npm/v1/user', opts)\n\nconst set = (profile, opts = {}) => {\n  Object.keys(profile).forEach(key => {\n    // profile keys can't be empty strings, but they CAN be null\n    if (profile[key] === '') {\n      profile[key] = null\n    }\n  })\n  return fetch.json('/-/npm/v1/user', {\n    ...opts,\n    method: 'POST',\n    body: profile,\n  })\n}\n\nconst listTokens = (opts = {}) => {\n  const untilLastPage = (href, objects) => {\n    return fetch.json(href, opts).then(result => {\n      objects = objects ? objects.concat(result.objects) : result.objects\n      if (result.urls.next) {\n        return untilLastPage(result.urls.next, objects)\n      } else {\n        return objects\n      }\n    })\n  }\n  return untilLastPage('/-/npm/v1/tokens')\n}\n\nconst removeToken = (tokenKey, opts = {}) => {\n  const target = `/-/npm/v1/tokens/token/${tokenKey}`\n  return fetch(target, {\n    ...opts,\n    method: 'DELETE',\n    ignoreBody: true,\n  }).then(() => null)\n}\n\nconst createToken = (password, readonly, cidrs, opts = {}) => {\n  return fetch.json('/-/npm/v1/tokens', {\n    ...opts,\n    method: 'POST',\n    body: {\n      password: password,\n      readonly: readonly,\n      cidr_whitelist: cidrs,\n    },\n  })\n}\n\nclass WebLoginInvalidResponse extends HttpErrorBase {\n  constructor (method, res, body) {\n    super(method, res, body)\n    this.message = 'Invalid response from web login endpoint'\n    Error.captureStackTrace(this, WebLoginInvalidResponse)\n  }\n}\n\nclass WebLoginNotSupported extends HttpErrorBase {\n  constructor (method, res, body) {\n    super(method, res, body)\n    this.message = 'Web login not supported'\n    this.code = 'ENYI'\n    Error.captureStackTrace(this, WebLoginNotSupported)\n  }\n}\n\nconst sleep = (ms) =>\n  new Promise((resolve, reject) => setTimeout(resolve, ms))\n\nmodule.exports = {\n  adduserCouch,\n  loginCouch,\n  adduserWeb,\n  loginWeb,\n  login,\n  adduser,\n  get,\n  set,\n  listTokens,\n  removeToken,\n  createToken,\n}\n"]}