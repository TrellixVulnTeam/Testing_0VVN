{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const parseJSON = require('json-parse-even-better-errors')\nconst { diff } = require('just-diff')\nconst { diffApply } = require('just-diff-apply')\n\nconst globalObjectProperties = Object.getOwnPropertyNames(Object.prototype)\n\nconst stripBOM = content => {\n  content = content.toString()\n  // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1)\n  }\n  return content\n}\n\nconst PARENT_RE = /\\|{7,}/g\nconst OURS_RE = /<{7,}/g\nconst THEIRS_RE = /={7,}/g\nconst END_RE = />{7,}/g\n\nconst isDiff = str =>\n  str.match(OURS_RE) && str.match(THEIRS_RE) && str.match(END_RE)\n\nconst parseConflictJSON = (str, reviver, prefer) => {\n  prefer = prefer || 'ours'\n  if (prefer !== 'theirs' && prefer !== 'ours') {\n    throw new TypeError('prefer param must be \"ours\" or \"theirs\" if set')\n  }\n\n  str = stripBOM(str)\n\n  if (!isDiff(str)) {\n    return parseJSON(str)\n  }\n\n  const pieces = str.split(/[\\n\\r]+/g).reduce((acc, line) => {\n    if (line.match(PARENT_RE)) {\n      acc.state = 'parent'\n    } else if (line.match(OURS_RE)) {\n      acc.state = 'ours'\n    } else if (line.match(THEIRS_RE)) {\n      acc.state = 'theirs'\n    } else if (line.match(END_RE)) {\n      acc.state = 'top'\n    } else {\n      if (acc.state === 'top' || acc.state === 'ours') {\n        acc.ours += line\n      }\n      if (acc.state === 'top' || acc.state === 'theirs') {\n        acc.theirs += line\n      }\n      if (acc.state === 'top' || acc.state === 'parent') {\n        acc.parent += line\n      }\n    }\n    return acc\n  }, {\n    state: 'top',\n    ours: '',\n    theirs: '',\n    parent: '',\n  })\n\n  // this will throw if either piece is not valid JSON, that's intended\n  const parent = parseJSON(pieces.parent, reviver)\n  const ours = parseJSON(pieces.ours, reviver)\n  const theirs = parseJSON(pieces.theirs, reviver)\n\n  return prefer === 'ours'\n    ? resolve(parent, ours, theirs)\n    : resolve(parent, theirs, ours)\n}\n\nconst isObj = obj => obj && typeof obj === 'object'\n\nconst copyPath = (to, from, path, i) => {\n  const p = path[i]\n  if (isObj(to[p]) && isObj(from[p]) &&\n      Array.isArray(to[p]) === Array.isArray(from[p])) {\n    return copyPath(to[p], from[p], path, i + 1)\n  }\n  to[p] = from[p]\n}\n\n// get the diff from parent->ours and applying our changes on top of theirs.\n// If they turned an object into a non-object, then put it back.\nconst resolve = (parent, ours, theirs) => {\n  const dours = diff(parent, ours)\n  for (let i = 0; i < dours.length; i++) {\n    if (globalObjectProperties.find(prop => dours[i].path.includes(prop))) {\n      continue\n    }\n    try {\n      diffApply(theirs, [dours[i]])\n    } catch (e) {\n      copyPath(theirs, ours, dours[i].path, 0)\n    }\n  }\n  return theirs\n}\n\nmodule.exports = Object.assign(parseConflictJSON, { isDiff })\n"]}