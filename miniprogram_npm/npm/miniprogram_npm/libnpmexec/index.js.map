{"version":3,"sources":["index.js","cache-install-dir.js","file-exists.js","get-bin-from-manifest.js","manifest-missing.js","no-tty.js","run-script.js","is-windows.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,AHSA,AIZA;AHUA,ACHA,ACHA,AHSA,AIZA;AHUA,ACHA,ACHA,AHSA,AIZA;AHUA,ACHA,ACHA,AHSA,AIZA,ACHA;AJaA,ACHA,ACHA,AHSA,AIZA,ACHA;AJaA,ACHA,ACHA,AHSA,AIZA;AHUA,ACHA,ACHA,AHSA,AIZA,AENA;ALgBA,ACHA,ACHA,AHSA,AIZA,AENA;ALgBA,ACHA,ACHA,AHSA,AIZA,AENA;ALgBA,ACHA,ACHA,AHSA,AOrBA,AHSA,AENA;ALgBA,ACHA,ACHA,AHSA,AOrBA,AHSA,AENA;ALgBA,ACHA,ACHA,AHSA,AIZA,AENA;AJaA,ACHA,AHSA,AIZA,AENA;AJaA,ACHA,AHSA,AIZA,AENA;AJaA,ACHA,AHSA,AIZA,AENA;AJaA,ACHA,AHSA,AIZA,AENA;AJaA,ACHA,AHSA,AIZA,AENA;AJaA,ACHA,AHSA,AIZA,AENA;AJaA,ACHA,AHSA,AIZA,AENA;AJaA,ACHA,AHSA,AIZA,AENA;AJaA,AFMA,AMlBA;AJaA,AFMA,AMlBA;AJaA,AFMA,AMlBA;AJaA,AFMA,AMlBA;AJaA,AFMA,AMlBA;AJaA,AFMA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA,AMlBA;ANmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const { delimiter, dirname, resolve } = require('path')\nconst { promisify } = require('util')\nconst read = promisify(require('read'))\n\nconst Arborist = require('@npmcli/arborist')\nconst ciDetect = require('@npmcli/ci-detect')\nconst log = require('proc-log')\nconst npmlog = require('npmlog')\nconst mkdirp = require('mkdirp-infer-owner')\nconst npa = require('npm-package-arg')\nconst pacote = require('pacote')\nconst readPackageJson = require('read-package-json-fast')\n\nconst cacheInstallDir = require('./cache-install-dir.js')\nconst { fileExists, localFileExists } = require('./file-exists.js')\nconst getBinFromManifest = require('./get-bin-from-manifest.js')\nconst manifestMissing = require('./manifest-missing.js')\nconst noTTY = require('./no-tty.js')\nconst runScript = require('./run-script.js')\nconst isWindows = require('./is-windows.js')\n\n/* istanbul ignore next */\nconst PATH = (\n  process.env.PATH || process.env.Path || process.env.path\n).split(delimiter)\n\nconst exec = async (opts) => {\n  const {\n    args = [],\n    call = '',\n    color = false,\n    localBin = resolve('./node_modules/.bin'),\n    locationMsg = undefined,\n    globalBin = '',\n    output,\n    packages: _packages = [],\n    path = '.',\n    runPath = '.',\n    scriptShell = isWindows ? process.env.ComSpec || 'cmd' : 'sh',\n    yes = undefined,\n    ...flatOptions\n  } = opts\n\n  // dereferences values because we manipulate it later\n  const packages = [..._packages]\n  const pathArr = [...PATH]\n  const _run = () => runScript({\n    args,\n    call,\n    color,\n    flatOptions,\n    locationMsg,\n    output,\n    path,\n    pathArr,\n    runPath,\n    scriptShell,\n  })\n\n  // nothing to maybe install, skip the arborist dance\n  if (!call && !args.length && !packages.length) {\n    return await _run()\n  }\n\n  const needPackageCommandSwap = args.length && !packages.length\n  // if there's an argument and no package has been explicitly asked for\n  // check the local and global bin paths for a binary named the same as\n  // the argument and run it if it exists, otherwise fall through to\n  // the behavior of treating the single argument as a package name\n  if (needPackageCommandSwap) {\n    let binExists = false\n    const dir = dirname(dirname(localBin))\n    const localBinPath = await localFileExists(dir, args[0])\n    if (localBinPath) {\n      pathArr.unshift(localBinPath)\n      binExists = true\n    } else if (await fileExists(`${globalBin}/${args[0]}`)) {\n      pathArr.unshift(globalBin)\n      binExists = true\n    }\n\n    if (binExists) {\n      return await _run()\n    }\n\n    packages.push(args[0])\n  }\n\n  // If we do `npm exec foo`, and have a `foo` locally, then we'll\n  // always use that, so we don't really need to fetch the manifest.\n  // So: run npa on each packages entry, and if it is a name with a\n  // rawSpec==='', then try to readPackageJson at\n  // node_modules/${name}/package.json, and only pacote fetch if\n  // that fails.\n  const manis = await Promise.all(packages.map(async p => {\n    const spec = npa(p, path)\n    if (spec.type === 'tag' && spec.rawSpec === '') {\n      // fall through to the pacote.manifest() approach\n      try {\n        const pj = resolve(path, 'node_modules', spec.name, 'package.json')\n        return await readPackageJson(pj)\n      } catch (er) {}\n    }\n    // Force preferOnline to true so we are making sure to pull in the latest\n    // This is especially useful if the user didn't give us a version, and\n    // they expect to be running @latest\n    return await pacote.manifest(p, {\n      ...flatOptions,\n      preferOnline: true,\n    })\n  }))\n\n  if (needPackageCommandSwap) {\n    args[0] = getBinFromManifest(manis[0])\n  }\n\n  // figure out whether we need to install stuff, or if local is fine\n  const localArb = new Arborist({\n    ...flatOptions,\n    path,\n  })\n  const tree = await localArb.loadActual()\n\n  // do we have all the packages in manifest list?\n  const needInstall =\n    manis.some(manifest => manifestMissing({ tree, manifest }))\n\n  if (needInstall) {\n    const { npxCache } = flatOptions\n    const installDir = cacheInstallDir({ npxCache, packages })\n    await mkdirp(installDir)\n    const arb = new Arborist({\n      ...flatOptions,\n      path: installDir,\n    })\n    const tree = await arb.loadActual()\n\n    // at this point, we have to ensure that we get the exact same\n    // version, because it's something that has only ever been installed\n    // by npm exec in the cache install directory\n    const add = manis.filter(mani => manifestMissing({\n      tree,\n      manifest: {\n        ...mani,\n        _from: `${mani.name}@${mani.version}`,\n      },\n    }))\n      .map(mani => mani._from)\n      .sort((a, b) => a.localeCompare(b, 'en'))\n\n    // no need to install if already present\n    if (add.length) {\n      if (!yes) {\n        // set -n to always say no\n        if (yes === false) {\n          throw new Error('canceled')\n        }\n\n        if (noTTY() || ciDetect()) {\n          log.warn('exec', `The following package${\n            add.length === 1 ? ' was' : 's were'\n          } not found and will be installed: ${\n            add.map((pkg) => pkg.replace(/@$/, '')).join(', ')\n          }`)\n        } else {\n          const addList = add.map(a => `  ${a.replace(/@$/, '')}`)\n            .join('\\n') + '\\n'\n          const prompt = `Need to install the following packages:\\n${\n          addList\n        }Ok to proceed? `\n          npmlog.clearProgress()\n          const confirm = await read({ prompt, default: 'y' })\n          if (confirm.trim().toLowerCase().charAt(0) !== 'y') {\n            throw new Error('canceled')\n          }\n        }\n      }\n      await arb.reify({\n        ...flatOptions,\n        add,\n      })\n    }\n    pathArr.unshift(resolve(installDir, 'node_modules/.bin'))\n  }\n\n  return await _run()\n}\n\nmodule.exports = exec\n","const crypto = require('crypto')\n\nconst { resolve } = require('path')\n\nconst cacheInstallDir = ({ npxCache, packages }) => {\n  if (!npxCache) {\n    throw new Error('Must provide a valid npxCache path')\n  }\n\n  // only packages not found in ${prefix}/node_modules\n  return resolve(npxCache, getHash(packages))\n}\n\nconst getHash = (packages) =>\n  crypto.createHash('sha512')\n    .update(packages.sort((a, b) => a.localeCompare(b, 'en')).join('\\n'))\n    .digest('hex')\n    .slice(0, 16)\n\nmodule.exports = cacheInstallDir\n","const { resolve } = require('path')\nconst { promisify } = require('util')\nconst stat = promisify(require('fs').stat)\nconst walkUp = require('walk-up-path')\n\nconst fileExists = (file) => stat(file)\n  .then((stat) => stat.isFile())\n  .catch(() => false)\n\nconst localFileExists = async (dir, binName, root = '/') => {\n  root = resolve(root).toLowerCase()\n\n  for (const path of walkUp(resolve(dir))) {\n    const binDir = resolve(path, 'node_modules', '.bin')\n\n    if (await fileExists(resolve(binDir, binName))) {\n      return binDir\n    }\n\n    if (path.toLowerCase() === root) {\n      return false\n    }\n  }\n\n  return false\n}\n\nmodule.exports = {\n  fileExists,\n  localFileExists,\n}\n","const getBinFromManifest = (mani) => {\n  // if we have a bin matching (unscoped portion of) packagename, use that\n  // otherwise if there's 1 bin or all bin value is the same (alias), use\n  // that, otherwise fail\n  const bin = mani.bin || {}\n  if (new Set(Object.values(bin)).size === 1) {\n    return Object.keys(bin)[0]\n  }\n\n  // XXX probably a util to parse this better?\n  const name = mani.name.replace(/^@[^/]+\\//, '')\n  if (bin[name]) {\n    return name\n  }\n\n  // XXX need better error message\n  throw Object.assign(new Error('could not determine executable to run'), {\n    pkgid: mani._id,\n  })\n}\n\nmodule.exports = getBinFromManifest\n","const manifestMissing = ({ tree, manifest }) => {\n  // if the tree doesn't have a child by that name/version, return true\n  // true means we need to install it\n  const child = tree.children.get(manifest.name)\n  // if no child, we have to load it\n  if (!child) {\n    return true\n  }\n\n  // if no version/tag specified, allow whatever's there\n  if (manifest._from === `${manifest.name}@`) {\n    return false\n  }\n\n  // otherwise the version has to match what we WOULD get\n  return child.version !== manifest.version\n}\n\nmodule.exports = manifestMissing\n","module.exports = () => !process.stdin.isTTY\n","const { delimiter } = require('path')\n\nconst chalk = require('chalk')\nconst ciDetect = require('@npmcli/ci-detect')\nconst runScript = require('@npmcli/run-script')\nconst readPackageJson = require('read-package-json-fast')\nconst npmlog = require('npmlog')\nconst log = require('proc-log')\nconst noTTY = require('./no-tty.js')\n\nconst nocolor = {\n  reset: s => s,\n  bold: s => s,\n  dim: s => s,\n}\n\nconst run = async ({\n  args,\n  call,\n  color,\n  flatOptions,\n  locationMsg,\n  output = () => {},\n  path,\n  pathArr,\n  runPath,\n  scriptShell,\n}) => {\n  // turn list of args into command string\n  const script = call || args.shift() || scriptShell\n  const colorize = color ? chalk : nocolor\n\n  // do the fakey runScript dance\n  // still should work if no package.json in cwd\n  const realPkg = await readPackageJson(`${path}/package.json`)\n    .catch(() => ({}))\n  const pkg = {\n    ...realPkg,\n    scripts: {\n      ...(realPkg.scripts || {}),\n      npx: script,\n    },\n  }\n\n  npmlog.disableProgress()\n\n  try {\n    if (script === scriptShell) {\n      const isTTY = !noTTY()\n\n      if (isTTY) {\n        if (ciDetect()) {\n          return log.warn('exec', 'Interactive mode disabled in CI environment')\n        }\n\n        locationMsg = locationMsg || ` at location:\\n${colorize.dim(runPath)}`\n\n        output(`${\n          colorize.reset('\\nEntering npm script environment')\n        }${\n          colorize.reset(locationMsg)\n        }${\n          colorize.bold('\\nType \\'exit\\' or ^D when finished\\n')\n        }`)\n      }\n    }\n    return await runScript({\n      ...flatOptions,\n      pkg,\n      banner: false,\n      // we always run in cwd, not --prefix\n      path: runPath,\n      stdioString: true,\n      event: 'npx',\n      args,\n      env: {\n        PATH: pathArr.join(delimiter),\n      },\n      stdio: 'inherit',\n    })\n  } finally {\n    npmlog.enableProgress()\n  }\n}\n\nmodule.exports = run\n","module.exports = process.platform === 'win32'\n"]}