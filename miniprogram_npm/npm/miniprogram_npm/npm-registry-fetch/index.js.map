{"version":3,"sources":["index.js","errors.js","check-response.js","default-opts.js","../package.json","auth.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,AFMA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ACHA,AFMA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AIXA,ACHA,AHSA,ADGA,ADGA;AKdA,AHSA,ADGA,ADGA;AKdA,AHSA,ADGA,ADGA;AKdA,AHSA,ADGA,ADGA;AKdA,AHSA,ADGA,ADGA;AKdA,AHSA,ADGA,ADGA;AKdA,AHSA,ADGA,ADGA;AKdA,AHSA,ADGA,ADGA;AKdA,AHSA,ADGA,ADGA;AKdA,AHSA,ADGA,ADGA;AKdA,AHSA,ADGA,ADGA;AKdA,AHSA,ADGA,ADGA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,AHSA,AFMA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst { HttpErrorAuthOTP } = require('./errors.js')\nconst checkResponse = require('./check-response.js')\nconst getAuth = require('./auth.js')\nconst fetch = require('make-fetch-happen')\nconst JSONStream = require('minipass-json-stream')\nconst npa = require('npm-package-arg')\nconst qs = require('querystring')\nconst url = require('url')\nconst zlib = require('minizlib')\nconst Minipass = require('minipass')\n\nconst defaultOpts = require('./default-opts.js')\n\n// WhatWG URL throws if it's not fully resolved\nconst urlIsValid = u => {\n  try {\n    return !!new url.URL(u)\n  } catch (_) {\n    return false\n  }\n}\n\nmodule.exports = regFetch\nfunction regFetch (uri, /* istanbul ignore next */ opts_ = {}) {\n  const opts = {\n    ...defaultOpts,\n    ...opts_,\n  }\n\n  // if we did not get a fully qualified URI, then we look at the registry\n  // config or relevant scope to resolve it.\n  const uriValid = urlIsValid(uri)\n  let registry = opts.registry || defaultOpts.registry\n  if (!uriValid) {\n    registry = opts.registry = (\n      (opts.spec && pickRegistry(opts.spec, opts)) ||\n      opts.registry ||\n      registry\n    )\n    uri = `${\n      registry.trim().replace(/\\/?$/g, '')\n    }/${\n      uri.trim().replace(/^\\//, '')\n    }`\n    // asserts that this is now valid\n    new url.URL(uri)\n  }\n\n  const method = opts.method || 'GET'\n\n  // through that takes into account the scope, the prefix of `uri`, etc\n  const startTime = Date.now()\n  const auth = getAuth(uri, opts)\n  const headers = getHeaders(uri, auth, opts)\n  let body = opts.body\n  const bodyIsStream = Minipass.isStream(body)\n  const bodyIsPromise = body &&\n    typeof body === 'object' &&\n    typeof body.then === 'function'\n\n  if (\n    body && !bodyIsStream && !bodyIsPromise && typeof body !== 'string' && !Buffer.isBuffer(body)\n  ) {\n    headers['content-type'] = headers['content-type'] || 'application/json'\n    body = JSON.stringify(body)\n  } else if (body && !headers['content-type']) {\n    headers['content-type'] = 'application/octet-stream'\n  }\n\n  if (opts.gzip) {\n    headers['content-encoding'] = 'gzip'\n    if (bodyIsStream) {\n      const gz = new zlib.Gzip()\n      body.on('error', /* istanbul ignore next: unlikely and hard to test */\n        err => gz.emit('error', err))\n      body = body.pipe(gz)\n    } else if (!bodyIsPromise) {\n      body = new zlib.Gzip().end(body).concat()\n    }\n  }\n\n  const parsed = new url.URL(uri)\n\n  if (opts.query) {\n    const q = typeof opts.query === 'string' ? qs.parse(opts.query)\n      : opts.query\n\n    Object.keys(q).forEach(key => {\n      if (q[key] !== undefined) {\n        parsed.searchParams.set(key, q[key])\n      }\n    })\n    uri = url.format(parsed)\n  }\n\n  if (parsed.searchParams.get('write') === 'true' && method === 'GET') {\n    // do not cache, because this GET is fetching a rev that will be\n    // used for a subsequent PUT or DELETE, so we need to conditionally\n    // update cache.\n    opts.offline = false\n    opts.preferOffline = false\n    opts.preferOnline = true\n  }\n\n  const doFetch = async body => {\n    const p = fetch(uri, {\n      agent: opts.agent,\n      algorithms: opts.algorithms,\n      body,\n      cache: getCacheMode(opts),\n      cachePath: opts.cache,\n      ca: opts.ca,\n      cert: opts.cert,\n      headers,\n      integrity: opts.integrity,\n      key: opts.key,\n      localAddress: opts.localAddress,\n      maxSockets: opts.maxSockets,\n      memoize: opts.memoize,\n      method: method,\n      noProxy: opts.noProxy,\n      proxy: opts.httpsProxy || opts.proxy,\n      retry: opts.retry ? opts.retry : {\n        retries: opts.fetchRetries,\n        factor: opts.fetchRetryFactor,\n        minTimeout: opts.fetchRetryMintimeout,\n        maxTimeout: opts.fetchRetryMaxtimeout,\n      },\n      strictSSL: opts.strictSSL,\n      timeout: opts.timeout || 30 * 1000,\n    }).then(res => checkResponse({\n      method,\n      uri,\n      res,\n      registry,\n      startTime,\n      auth,\n      opts,\n    }))\n\n    if (typeof opts.otpPrompt === 'function') {\n      return p.catch(async er => {\n        if (er instanceof HttpErrorAuthOTP) {\n          let otp\n          // if otp fails to complete, we fail with that failure\n          try {\n            otp = await opts.otpPrompt()\n          } catch (_) {\n            // ignore this error\n          }\n          // if no otp provided, or otpPrompt errored, throw the original HTTP error\n          if (!otp) {\n            throw er\n          }\n          return regFetch(uri, { ...opts, otp })\n        }\n        throw er\n      })\n    } else {\n      return p\n    }\n  }\n\n  return Promise.resolve(body).then(doFetch)\n}\n\nmodule.exports.json = fetchJSON\nfunction fetchJSON (uri, opts) {\n  return regFetch(uri, opts).then(res => res.json())\n}\n\nmodule.exports.json.stream = fetchJSONStream\nfunction fetchJSONStream (uri, jsonPath,\n  /* istanbul ignore next */ opts_ = {}) {\n  const opts = { ...defaultOpts, ...opts_ }\n  const parser = JSONStream.parse(jsonPath, opts.mapJSON)\n  regFetch(uri, opts).then(res =>\n    res.body.on('error',\n      /* istanbul ignore next: unlikely and difficult to test */\n      er => parser.emit('error', er)).pipe(parser)\n  ).catch(er => parser.emit('error', er))\n  return parser\n}\n\nmodule.exports.pickRegistry = pickRegistry\nfunction pickRegistry (spec, opts = {}) {\n  spec = npa(spec)\n  let registry = spec.scope &&\n    opts[spec.scope.replace(/^@?/, '@') + ':registry']\n\n  if (!registry && opts.scope) {\n    registry = opts[opts.scope.replace(/^@?/, '@') + ':registry']\n  }\n\n  if (!registry) {\n    registry = opts.registry || defaultOpts.registry\n  }\n\n  return registry\n}\n\nfunction getCacheMode (opts) {\n  return opts.offline ? 'only-if-cached'\n    : opts.preferOffline ? 'force-cache'\n    : opts.preferOnline ? 'no-cache'\n    : 'default'\n}\n\nfunction getHeaders (uri, auth, opts) {\n  const headers = Object.assign({\n    'user-agent': opts.userAgent,\n  }, opts.headers || {})\n\n  if (opts.scope) {\n    headers['npm-scope'] = opts.scope\n  }\n\n  if (opts.npmSession) {\n    headers['npm-session'] = opts.npmSession\n  }\n\n  if (opts.npmCommand) {\n    headers['npm-command'] = opts.npmCommand\n  }\n\n  // If a tarball is hosted on a different place than the manifest, only send\n  // credentials on `alwaysAuth`\n  if (auth.token) {\n    headers.authorization = `Bearer ${auth.token}`\n  } else if (auth.auth) {\n    headers.authorization = `Basic ${auth.auth}`\n  }\n\n  if (opts.otp) {\n    headers['npm-otp'] = opts.otp\n  }\n\n  return headers\n}\n","\n\nconst url = require('url')\n\nfunction packageName (href) {\n  try {\n    let basePath = new url.URL(href).pathname.substr(1)\n    if (!basePath.match(/^-/)) {\n      basePath = basePath.split('/')\n      var index = basePath.indexOf('_rewrite')\n      if (index === -1) {\n        index = basePath.length - 1\n      } else {\n        index++\n      }\n      return decodeURIComponent(basePath[index])\n    }\n  } catch (_) {\n    // this is ok\n  }\n}\n\nclass HttpErrorBase extends Error {\n  constructor (method, res, body, spec) {\n    super()\n    this.name = this.constructor.name\n    this.headers = res.headers.raw()\n    this.statusCode = res.status\n    this.code = `E${res.status}`\n    this.method = method\n    this.uri = res.url\n    this.body = body\n    this.pkgid = spec ? spec.toString() : packageName(res.url)\n  }\n}\nmodule.exports.HttpErrorBase = HttpErrorBase\n\nclass HttpErrorGeneral extends HttpErrorBase {\n  constructor (method, res, body, spec) {\n    super(method, res, body, spec)\n    this.message = `${res.status} ${res.statusText} - ${\n      this.method.toUpperCase()\n    } ${\n      this.spec || this.uri\n    }${\n      (body && body.error) ? ' - ' + body.error : ''\n    }`\n    Error.captureStackTrace(this, HttpErrorGeneral)\n  }\n}\nmodule.exports.HttpErrorGeneral = HttpErrorGeneral\n\nclass HttpErrorAuthOTP extends HttpErrorBase {\n  constructor (method, res, body, spec) {\n    super(method, res, body, spec)\n    this.message = 'OTP required for authentication'\n    this.code = 'EOTP'\n    Error.captureStackTrace(this, HttpErrorAuthOTP)\n  }\n}\nmodule.exports.HttpErrorAuthOTP = HttpErrorAuthOTP\n\nclass HttpErrorAuthIPAddress extends HttpErrorBase {\n  constructor (method, res, body, spec) {\n    super(method, res, body, spec)\n    this.message = 'Login is not allowed from your IP address'\n    this.code = 'EAUTHIP'\n    Error.captureStackTrace(this, HttpErrorAuthIPAddress)\n  }\n}\nmodule.exports.HttpErrorAuthIPAddress = HttpErrorAuthIPAddress\n\nclass HttpErrorAuthUnknown extends HttpErrorBase {\n  constructor (method, res, body, spec) {\n    super(method, res, body, spec)\n    this.message = 'Unable to authenticate, need: ' + res.headers.get('www-authenticate')\n    Error.captureStackTrace(this, HttpErrorAuthUnknown)\n  }\n}\nmodule.exports.HttpErrorAuthUnknown = HttpErrorAuthUnknown\n","\n\nconst errors = require('./errors.js')\nconst { Response } = require('minipass-fetch')\nconst defaultOpts = require('./default-opts.js')\nconst log = require('proc-log')\n\n/* eslint-disable-next-line max-len */\nconst moreInfoUrl = 'https://github.com/npm/cli/wiki/No-auth-for-URI,-but-auth-present-for-scoped-registry'\nconst checkResponse =\n  async ({ method, uri, res, startTime, auth, opts }) => {\n    opts = { ...defaultOpts, ...opts }\n    if (res.headers.has('npm-notice') && !res.headers.has('x-local-cache')) {\n      log.notice('', res.headers.get('npm-notice'))\n    }\n\n    if (res.status >= 400) {\n      logRequest(method, res, startTime)\n      if (auth && auth.scopeAuthKey && !auth.token && !auth.auth) {\n      // we didn't have auth for THIS request, but we do have auth for\n      // requests to the registry indicated by the spec's scope value.\n      // Warn the user.\n        log.warn('registry', `No auth for URI, but auth present for scoped registry.\n\nURI: ${uri}\nScoped Registry Key: ${auth.scopeAuthKey}\n\nMore info here: ${moreInfoUrl}`)\n      }\n      return checkErrors(method, res, startTime, opts)\n    } else {\n      res.body.on('end', () => logRequest(method, res, startTime, opts))\n      if (opts.ignoreBody) {\n        res.body.resume()\n        return new Response(null, res)\n      }\n      return res\n    }\n  }\nmodule.exports = checkResponse\n\nfunction logRequest (method, res, startTime) {\n  const elapsedTime = Date.now() - startTime\n  const attempt = res.headers.get('x-fetch-attempts')\n  const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : ''\n  const cacheStatus = res.headers.get('x-local-cache-status')\n  const cacheStr = cacheStatus ? ` (cache ${cacheStatus})` : ''\n\n  let urlStr\n  try {\n    const { URL } = require('url')\n    const url = new URL(res.url)\n    if (url.password) {\n      url.password = '***'\n    }\n\n    urlStr = url.toString()\n  } catch (er) {\n    urlStr = res.url\n  }\n\n  log.http(\n    'fetch',\n    `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`\n  )\n}\n\nfunction checkErrors (method, res, startTime, opts) {\n  return res.buffer()\n    .catch(() => null)\n    .then(body => {\n      let parsed = body\n      try {\n        parsed = JSON.parse(body.toString('utf8'))\n      } catch (e) {}\n      if (res.status === 401 && res.headers.get('www-authenticate')) {\n        const auth = res.headers.get('www-authenticate')\n          .split(/,\\s*/)\n          .map(s => s.toLowerCase())\n        if (auth.indexOf('ipaddress') !== -1) {\n          throw new errors.HttpErrorAuthIPAddress(\n            method, res, parsed, opts.spec\n          )\n        } else if (auth.indexOf('otp') !== -1) {\n          throw new errors.HttpErrorAuthOTP(\n            method, res, parsed, opts.spec\n          )\n        } else {\n          throw new errors.HttpErrorAuthUnknown(\n            method, res, parsed, opts.spec\n          )\n        }\n      } else if (\n        res.status === 401 &&\n        body != null &&\n        /one-time pass/.test(body.toString('utf8'))\n      ) {\n        // Heuristic for malformed OTP responses that don't include the\n        // www-authenticate header.\n        throw new errors.HttpErrorAuthOTP(\n          method, res, parsed, opts.spec\n        )\n      } else {\n        throw new errors.HttpErrorGeneral(\n          method, res, parsed, opts.spec\n        )\n      }\n    })\n}\n","const pkg = require('../package.json')\nmodule.exports = {\n  maxSockets: 12,\n  method: 'GET',\n  registry: 'https://registry.npmjs.org/',\n  timeout: 5 * 60 * 1000, // 5 minutes\n  strictSSL: true,\n  noProxy: process.env.NOPROXY,\n  userAgent: `${pkg.name\n    }@${\n      pkg.version\n    }/node@${\n      process.version\n    }+${\n      process.arch\n    } (${\n      process.platform\n    })`,\n}\n","module.exports = {\n  \"name\": \"npm-registry-fetch\",\n  \"version\": \"13.0.1\",\n  \"description\": \"Fetch-based http client for use with npm registry APIs\",\n  \"main\": \"lib\",\n  \"files\": [\n    \"bin\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"eslint\": \"eslint\",\n    \"lint\": \"eslint '**/*.js'\",\n    \"lintfix\": \"npm run lint -- --fix\",\n    \"prepublishOnly\": \"git push origin --follow-tags\",\n    \"preversion\": \"npm test\",\n    \"postversion\": \"npm publish\",\n    \"test\": \"tap\",\n    \"posttest\": \"npm run lint\",\n    \"npmclilint\": \"npmcli-lint\",\n    \"postsnap\": \"npm run lintfix --\",\n    \"postlint\": \"npm-template-check\",\n    \"snap\": \"tap\",\n    \"template-copy\": \"npm-template-copy --force\"\n  },\n  \"repository\": \"https://github.com/npm/npm-registry-fetch\",\n  \"keywords\": [\n    \"npm\",\n    \"registry\",\n    \"fetch\"\n  ],\n  \"author\": \"GitHub Inc.\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"make-fetch-happen\": \"^10.0.3\",\n    \"minipass\": \"^3.1.6\",\n    \"minipass-fetch\": \"^2.0.1\",\n    \"minipass-json-stream\": \"^1.0.1\",\n    \"minizlib\": \"^2.1.2\",\n    \"npm-package-arg\": \"^9.0.0\",\n    \"proc-log\": \"^2.0.0\"\n  },\n  \"devDependencies\": {\n    \"@npmcli/template-oss\": \"^2.8.1\",\n    \"cacache\": \"^15.3.0\",\n    \"nock\": \"^13.2.4\",\n    \"require-inject\": \"^1.4.4\",\n    \"ssri\": \"^8.0.1\",\n    \"tap\": \"^15.1.6\"\n  },\n  \"tap\": {\n    \"check-coverage\": true,\n    \"test-ignore\": \"test[\\\\\\\\/](util|cache)[\\\\\\\\/]\"\n  },\n  \"engines\": {\n    \"node\": \"^12.13.0 || ^14.15.0 || >=16\"\n  },\n  \"templateOSS\": {\n    \"version\": \"2.8.1\"\n  }\n}\n","\nconst npa = require('npm-package-arg')\nconst { URL } = require('url')\n\n// Find the longest registry key that is used for some kind of auth\n// in the options.\nconst regKeyFromURI = (uri, opts) => {\n  const parsed = new URL(uri)\n  // try to find a config key indicating we have auth for this registry\n  // can be one of :_authToken, :_auth, or :_password and :username\n  // We walk up the \"path\" until we're left with just //<host>[:<port>],\n  // stopping when we reach '//'.\n  let regKey = `//${parsed.host}${parsed.pathname}`\n  while (regKey.length > '//'.length) {\n    // got some auth for this URI\n    if (hasAuth(regKey, opts)) {\n      return regKey\n    }\n\n    // can be either //host/some/path/:_auth or //host/some/path:_auth\n    // walk up by removing EITHER what's after the slash OR the slash itself\n    regKey = regKey.replace(/([^/]+|\\/)$/, '')\n  }\n}\n\nconst hasAuth = (regKey, opts) => (\n  opts[`${regKey}:_authToken`] ||\n  opts[`${regKey}:_auth`] ||\n  opts[`${regKey}:username`] && opts[`${regKey}:_password`]\n)\n\nconst sameHost = (a, b) => {\n  const parsedA = new URL(a)\n  const parsedB = new URL(b)\n  return parsedA.host === parsedB.host\n}\n\nconst getRegistry = opts => {\n  const { spec } = opts\n  const { scope: specScope, subSpec } = spec ? npa(spec) : {}\n  const subSpecScope = subSpec && subSpec.scope\n  const scope = subSpec ? subSpecScope : specScope\n  const scopeReg = scope && opts[`${scope}:registry`]\n  return scopeReg || opts.registry\n}\n\nconst getAuth = (uri, opts = {}) => {\n  const { forceAuth } = opts\n  if (!uri) {\n    throw new Error('URI is required')\n  }\n  const regKey = regKeyFromURI(uri, forceAuth || opts)\n\n  // we are only allowed to use what's in forceAuth if specified\n  if (forceAuth && !regKey) {\n    return new Auth({\n      scopeAuthKey: null,\n      token: forceAuth._authToken || forceAuth.token,\n      username: forceAuth.username,\n      password: forceAuth._password || forceAuth.password,\n      auth: forceAuth._auth || forceAuth.auth,\n    })\n  }\n\n  // no auth for this URI, but might have it for the registry\n  if (!regKey) {\n    const registry = getRegistry(opts)\n    if (registry && uri !== registry && sameHost(uri, registry)) {\n      return getAuth(registry, opts)\n    } else if (registry !== opts.registry) {\n      // If making a tarball request to a different base URI than the\n      // registry where we logged in, but the same auth SHOULD be sent\n      // to that artifact host, then we track where it was coming in from,\n      // and warn the user if we get a 4xx error on it.\n      const scopeAuthKey = regKeyFromURI(registry, opts)\n      return new Auth({ scopeAuthKey })\n    }\n  }\n\n  const {\n    [`${regKey}:_authToken`]: token,\n    [`${regKey}:username`]: username,\n    [`${regKey}:_password`]: password,\n    [`${regKey}:_auth`]: auth,\n  } = opts\n\n  return new Auth({\n    scopeAuthKey: null,\n    token,\n    auth,\n    username,\n    password,\n  })\n}\n\nclass Auth {\n  constructor ({ token, auth, username, password, scopeAuthKey }) {\n    this.scopeAuthKey = scopeAuthKey\n    this.token = null\n    this.auth = null\n    this.isBasicAuth = false\n    if (token) {\n      this.token = token\n    } else if (auth) {\n      this.auth = auth\n    } else if (username && password) {\n      const p = Buffer.from(password, 'base64').toString('utf8')\n      this.auth = Buffer.from(`${username}:${p}`, 'utf8').toString('base64')\n      this.isBasicAuth = true\n    }\n  }\n}\n\nmodule.exports = getAuth\n"]}