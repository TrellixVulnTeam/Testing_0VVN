{"version":3,"sources":["index.js","read-json.js","version.js","retrieve-tag.js","enforce-clean.js","write-json.js","commit.js","tag.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,AENA,ADGA;AFOA,ACHA,AENA,ADGA;AFOA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA;AELA,AJYA,AGTA,ADGA,AGTA;ADIA,AJYA,AGTA,ADGA,AGTA;ADIA,AJYA,AGTA,ADGA,AGTA;ACFA,AFMA,AJYA,AGTA,ADGA,AGTA;ACFA,AFMA,AJYA,AGTA,ADGA,AGTA;ACFA,AFMA,AJYA,AGTA,ADGA,AGTA;ACFA,AFMA,AJYA,AGTA,AIZA,ALeA,AGTA;ACFA,AFMA,AJYA,AGTA,AIZA,ALeA,AGTA;ACFA,AFMA,AJYA,AOrBA,ALeA,AGTA;ACFA,AFMA,AJYA,AOrBA,ALeA,AGTA;ACFA,AFMA,AJYA,AOrBA,ALeA,AGTA;ACFA,AFMA,AJYA,AOrBA,ALeA,AGTA;ACFA,AFMA,AJYA,AOrBA,ALeA,AGTA;ACFA,AFMA,AJYA,AOrBA,ALeA,AGTA;ACFA,AFMA,AJYA,AOrBA,ALeA,AGTA;ACFA,AFMA,AJYA,AOrBA,ALeA,AGTA;ACFA,AFMA,AJYA,AOrBA,ALeA,AGTA;ACFA,AFMA,AJYA,AOrBA,ALeA;AIXA,AFMA,AJYA,AOrBA,ALeA;AIXA,AFMA,AJYA,AOrBA,ALeA;AIXA,AFMA,AJYA,AOrBA,ALeA;AELA,AJYA,AOrBA,ALeA;AELA,AJYA,AOrBA,ALeA;AELA,AJYA,AOrBA,ALeA;AELA,AJYA,AOrBA,ALeA;AELA,AJYA,AOrBA,ALeA;AELA,AGTA,ALeA;AELA,AGTA,ALeA;AELA,AGTA,ALeA;AELA,AGTA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AKdA,ALeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const readJson = require('./read-json.js')\nconst version = require('./version.js')\n\nmodule.exports = async (newversion, opts = {}) => {\n  const {\n    path = process.cwd(),\n    allowSameVersion = false,\n    tagVersionPrefix = 'v',\n    commitHooks = true,\n    gitTagVersion = true,\n    signGitCommit = false,\n    signGitTag = false,\n    force = false,\n    ignoreScripts = false,\n    scriptShell = undefined,\n    preid = null,\n    message = 'v%s',\n    silent,\n  } = opts\n\n  const pkg = opts.pkg || await readJson(path + '/package.json')\n\n  return version(newversion, {\n    path,\n    cwd: path,\n    allowSameVersion,\n    tagVersionPrefix,\n    commitHooks,\n    gitTagVersion,\n    signGitCommit,\n    signGitTag,\n    force,\n    ignoreScripts,\n    scriptShell,\n    preid,\n    pkg,\n    message,\n    silent,\n  })\n}\n","// can't use read-package-json-fast, because we want to ensure\n// that we make as few changes as possible, even for safety issues.\nconst { promisify } = require('util')\nconst readFile = promisify(require('fs').readFile)\nconst parse = require('json-parse-even-better-errors')\n\nmodule.exports = async path => parse(await readFile(path))\n","// called with all the options already set to their defaults\n\nconst retrieveTag = require('./retrieve-tag.js')\nconst semver = require('semver')\nconst enforceClean = require('./enforce-clean.js')\nconst writeJson = require('./write-json.js')\nconst readJson = require('./read-json.js')\nconst git = require('@npmcli/git')\nconst commit = require('./commit.js')\nconst tag = require('./tag.js')\nconst log = require('proc-log')\n\nconst runScript = require('@npmcli/run-script')\n\nmodule.exports = async (newversion, opts) => {\n  const {\n    path,\n    allowSameVersion,\n    gitTagVersion,\n    ignoreScripts,\n    preid,\n    pkg,\n    silent,\n  } = opts\n\n  const { valid, clean, inc } = semver\n  const current = pkg.version || '0.0.0'\n  const currentClean = clean(current)\n\n  let newV\n  if (valid(newversion, { loose: true })) {\n    newV = clean(newversion, { loose: true })\n  } else if (newversion === 'from-git') {\n    newV = await retrieveTag(opts)\n  } else {\n    newV = inc(currentClean, newversion, { loose: true }, preid)\n  }\n\n  if (!newV) {\n    throw Object.assign(new Error('Invalid version: ' + newversion), {\n      current,\n      requested: newversion,\n    })\n  }\n\n  if (newV === currentClean && !allowSameVersion) {\n    throw Object.assign(new Error('Version not changed'), {\n      current,\n      requested: newversion,\n      newVersion: newV,\n    })\n  }\n\n  const isGitDir = newversion === 'from-git' || await git.is(opts)\n\n  // ok!  now we know the new version, and the old version is in pkg\n\n  // - check if git dir is clean\n  // returns false if we should not keep doing git stuff\n  const doGit = gitTagVersion && isGitDir && await enforceClean(opts)\n\n  if (!ignoreScripts) {\n    await runScript({\n      ...opts,\n      pkg,\n      stdio: 'inherit',\n      event: 'preversion',\n      banner: !silent,\n      env: {\n        npm_old_version: current,\n        npm_new_version: newV,\n      },\n    })\n  }\n\n  // - update the files\n  pkg.version = newV\n  delete pkg._id\n  await writeJson(`${path}/package.json`, pkg)\n\n  // try to update shrinkwrap, but ok if this fails\n  const locks = [`${path}/package-lock.json`, `${path}/npm-shrinkwrap.json`]\n  const haveLocks = []\n  for (const lock of locks) {\n    try {\n      const sw = await readJson(lock)\n      sw.version = newV\n      if (sw.packages && sw.packages['']) {\n        sw.packages[''].version = newV\n      }\n      await writeJson(lock, sw)\n      haveLocks.push(lock)\n    } catch (er) {}\n  }\n\n  if (!ignoreScripts) {\n    await runScript({\n      ...opts,\n      pkg,\n      stdio: 'inherit',\n      event: 'version',\n      banner: !silent,\n      env: {\n        npm_old_version: current,\n        npm_new_version: newV,\n      },\n    })\n  }\n\n  if (doGit) {\n    // - git add, git commit, git tag\n    await git.spawn(['add', `${path}/package.json`], opts)\n    // sometimes people .gitignore their lockfiles\n    for (const lock of haveLocks) {\n      await git.spawn(['add', lock], opts).catch(() => {})\n    }\n    await commit(newV, opts)\n    await tag(newV, opts)\n  } else {\n    log.verbose('version', 'Not tagging: not in a git repo or no git cmd')\n  }\n\n  if (!ignoreScripts) {\n    await runScript({\n      ...opts,\n      pkg,\n      stdio: 'inherit',\n      event: 'postversion',\n      banner: !silent,\n      env: {\n        npm_old_version: current,\n        npm_new_version: newV,\n      },\n    })\n  }\n\n  return newV\n}\n","const { spawn } = require('@npmcli/git')\nconst semver = require('semver')\n\nmodule.exports = async opts => {\n  const tag = (await spawn(\n    ['describe', '--tags', '--abbrev=0', '--match=*.*.*'],\n    opts)).stdout.trim()\n  const ver = semver.coerce(tag, { loose: true })\n  if (ver) {\n    return ver.version\n  }\n  throw new Error(`Tag is not a valid version: ${JSON.stringify(tag)}`)\n}\n","const git = require('@npmcli/git')\nconst log = require('proc-log')\n\n// returns true if it's cool to do git stuff\n// throws if it's unclean, and not forced.\nmodule.exports = async opts => {\n  const { force } = opts\n  let hadError = false\n  const clean = await git.isClean(opts).catch(er => {\n    if (er.code === 'ENOGIT') {\n      log.warn(\n        'version',\n        'This is a Git checkout, but the git command was not found.',\n        'npm could not create a Git tag for this release!'\n      )\n      hadError = true\n      // how can merges be real if our git isn't real?\n      return true\n    } else {\n      throw er\n    }\n  })\n\n  if (!clean) {\n    if (!force) {\n      throw new Error('Git working directory not clean.')\n    }\n    log.warn('version', 'Git working directory not clean, proceeding forcefully.')\n  }\n\n  return !hadError\n}\n","// write the json back, preserving the line breaks and indent\nconst { promisify } = require('util')\nconst writeFile = promisify(require('fs').writeFile)\nconst kIndent = Symbol.for('indent')\nconst kNewline = Symbol.for('newline')\n\nmodule.exports = async (path, pkg) => {\n  const {\n    [kIndent]: indent = 2,\n    [kNewline]: newline = '\\n',\n  } = pkg\n  delete pkg._id\n  const raw = JSON.stringify(pkg, null, indent) + '\\n'\n  const data = newline === '\\n' ? raw : raw.split('\\n').join(newline)\n  return writeFile(path, data)\n}\n","const git = require('@npmcli/git')\n\nmodule.exports = (version, opts) => {\n  const { commitHooks, allowSameVersion, signGitCommit, message } = opts\n  const args = ['commit']\n  if (commitHooks === false) {\n    args.push('-n')\n  }\n  if (allowSameVersion) {\n    args.push('--allow-empty')\n  }\n  if (signGitCommit) {\n    args.push('-S')\n  }\n  args.push('-m')\n  return git.spawn([...args, message.replace(/%s/g, version)], opts)\n}\n","const git = require('@npmcli/git')\n\nmodule.exports = async (version, opts) => {\n  const {\n    signGitTag,\n    allowSameVersion,\n    tagVersionPrefix,\n    message,\n  } = opts\n\n  const tag = `${tagVersionPrefix}${version}`\n  const flags = ['-']\n\n  if (signGitTag) {\n    flags.push('s')\n  }\n\n  if (allowSameVersion) {\n    flags.push('f')\n  }\n\n  flags.push('m')\n\n  return git.spawn([\n    'tag',\n    flags.join(''),\n    message.replace(/%s/g, version),\n    tag,\n  ], opts)\n}\n"]}