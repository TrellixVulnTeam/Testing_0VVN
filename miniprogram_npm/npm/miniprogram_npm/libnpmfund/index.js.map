{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst URL = require('url').URL\nconst Arborist = require('@npmcli/arborist')\n\n// supports object funding and string shorthand, or an array of these\n// if original was an array, returns an array; else returns the lone item\nfunction normalizeFunding (funding) {\n  const normalizeItem = item =>\n    typeof item === 'string' ? { url: item } : item\n  const sources = [].concat(funding || []).map(normalizeItem)\n  return Array.isArray(funding) ? sources : sources[0]\n}\n\n// Is the value of a `funding` property of a `package.json`\n// a valid type+url for `npm fund` to display?\nfunction isValidFunding (funding) {\n  if (!funding) {\n    return false\n  }\n\n  if (Array.isArray(funding)) {\n    return funding.every(f => !Array.isArray(f) && isValidFunding(f))\n  }\n\n  try {\n    var parsed = new URL(funding.url || funding)\n  } catch (error) {\n    return false\n  }\n\n  if (\n    parsed.protocol !== 'https:' &&\n    parsed.protocol !== 'http:'\n  ) {\n    return false\n  }\n\n  return Boolean(parsed.host)\n}\n\nconst empty = () => Object.create(null)\n\nfunction readTree (tree, opts) {\n  let packageWithFundingCount = 0\n  const seen = new Set()\n  const { countOnly } = opts || {}\n  const _trailingDependencies = Symbol('trailingDependencies')\n\n  let filterSet\n\n  if (opts && opts.workspaces && opts.workspaces.length) {\n    const arb = new Arborist(opts)\n    filterSet = arb.workspaceDependencySet(tree, opts.workspaces)\n  }\n\n  function tracked (name, version) {\n    const key = String(name) + String(version)\n    if (seen.has(key)) {\n      return true\n    }\n\n    seen.add(key)\n  }\n\n  function retrieveDependencies (dependencies) {\n    const trailing = dependencies[_trailingDependencies]\n\n    if (trailing) {\n      return Object.assign(\n        empty(),\n        dependencies,\n        trailing\n      )\n    }\n\n    return dependencies\n  }\n\n  function hasDependencies (dependencies) {\n    return dependencies && (\n      Object.keys(dependencies).length ||\n      dependencies[_trailingDependencies]\n    )\n  }\n\n  function attachFundingInfo (target, funding) {\n    if (funding && isValidFunding(funding)) {\n      target.funding = normalizeFunding(funding)\n      packageWithFundingCount++\n    }\n  }\n\n  function getFundingDependencies (tree) {\n    const edges = tree && tree.edgesOut && tree.edgesOut.values()\n    if (!edges) {\n      return empty()\n    }\n\n    const directDepsWithFunding = Array.from(edges).map(edge => {\n      if (!edge || !edge.to) {\n        return empty()\n      }\n\n      const node = edge.to.target || edge.to\n      if (!node.package) {\n        return empty()\n      }\n\n      if (filterSet && filterSet.size > 0 && !filterSet.has(node)) {\n        return empty()\n      }\n\n      const { name, funding, version } = node.package\n\n      // avoids duplicated items within the funding tree\n      if (tracked(name, version)) {\n        return empty()\n      }\n\n      const fundingItem = {}\n\n      if (version) {\n        fundingItem.version = version\n      }\n\n      attachFundingInfo(fundingItem, funding)\n\n      return {\n        node,\n        fundingItem,\n      }\n    })\n\n    return directDepsWithFunding.reduce(\n      (res, { node, fundingItem }, i) => {\n        if (!fundingItem ||\n          fundingItem.length === 0 ||\n          !node) {\n          return res\n        }\n\n        // recurse\n        const transitiveDependencies = node.edgesOut &&\n          node.edgesOut.size > 0 &&\n          getFundingDependencies(node)\n\n        // if we're only counting items there's no need\n        // to add all the data to the resulting object\n        if (countOnly) {\n          return null\n        }\n\n        if (hasDependencies(transitiveDependencies)) {\n          fundingItem.dependencies =\n            retrieveDependencies(transitiveDependencies)\n        }\n\n        if (isValidFunding(fundingItem.funding)) {\n          res[node.package.name] = fundingItem\n        } else if (hasDependencies(fundingItem.dependencies)) {\n          res[_trailingDependencies] =\n            Object.assign(\n              empty(),\n              res[_trailingDependencies],\n              fundingItem.dependencies\n            )\n        }\n\n        return res\n      }, countOnly ? null : empty())\n  }\n\n  const treeDependencies = getFundingDependencies(tree)\n  const result = {\n    length: packageWithFundingCount,\n  }\n\n  if (!countOnly) {\n    const name =\n      (tree && tree.package && tree.package.name) ||\n      (tree && tree.name)\n    result.name = name || (tree && tree.path)\n\n    if (tree && tree.package && tree.package.version) {\n      result.version = tree.package.version\n    }\n\n    if (tree && tree.package && tree.package.funding) {\n      result.funding = normalizeFunding(tree.package.funding)\n    }\n\n    result.dependencies = retrieveDependencies(treeDependencies)\n  }\n\n  return result\n}\n\nasync function read (opts) {\n  const arb = new Arborist(opts)\n  const tree = await arb.loadActual(opts)\n  return readTree(tree, opts)\n}\n\nmodule.exports = {\n  read,\n  readTree,\n  normalizeFunding,\n  isValidFunding,\n}\n"]}