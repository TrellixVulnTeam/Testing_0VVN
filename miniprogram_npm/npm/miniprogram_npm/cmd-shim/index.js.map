{"version":3,"sources":["index.js","lib/to-batch-syntax.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// On windows, create a .cmd file.\n// Read the #! in the file to see what it uses.  The vast majority\n// of the time, this will be either:\n// \"#!/usr/bin/env <prog> <args...>\"\n// or:\n// \"#!<prog> <args...>\"\n//\n// Write a binroot/pkg.bin + \".cmd\" file that has this line in it:\n// @<prog> <args...> %dp0%<target> %*\n\nconst {promisify} = require('util')\nconst fs = require('fs')\nconst writeFile = promisify(fs.writeFile)\nconst readFile = promisify(fs.readFile)\nconst chmod = promisify(fs.chmod)\nconst stat = promisify(fs.stat)\nconst unlink = promisify(fs.unlink)\n\nconst {dirname, relative} = require('path')\nconst mkdir = require('mkdirp-infer-owner')\nconst toBatchSyntax = require('./lib/to-batch-syntax')\nconst shebangExpr = /^#\\!\\s*(?:\\/usr\\/bin\\/env)?\\s*([^ \\t]+=[^ \\t]+\\s+)*\\s*([^ \\t]+)(.*)$/\n\nconst cmdShimIfExists = (from, to) =>\n  stat(from).then(() => cmdShim(from, to), () => {})\n\n// Try to unlink, but ignore errors.\n// Any problems will surface later.\nconst rm = path => unlink(path).catch(() => {})\n\nconst cmdShim = (from, to) =>\n  stat(from).then(() => cmdShim_(from, to))\n\nconst cmdShim_ = (from, to) => Promise.all([\n  rm(to),\n  rm(to + '.cmd'),\n  rm(to + '.ps1'),\n]).then(() => writeShim(from, to))\n\nconst writeShim = (from, to) =>\n  // make a cmd file and a sh script\n  // First, check if the bin is a #! of some sort.\n  // If not, then assume it's something that'll be compiled, or some other\n  // sort of script, and just call it directly.\n  mkdir(dirname(to))\n    .then(() => readFile(from, 'utf8'))\n    .then(data => {\n      const firstLine = data.trim().split(/\\r*\\n/)[0]\n      const shebang = firstLine.match(shebangExpr)\n      if (!shebang) return writeShim_(from, to)\n      const vars = shebang[1] || ''\n      const prog = shebang[2]\n      const args = shebang[3] || ''\n      return writeShim_(from, to, prog, args, vars)\n    }, er => writeShim_(from, to))\n\n\nconst writeShim_ = (from, to, prog, args, variables) => {\n  let shTarget = relative(dirname(to), from)\n  let target = shTarget.split('/').join('\\\\')\n  let longProg\n  let shProg = prog && prog.split('\\\\').join('/')\n  let shLongProg\n  let pwshProg = shProg && `\"${shProg}$exe\"`\n  let pwshLongProg\n  shTarget = shTarget.split('\\\\').join('/')\n  args = args || ''\n  variables = variables || ''\n  if (!prog) {\n    prog = `\"%dp0%\\\\${target}\"`\n    shProg = `\"$basedir/${shTarget}\"`\n    pwshProg = shProg\n    args = ''\n    target = ''\n    shTarget = ''\n  } else {\n    longProg = `\"%dp0%\\\\${prog}.exe\"`\n    shLongProg = `\"$basedir/${prog}\"`\n    pwshLongProg = `\"$basedir/${prog}$exe\"`\n    target = `\"%dp0%\\\\${target}\"`\n    shTarget = `\"$basedir/${shTarget}\"`\n  }\n\n  // Subroutine trick to fix https://github.com/npm/cmd-shim/issues/10\n  // and https://github.com/npm/cli/issues/969\n  const head = '@ECHO off\\r\\n' +\n    'GOTO start\\r\\n' +\n    ':find_dp0\\r\\n' +\n    'SET dp0=%~dp0\\r\\n' +\n    'EXIT /b\\r\\n' +\n    ':start\\r\\n' +\n    'SETLOCAL\\r\\n' +\n    'CALL :find_dp0\\r\\n'\n\n  let cmd\n  if (longProg) {\n    shLongProg = shLongProg.trim();\n    args = args.trim();\n    const variablesBatch = toBatchSyntax.convertToSetCommands(variables)\n    cmd = head\n        + variablesBatch\n        + '\\r\\n'\n        + `IF EXIST ${longProg} (\\r\\n`\n        + `  SET \"_prog=${longProg.replace(/(^\")|(\"$)/g, '')}\"\\r\\n`\n        + ') ELSE (\\r\\n'\n        + `  SET \"_prog=${prog.replace(/(^\")|(\"$)/g, '')}\"\\r\\n`\n        + '  SET PATHEXT=%PATHEXT:;.JS;=;%\\r\\n'\n        + ')\\r\\n'\n        + '\\r\\n'\n        // prevent \"Terminate Batch Job? (Y/n)\" message\n        // https://github.com/npm/cli/issues/969#issuecomment-737496588\n        + 'endLocal & goto #_undefined_# 2>NUL || title %COMSPEC% & '\n        +  `\"%_prog%\" ${args} ${target} %*\\r\\n`\n  } else {\n    cmd = `${head}${prog} ${args} ${target} %*\\r\\n`\n  }\n\n  // #!/bin/sh\n  // basedir=`dirname \"$0\"`\n  //\n  // case `uname` in\n  //     *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;;\n  // esac\n  //\n  // if [ -x \"$basedir/node.exe\" ]; then\n  //   exec \"$basedir/node.exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // else\n  //   exec node \"$basedir/node_modules/npm/bin/npm-cli.js\" \"$@\"\n  // fi\n\n  let sh = \"#!/bin/sh\\n\"\n\n  sh = sh\n      + `basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\\\\\,/,g')\")\\n`\n      + '\\n'\n      + 'case `uname` in\\n'\n      + '    *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;;\\n'\n      + 'esac\\n'\n      + '\\n'\n\n  if (shLongProg) {\n    sh = sh\n       + `if [ -x ${shLongProg} ]; then\\n`\n       + `  exec ${variables}${shLongProg} ${args} ${shTarget} \"$@\"\\n`\n       + 'else \\n'\n       + `  exec ${variables}${shProg} ${args} ${shTarget} \"$@\"\\n`\n       + 'fi\\n'\n  } else {\n    sh = sh\n       + `exec ${shProg} ${args} ${shTarget} \"$@\"\\n`\n  }\n\n  // #!/usr/bin/env pwsh\n  // $basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\n  //\n  // $ret=0\n  // $exe = \"\"\n  // if ($PSVersionTable.PSVersion -lt \"6.0\" -or $IsWindows) {\n  //   # Fix case when both the Windows and Linux builds of Node\n  //   # are installed in the same directory\n  //   $exe = \".exe\"\n  // }\n  // if (Test-Path \"$basedir/node\") {\n  //   # Suport pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     input | & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"$basedir/node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // } else {\n  //   # Support pipeline input\n  //   if ($MyInvocation.ExpectingInput) {\n  //     $input | & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   } else {\n  //     & \"node$exe\" \"$basedir/node_modules/npm/bin/npm-cli.js\" $args\n  //   }\n  //   $ret=$LASTEXITCODE\n  // }\n  // exit $ret\n  let pwsh = '#!/usr/bin/env pwsh\\n'\n           + '$basedir=Split-Path $MyInvocation.MyCommand.Definition -Parent\\n'\n           + '\\n'\n           + '$exe=\"\"\\n'\n           + 'if ($PSVersionTable.PSVersion -lt \\\"6.0\\\" -or $IsWindows) {\\n'\n           + '  # Fix case when both the Windows and Linux builds of Node\\n'\n           + '  # are installed in the same directory\\n'\n           + '  $exe=\".exe\"\\n'\n           + '}\\n'\n  if (shLongProg) {\n    pwsh = pwsh\n         + '$ret=0\\n'\n         + `if (Test-Path ${pwshLongProg}) {\\n`\n         + '  # Support pipeline input\\n'\n         + '  if ($MyInvocation.ExpectingInput) {\\n'\n         + `    $input | & ${pwshLongProg} ${args} ${shTarget} $args\\n`\n         + '  } else {\\n'\n         + `    & ${pwshLongProg} ${args} ${shTarget} $args\\n`\n         + '  }\\n'\n         + '  $ret=$LASTEXITCODE\\n'\n         + '} else {\\n'\n         + '  # Support pipeline input\\n'\n         + '  if ($MyInvocation.ExpectingInput) {\\n'\n         + `    $input | & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '  } else {\\n'\n         + `    & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '  }\\n'\n         + '  $ret=$LASTEXITCODE\\n'\n         + '}\\n'\n         + 'exit $ret\\n'\n  } else {\n    pwsh = pwsh\n         + '# Support pipeline input\\n'\n         + 'if ($MyInvocation.ExpectingInput) {\\n'\n         + `  $input | & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '} else {\\n'\n         + `  & ${pwshProg} ${args} ${shTarget} $args\\n`\n         + '}\\n'\n         + 'exit $LASTEXITCODE\\n'\n  }\n\n  return Promise.all([\n    writeFile(to + '.ps1', pwsh, 'utf8'),\n    writeFile(to + '.cmd', cmd, 'utf8'),\n    writeFile(to, sh, 'utf8'),\n  ]).then(() => chmodShim(to))\n}\n\nconst chmodShim = to => Promise.all([\n  chmod(to, 0o755),\n  chmod(to + '.cmd', 0o755),\n  chmod(to + '.ps1', 0o755),\n])\n\nmodule.exports = cmdShim\ncmdShim.ifExists = cmdShimIfExists\n","exports.replaceDollarWithPercentPair = replaceDollarWithPercentPair\r\nexports.convertToSetCommand = convertToSetCommand\r\nexports.convertToSetCommands = convertToSetCommands\r\n\r\nfunction convertToSetCommand(key, value) {\r\n    var line = \"\"\r\n    key = key || \"\"\r\n    key = key.trim()\r\n    value = value || \"\"\r\n    value = value.trim()\r\n    if(key && value && value.length > 0) {\r\n        line = \"@SET \" + key + \"=\" + replaceDollarWithPercentPair(value) + \"\\r\\n\"\r\n    }\r\n    return line\r\n}\r\n\r\nfunction extractVariableValuePairs(declarations) {\r\n    var pairs = {}\r\n    declarations.map(function(declaration) {\r\n        var split = declaration.split(\"=\")\r\n        pairs[split[0]]=split[1]\r\n    })\r\n    return pairs\r\n}\r\n\r\nfunction convertToSetCommands(variableString) {\r\n    var variableValuePairs = extractVariableValuePairs(variableString.split(\" \"))\r\n    var variableDeclarationsAsBatch = \"\"\r\n    Object.keys(variableValuePairs).forEach(function (key) {\r\n        variableDeclarationsAsBatch += convertToSetCommand(key, variableValuePairs[key])\r\n    })\r\n    return variableDeclarationsAsBatch\r\n}\r\n\r\nfunction replaceDollarWithPercentPair(value) {\r\n    var dollarExpressions = /\\$\\{?([^\\$@#\\?\\- \\t{}:]+)\\}?/g\r\n    var result = \"\"\r\n    var startIndex = 0\r\n    do {\r\n        var match = dollarExpressions.exec(value)\r\n        if(match) {\r\n            var betweenMatches = value.substring(startIndex, match.index) || \"\"\r\n            result +=  betweenMatches + \"%\" + match[1] + \"%\"\r\n            startIndex = dollarExpressions.lastIndex\r\n        }\r\n    } while (dollarExpressions.lastIndex > 0)\r\n    result += value.substr(startIndex)\r\n    return result\r\n}\r\n\r\n\r\n"]}