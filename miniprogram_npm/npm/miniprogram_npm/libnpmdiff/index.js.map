{"version":3,"sources":["index.js","format-diff.js","should-print-patch.js","tarball.js","untar.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AENA,ACHA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AGTA,ACHA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,ADGA,AIZA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const pacote = require('pacote')\n\nconst formatDiff = require('./format-diff.js')\nconst getTarball = require('./tarball.js')\nconst untar = require('./untar.js')\n\n// TODO: we test this condition in the diff command\n// so this error probably doesnt need to be here. Or\n// if it does we should figure out a standard code\n// so we can catch it in the cli and display it consistently\nconst argsError = () =>\n  Object.assign(\n    new TypeError('libnpmdiff needs two arguments to compare'),\n    { code: 'EDIFFARGS' }\n  )\nconst diff = async (specs, opts = {}) => {\n  if (specs.length !== 2) {\n    throw argsError()\n  }\n\n  const [\n    aManifest,\n    bManifest,\n  ] =\n    await Promise.all(specs.map(spec => pacote.manifest(spec, opts)))\n\n  const versions = {\n    a: aManifest.version,\n    b: bManifest.version,\n  }\n\n  // fetches tarball using pacote\n  const [a, b] = await Promise.all([\n    getTarball(aManifest, opts),\n    getTarball(bManifest, opts),\n  ])\n\n  // read all files\n  // populates `files` and `refs`\n  const {\n    files,\n    refs,\n  } = await untar([\n    {\n      prefix: 'a/',\n      item: a,\n    },\n    {\n      prefix: 'b/',\n      item: b,\n    },\n  ], opts)\n\n  return formatDiff({\n    files,\n    opts,\n    refs,\n    versions,\n  })\n}\n\nmodule.exports = diff\n","const EOL = '\\n'\n\nconst colorizeDiff = require('@npmcli/disparity-colors')\nconst jsDiff = require('diff')\n\nconst shouldPrintPatch = require('./should-print-patch.js')\n\nconst formatDiff = ({ files, opts = {}, refs, versions }) => {\n  let res = ''\n  const srcPrefix = opts.diffNoPrefix ? '' : opts.diffSrcPrefix || 'a/'\n  const dstPrefix = opts.diffNoPrefix ? '' : opts.diffDstPrefix || 'b/'\n\n  for (const filename of files.values()) {\n    const names = {\n      a: `${srcPrefix}${filename}`,\n      b: `${dstPrefix}${filename}`,\n    }\n\n    let fileMode = ''\n    const filenames = {\n      a: refs.get(`a/${filename}`),\n      b: refs.get(`b/${filename}`),\n    }\n    const contents = {\n      a: filenames.a && filenames.a.content,\n      b: filenames.b && filenames.b.content,\n    }\n    const modes = {\n      a: filenames.a && filenames.a.mode,\n      b: filenames.b && filenames.b.mode,\n    }\n\n    if (contents.a === contents.b && modes.a === modes.b) {\n      continue\n    }\n\n    if (opts.diffNameOnly) {\n      res += `${filename}${EOL}`\n      continue\n    }\n\n    let patch = ''\n    let headerLength = 0\n    const header = str => {\n      headerLength++\n      patch += `${str}${EOL}`\n    }\n\n    // manually build a git diff-compatible header\n    header(`diff --git ${names.a} ${names.b}`)\n    if (modes.a === modes.b) {\n      fileMode = filenames.a.mode\n    } else {\n      if (modes.a && !modes.b) {\n        header(`deleted file mode ${modes.a}`)\n      } else if (!modes.a && modes.b) {\n        header(`new file mode ${modes.b}`)\n      } else {\n        header(`old mode ${modes.a}`)\n        header(`new mode ${modes.b}`)\n      }\n    }\n    /* eslint-disable-next-line max-len */\n    header(`index ${opts.tagVersionPrefix || 'v'}${versions.a}..${opts.tagVersionPrefix || 'v'}${versions.b} ${fileMode}`)\n\n    if (shouldPrintPatch(filename)) {\n      patch += jsDiff.createTwoFilesPatch(\n        names.a,\n        names.b,\n        contents.a || '',\n        contents.b || '',\n        '',\n        '',\n        {\n          context: opts.diffUnified === 0 ? 0 : opts.diffUnified || 3,\n          ignoreWhitespace: opts.diffIgnoreAllSpace,\n        }\n      ).replace(\n        '===================================================================\\n',\n        ''\n      ).replace(/\\t\\n/g, '\\n') // strip trailing tabs\n      headerLength += 2\n    } else {\n      header(`--- ${names.a}`)\n      header(`+++ ${names.b}`)\n    }\n\n    res += (opts.color\n      ? colorizeDiff(patch, { headerLength })\n      : patch)\n  }\n\n  return res.trim()\n}\n\nmodule.exports = formatDiff\n","const { basename, extname } = require('path')\n\nconst binaryExtensions = require('binary-extensions')\n\n// we should try to print patches as long as the\n// extension is not identified as binary files\nconst shouldPrintPatch = (path, opts = {}) => {\n  if (opts.diffText) {\n    return true\n  }\n\n  const filename = basename(path)\n  const extension = (\n    filename.startsWith('.')\n      ? filename\n      : extname(filename)\n  ).substr(1)\n\n  return !binaryExtensions.includes(extension)\n}\n\nmodule.exports = shouldPrintPatch\n","const { relative } = require('path')\n\nconst npa = require('npm-package-arg')\nconst pkgContents = require('@npmcli/installed-package-contents')\nconst pacote = require('pacote')\nconst { tarCreateOptions } = pacote.DirFetcher\nconst tar = require('tar')\n\n// returns a simplified tarball when reading files from node_modules folder,\n// thus avoiding running the prepare scripts and the extra logic from packlist\nconst nodeModulesTarball = (manifest, opts) =>\n  pkgContents({ path: manifest._resolved, depth: 1 })\n    .then(files =>\n      files.map(file => relative(manifest._resolved, file))\n    )\n    .then(files =>\n      tar.c(tarCreateOptions(manifest), files).concat()\n    )\n\nconst tarball = (manifest, opts) => {\n  const resolved = manifest._resolved\n  const where = opts.where || process.cwd()\n\n  const fromNodeModules = npa(resolved).type === 'directory'\n    && /node_modules[\\\\/](@[^\\\\/]+\\/)?[^\\\\/]+[\\\\/]?$/.test(relative(where, resolved))\n\n  if (fromNodeModules) {\n    return nodeModulesTarball(manifest, opts)\n  }\n\n  return pacote.tarball(manifest._resolved, opts)\n}\n\nmodule.exports = tarball\n","const tar = require('tar')\nconst minimatch = require('minimatch')\n\nconst normalizeMatch = str => str\n  .replace(/\\\\+/g, '/')\n  .replace(/^\\.\\/|^\\./, '')\n\n// files and refs are mutating params\n// filterFiles, item, prefix and opts are read-only options\nconst untar = ({ files, refs }, { filterFiles, item, prefix }) => {\n  tar.list({\n    filter: (path, entry) => {\n      const fileMatch = () =>\n        (!filterFiles.length ||\n          filterFiles.some(f => {\n            const pattern = normalizeMatch(f)\n            return minimatch(\n              normalizeMatch(path),\n              `{package/,}${pattern}`,\n              { matchBase: pattern.startsWith('*') }\n            )\n          }))\n\n      // expands usage of simple path filters, e.g: lib or src/\n      const folderMatch = () =>\n        filterFiles.some(f =>\n          normalizeMatch(path).startsWith(normalizeMatch(f)) ||\n          normalizeMatch(path).startsWith(`package/${normalizeMatch(f)}`))\n\n      if (\n        entry.type === 'File' &&\n        (fileMatch() || folderMatch())\n      ) {\n        const key = path.replace(/^[^/]+\\/?/, '')\n        files.add(key)\n\n        // should skip reading file when using --name-only option\n        let content\n        try {\n          entry.setEncoding('utf8')\n          content = entry.concat()\n        } catch (e) {\n          /* istanbul ignore next */\n          throw Object.assign(\n            new Error('failed to read files'),\n            { code: 'EDIFFUNTAR' }\n          )\n        }\n\n        refs.set(`${prefix}${key}`, {\n          content,\n          mode: `100${entry.mode.toString(8)}`,\n        })\n        return true\n      }\n    },\n  })\n    .on('error', /* istanbul ignore next */ e => {\n      throw e\n    })\n    .end(item)\n}\n\nconst readTarballs = async (tarballs, opts = {}) => {\n  const files = new Set()\n  const refs = new Map()\n  const arr = [].concat(tarballs)\n\n  const filterFiles = opts.diffFiles || []\n\n  for (const i of arr) {\n    untar({\n      files,\n      refs,\n    }, {\n      item: i.item,\n      prefix: i.prefix,\n      filterFiles,\n    })\n  }\n\n  // await to read all content from included files\n  const allRefs = [...refs.values()]\n  const contents = await Promise.all(allRefs.map(async ref => ref.content))\n\n  contents.forEach((content, index) => {\n    allRefs[index].content = content\n  })\n\n  return {\n    files,\n    refs,\n  }\n}\n\nmodule.exports = readTarballs\n"]}