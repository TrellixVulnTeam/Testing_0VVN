{"version":3,"sources":["index.js","link-bins.js","is-windows.js","bin-target.js","get-prefix.js","get-node-modules.js","shim-bin.js","fix-bin.js","link-bin.js","link-gently.js","link-mans.js","man-target.js","check-bins.js","check-bin.js","get-paths.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,AHSA,ACHA;AELA,ACHA,AJYA,ACHA;AELA,ACHA,AJYA,ACHA;AELA,ACHA,AJYA,ACHA;AELA,AENA,ADGA,AJYA,ACHA;AELA,AENA,ALeA,ACHA;AELA,AENA,ALeA,ACHA;AELA,AENA,ALeA,ACHA,AKfA;ADIA,ALeA,ACHA,AKfA;ADIA,ALeA,ACHA,AKfA;ACFA,AFMA,ALeA,ACHA,AKfA;ACFA,AFMA,ALeA,ACHA,AKfA;ACFA,AFMA,ALeA,ACHA,AKfA;ACFA,AFMA,ALeA,AQxBA,APqBA,AKfA;ACFA,AFMA,ALeA,AQxBA,APqBA,AKfA;ACFA,AFMA,ALeA,AQxBA,APqBA,AKfA;ACFA,AFMA,ALeA,AQxBA,ACHA,AHSA;ACFA,AFMA,ALeA,AQxBA,ACHA,AHSA;ACFA,AFMA,ALeA,AQxBA,ACHA,AHSA;ACFA,AFMA,ALeA,AQxBA,ACHA,ACHA,AJYA;ACFA,AFMA,ALeA,AQxBA,ACHA,ACHA,AJYA;ACFA,AFMA,ALeA,AQxBA,ACHA,ACHA,AJYA;ACFA,AFMA,ALeA,AQxBA,ACHA,ACHA,ACHA,ALeA;ACFA,AFMA,ALeA,AS3BA,ACHA,ACHA,ALeA;ACFA,APqBA,AS3BA,ACHA,ACHA,ALeA;AMjBA,ALeA,APqBA,AS3BA,ACHA,ACHA,ALeA;AMjBA,ALeA,APqBA,AS3BA,ACHA,ACHA,ALeA;AMjBA,ALeA,APqBA,AS3BA,ACHA,ACHA,ALeA;AOpBA,ADGA,ALeA,APqBA,AS3BA,ACHA,ACHA,ALeA;AOpBA,ADGA,ALeA,APqBA,AS3BA,ACHA,AJYA;AOpBA,ADGA,ALeA,APqBA,AS3BA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,Ad0CA,AS3BA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,Ad0CA,AS3BA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,Ad0CA,AS3BA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ADGA,ALeA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ANkBA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ANkBA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ANkBA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ANkBA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ANkBA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ANkBA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ANkBA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ANkBA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ANkBA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ANkBA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ANkBA,AOrBA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,ACHA,AJYA;AOpBA,ACHA,ALeA,AHSA;AOpBA,ACHA,ALeA,AHSA;AOpBA,ACHA,ALeA,AHSA;AOpBA,ACHA,ALeA,AHSA;AOpBA,ACHA,ALeA,AHSA;AOpBA,ACHA,ALeA,AHSA;AOpBA,ACHA,ALeA,AHSA;AOpBA,ACHA,ALeA,AHSA;AOpBA,ACHA,ALeA,AHSA;AOpBA,ACHA,ALeA,AHSA;AOpBA,ACHA,ALeA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA,AHSA;AOpBA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AIXA,AJYA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const linkBins = require('./link-bins.js')\nconst linkMans = require('./link-mans.js')\n\nconst binLinks = opts => {\n  const { path, pkg, force, global, top } = opts\n  // global top pkgs on windows get bins installed in {prefix}, and no mans\n  //\n  // unix global top pkgs get their bins installed in {prefix}/bin,\n  // and mans in {prefix}/share/man\n  //\n  // non-top pkgs get their bins installed in {prefix}/node_modules/.bin,\n  // and do not install mans\n  //\n  // non-global top pkgs don't have any bins or mans linked.  From here on\n  // out, if it's top, we know that it's global, so no need to pass that\n  // option further down the stack.\n  if (top && !global) {\n    return Promise.resolve()\n  }\n\n  return Promise.all([\n    // allow clobbering within the local node_modules/.bin folder.\n    // only global bins are protected in this way, or else it is\n    // yet another vector for excessive dependency conflicts.\n    linkBins({ path, pkg, top, force: force || !top }),\n    linkMans({ path, pkg, top, force }),\n  ])\n}\n\nconst shimBin = require('./shim-bin.js')\nconst linkGently = require('./link-gently.js')\nconst resetSeen = () => {\n  shimBin.resetSeen()\n  linkGently.resetSeen()\n}\n\nconst checkBins = require('./check-bins.js')\nconst getPaths = require('./get-paths.js')\n\nmodule.exports = Object.assign(binLinks, {\n  checkBins,\n  resetSeen,\n  getPaths,\n})\n","const isWindows = require('./is-windows.js')\nconst binTarget = require('./bin-target.js')\nconst { dirname, resolve, relative } = require('path')\nconst linkBin = isWindows ? require('./shim-bin.js') : require('./link-bin.js')\nconst normalize = require('npm-normalize-package-bin')\n\nconst linkBins = ({ path, pkg, top, force }) => {\n  pkg = normalize(pkg)\n  if (!pkg.bin) {\n    return Promise.resolve([])\n  }\n  const promises = []\n  const target = binTarget({ path, top })\n  for (const [key, val] of Object.entries(pkg.bin)) {\n    const to = resolve(target, key)\n    const absFrom = resolve(path, val)\n    const from = relative(dirname(to), absFrom)\n    promises.push(linkBin({ path, from, to, absFrom, force }))\n  }\n  return Promise.all(promises)\n}\n\nmodule.exports = linkBins\n","const platform = process.env.__TESTING_BIN_LINKS_PLATFORM__ || process.platform\nmodule.exports = platform === 'win32'\n","const isWindows = require('./is-windows.js')\nconst getPrefix = require('./get-prefix.js')\nconst getNodeModules = require('./get-node-modules.js')\nconst { dirname } = require('path')\n\nmodule.exports = ({ top, path }) =>\n  !top ? getNodeModules(path) + '/.bin'\n  : isWindows ? getPrefix(path)\n  : dirname(getPrefix(path)) + '/bin'\n","const { dirname } = require('path')\nconst getNodeModules = require('./get-node-modules.js')\nmodule.exports = path => dirname(getNodeModules(path))\n","// we know it's global and/or not top, so the path has to be\n// {prefix}/node_modules/{name}.  Can't rely on pkg.name, because\n// it might be installed as an alias.\n\nconst { dirname, basename } = require('path')\n// this gets called a lot and can't change, so memoize it\nconst memo = new Map()\nmodule.exports = path => {\n  if (memo.has(path)) {\n    return memo.get(path)\n  }\n\n  const scopeOrNm = dirname(path)\n  const nm = basename(scopeOrNm) === 'node_modules' ? scopeOrNm\n    : dirname(scopeOrNm)\n\n  memo.set(path, nm)\n  return nm\n}\n","const { promisify } = require('util')\nconst { resolve, dirname } = require('path')\nconst fs = require('fs')\nconst lstat = promisify(fs.lstat)\nconst throwNonEnoent = er => {\n  if (er.code !== 'ENOENT') {\n    throw er\n  }\n}\n\nconst cmdShim = require('cmd-shim')\nconst readCmdShim = require('read-cmd-shim')\n\nconst fixBin = require('./fix-bin.js')\n\n// even in --force mode, we never create a shim over a shim we've\n// already created.  you can have multiple packages in a tree trying\n// to contend for the same bin, which creates a race condition and\n// nondeterminism.\nconst seen = new Set()\n\nconst failEEXIST = ({ path, to, from }) =>\n  Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n    path: to,\n    dest: from,\n    code: 'EEXIST',\n  }))\n\nconst handleReadCmdShimError = ({ er, from, to }) =>\n  er.code === 'ENOENT' ? null\n  : er.code === 'ENOTASHIM' ? failEEXIST({ from, to })\n  : Promise.reject(er)\n\nconst SKIP = Symbol('skip - missing or already installed')\nconst shimBin = ({ path, to, from, absFrom, force }) => {\n  const shims = [\n    to,\n    to + '.cmd',\n    to + '.ps1',\n  ]\n\n  for (const shim of shims) {\n    if (seen.has(shim)) {\n      return true\n    }\n    seen.add(shim)\n  }\n\n  return Promise.all([\n    ...shims,\n    absFrom,\n  ].map(f => lstat(f).catch(throwNonEnoent))).then((stats) => {\n    const [, , , stFrom] = stats\n    if (!stFrom) {\n      return SKIP\n    }\n\n    if (force) {\n      return\n    }\n\n    return Promise.all(shims.map((s, i) => [s, stats[i]]).map(([s, st]) => {\n      if (!st) {\n        return\n      }\n      return readCmdShim(s)\n        .then(target => {\n          target = resolve(dirname(to), target)\n          if (target.indexOf(resolve(path)) !== 0) {\n            return failEEXIST({ from, to, path })\n          }\n        }, er => handleReadCmdShimError({ er, from, to }))\n    }))\n  })\n    .then(skip => skip !== SKIP && doShim(absFrom, to))\n}\n\nconst doShim = (absFrom, to) =>\n  cmdShim(absFrom, to).then(() => fixBin(absFrom))\n\nconst resetSeen = () => {\n  for (const p of seen) {\n    seen.delete(p)\n  }\n}\n\nmodule.exports = Object.assign(shimBin, { resetSeen })\n","// make sure that bins are executable, and that they don't have\n// windows line-endings on the hashbang line.\nconst fs = require('fs')\nconst { promisify } = require('util')\n\nconst execMode = 0o777 & (~process.umask())\n\nconst writeFileAtomic = require('write-file-atomic')\nconst open = promisify(fs.open)\nconst close = promisify(fs.close)\nconst read = promisify(fs.read)\nconst chmod = promisify(fs.chmod)\nconst readFile = promisify(fs.readFile)\n\nconst isWindowsHashBang = buf =>\n  buf[0] === '#'.charCodeAt(0) &&\n  buf[1] === '!'.charCodeAt(0) &&\n  /^#![^\\n]+\\r\\n/.test(buf.toString())\n\nconst isWindowsHashbangFile = file => {\n  const FALSE = () => false\n  return open(file, 'r').then(fd => {\n    const buf = Buffer.alloc(2048)\n    return read(fd, buf, 0, 2048, 0)\n      .then(\n        () => {\n          const isWHB = isWindowsHashBang(buf)\n          return close(fd).then(() => isWHB, () => isWHB)\n        },\n        // don't leak FD if read() fails\n        () => close(fd).then(FALSE, FALSE)\n      )\n  }, FALSE)\n}\n\nconst dos2Unix = file =>\n  readFile(file, 'utf8').then(content =>\n    writeFileAtomic(file, content.replace(/^(#![^\\n]+)\\r\\n/, '$1\\n')))\n\nconst fixBin = (file, mode = execMode) => chmod(file, mode)\n  .then(() => isWindowsHashbangFile(file))\n  .then(isWHB => isWHB ? dos2Unix(file) : null)\n\nmodule.exports = fixBin\n","const linkGently = require('./link-gently.js')\nconst fixBin = require('./fix-bin.js')\n\n// linking bins is simple.  just symlink, and if we linked it, fix the bin up\nconst linkBin = ({ path, to, from, absFrom, force }) =>\n  linkGently({ path, to, from, absFrom, force })\n    .then(linked => linked && fixBin(absFrom))\n\nmodule.exports = linkBin\n","// if the thing isn't there, skip it\n// if there's a non-symlink there already, eexist\n// if there's a symlink already, pointing somewhere else, eexist\n// if there's a symlink already, pointing into our pkg, remove it first\n// then create the symlink\n\nconst { promisify } = require('util')\nconst { resolve, dirname } = require('path')\nconst mkdirp = require('mkdirp-infer-owner')\nconst fs = require('fs')\nconst symlink = promisify(fs.symlink)\nconst readlink = promisify(fs.readlink)\nconst lstat = promisify(fs.lstat)\nconst throwNonEnoent = er => {\n  if (er.code !== 'ENOENT') {\n    throw er\n  }\n}\n\n// even in --force mode, we never create a link over a link we've\n// already created.  you can have multiple packages in a tree trying\n// to contend for the same bin, or the same manpage listed multiple times,\n// which creates a race condition and nondeterminism.\nconst seen = new Set()\n\n// disable glob in our rimraf calls\nconst rimraf = promisify(require('rimraf'))\nconst rm = path => rimraf(path, { glob: false })\n\nconst SKIP = Symbol('skip - missing or already installed')\nconst CLOBBER = Symbol('clobber - ours or in forceful mode')\n\nconst linkGently = async ({ path, to, from, absFrom, force }) => {\n  if (seen.has(to)) {\n    return true\n  }\n  seen.add(to)\n\n  // if the script or manpage isn't there, just ignore it.\n  // this arguably *should* be an install error of some sort,\n  // or at least a warning, but npm has always behaved this\n  // way in the past, so it'd be a breaking change\n  return Promise.all([\n    lstat(absFrom).catch(throwNonEnoent),\n    lstat(to).catch(throwNonEnoent),\n  ]).then(([stFrom, stTo]) => {\n    // not present in package, skip it\n    if (!stFrom) {\n      return SKIP\n    }\n\n    // exists! maybe clobber if we can\n    if (stTo) {\n      if (!stTo.isSymbolicLink()) {\n        return force && rm(to).then(() => CLOBBER)\n      }\n\n      return readlink(to).then(target => {\n        if (target === from) {\n          return SKIP\n        } // skip it, already set up like we want it.\n\n        target = resolve(dirname(to), target)\n        if (target.indexOf(path) === 0 || force) {\n          return rm(to).then(() => CLOBBER)\n        }\n      })\n    } else {\n      // doesn't exist, dir might not either\n      return mkdirp(dirname(to))\n    }\n  })\n    .then(skipOrClobber => {\n      if (skipOrClobber === SKIP) {\n        return false\n      }\n      return symlink(from, to, 'file').catch(er => {\n        if (skipOrClobber === CLOBBER || force) {\n          return rm(to).then(() => symlink(from, to, 'file'))\n        }\n        throw er\n      }).then(() => true)\n    })\n}\n\nconst resetSeen = () => {\n  for (const p of seen) {\n    seen.delete(p)\n  }\n}\n\nmodule.exports = Object.assign(linkGently, { resetSeen })\n","const { dirname, relative, join, resolve, basename } = require('path')\nconst linkGently = require('./link-gently.js')\nconst manTarget = require('./man-target.js')\n\nconst linkMans = ({ path, pkg, top, force }) => {\n  const target = manTarget({ path, top })\n  if (!target || !pkg.man || !Array.isArray(pkg.man) || !pkg.man.length) {\n    return Promise.resolve([])\n  }\n\n  // break any links to c:\\\\blah or /foo/blah or ../blah\n  // and filter out duplicates\n  const set = [...new Set(pkg.man.map(man =>\n    man ? join('/', man).replace(/\\\\|:/g, '/').substr(1) : null)\n    .filter(man => typeof man === 'string'))]\n\n  return Promise.all(set.map(man => {\n    const parseMan = man.match(/(.*\\.([0-9]+)(\\.gz)?)$/)\n    if (!parseMan) {\n      return Promise.reject(Object.assign(new Error('invalid man entry name\\n' +\n        'Man files must end with a number, ' +\n        'and optionally a .gz suffix if they are compressed.'\n      ), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man,\n      }))\n    }\n\n    const stem = parseMan[1]\n    const sxn = parseMan[2]\n    const base = basename(stem)\n    const absFrom = resolve(path, man)\n    /* istanbul ignore if - that unpossible */\n    if (absFrom.indexOf(path) !== 0) {\n      return Promise.reject(Object.assign(new Error('invalid man entry'), {\n        code: 'EBADMAN',\n        path,\n        pkgid: pkg._id,\n        man,\n      }))\n    }\n\n    const to = resolve(target, 'man' + sxn, base)\n    const from = relative(dirname(to), absFrom)\n\n    return linkGently({ from, to, path, absFrom, force })\n  }))\n}\n\nmodule.exports = linkMans\n","const isWindows = require('./is-windows.js')\nconst getPrefix = require('./get-prefix.js')\nconst { dirname } = require('path')\n\nmodule.exports = ({ top, path }) => !top || isWindows ? null\n  : dirname(getPrefix(path)) + '/share/man'\n","const checkBin = require('./check-bin.js')\nconst normalize = require('npm-normalize-package-bin')\nconst checkBins = async ({ pkg, path, top, global, force }) => {\n  // always ok to clobber when forced\n  // always ok to clobber local bins, or when forced\n  if (force || !global || !top) {\n    return\n  }\n\n  pkg = normalize(pkg)\n  if (!pkg.bin) {\n    return\n  }\n\n  await Promise.all(Object.keys(pkg.bin)\n    .map(bin => checkBin({ bin, path, top, global, force })))\n}\nmodule.exports = checkBins\n","// check to see if a bin is allowed to be overwritten\n// either rejects or resolves to nothing.  return value not relevant.\nconst isWindows = require('./is-windows.js')\nconst binTarget = require('./bin-target.js')\nconst { resolve, dirname } = require('path')\nconst readCmdShim = require('read-cmd-shim')\nconst fs = require('fs')\nconst { promisify } = require('util')\nconst readlink = promisify(fs.readlink)\n\nconst checkBin = async ({ bin, path, top, global, force }) => {\n  // always ok to clobber when forced\n  // always ok to clobber local bins, or when forced\n  if (force || !global || !top) {\n    return\n  }\n\n  // ok, need to make sure, then\n  const target = resolve(binTarget({ path, top }), bin)\n  path = resolve(path)\n  return isWindows ? checkShim({ target, path }) : checkLink({ target, path })\n}\n\n// only enoent is allowed.  anything else is a problem.\nconst handleReadLinkError = async ({ er, target }) =>\n  er.code === 'ENOENT' ? null\n  : failEEXIST({ target })\n\nconst checkLink = async ({ target, path }) => {\n  const current = await readlink(target)\n    .catch(er => handleReadLinkError({ er, target }))\n\n  if (!current) {\n    return\n  }\n\n  const resolved = resolve(dirname(target), current)\n\n  if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0) {\n    return failEEXIST({ target })\n  }\n}\n\nconst handleReadCmdShimError = ({ er, target }) =>\n  er.code === 'ENOENT' ? null\n  : failEEXIST({ target })\n\nconst failEEXIST = ({ target }) =>\n  Promise.reject(Object.assign(new Error('EEXIST: file already exists'), {\n    path: target,\n    code: 'EEXIST',\n  }))\n\nconst checkShim = async ({ target, path }) => {\n  const shims = [\n    target,\n    target + '.cmd',\n    target + '.ps1',\n  ]\n  await Promise.all(shims.map(async target => {\n    const current = await readCmdShim(target)\n      .catch(er => handleReadCmdShimError({ er, target }))\n\n    if (!current) {\n      return\n    }\n\n    const resolved = resolve(dirname(target), current.replace(/\\\\/g, '/'))\n\n    if (resolved.toLowerCase().indexOf(path.toLowerCase()) !== 0) {\n      return failEEXIST({ target })\n    }\n  }))\n}\n\nmodule.exports = checkBin\n","// get all the paths that are (or might be) installed for a given pkg\n// There's no guarantee that all of these will be installed, but if they\n// are present, then we can assume that they're associated.\nconst binTarget = require('./bin-target.js')\nconst manTarget = require('./man-target.js')\nconst { resolve, basename } = require('path')\nconst isWindows = require('./is-windows.js')\nmodule.exports = ({ path, pkg, global, top }) => {\n  if (top && !global) {\n    return []\n  }\n\n  const binSet = []\n  const binTarg = binTarget({ path, top })\n  if (pkg.bin) {\n    for (const bin of Object.keys(pkg.bin)) {\n      const b = resolve(binTarg, bin)\n      binSet.push(b)\n      if (isWindows) {\n        binSet.push(b + '.cmd')\n        binSet.push(b + '.ps1')\n      }\n    }\n  }\n\n  const manTarg = manTarget({ path, top })\n  const manSet = []\n  if (manTarg && pkg.man && Array.isArray(pkg.man) && pkg.man.length) {\n    for (const man of pkg.man) {\n      const parseMan = man.match(/(.*\\.([0-9]+)(\\.gz)?)$/)\n      // invalid entries invalidate the entire man set\n      if (!parseMan) {\n        return binSet\n      }\n\n      const stem = parseMan[1]\n      const sxn = parseMan[2]\n      const base = basename(stem)\n      const absFrom = resolve(path, man)\n\n      /* istanbul ignore if - should be impossible */\n      if (absFrom.indexOf(path) !== 0) {\n        return binSet\n      }\n\n      manSet.push(resolve(manTarg, 'man' + sxn, base))\n    }\n  }\n\n  return manSet.length ? [...binSet, ...manSet] : binSet\n}\n"]}