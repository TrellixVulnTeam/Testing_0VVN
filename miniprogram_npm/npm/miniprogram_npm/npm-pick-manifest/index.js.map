{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst npa = require('npm-package-arg')\nconst semver = require('semver')\nconst { checkEngine } = require('npm-install-checks')\nconst normalizeBin = require('npm-normalize-package-bin')\n\nconst engineOk = (manifest, npmVersion, nodeVersion) => {\n  try {\n    checkEngine(manifest, npmVersion, nodeVersion)\n    return true\n  } catch (_) {\n    return false\n  }\n}\n\nconst isBefore = (verTimes, ver, time) =>\n  !verTimes || !verTimes[ver] || Date.parse(verTimes[ver]) <= time\n\nconst avoidSemverOpt = { includePrerelease: true, loose: true }\nconst shouldAvoid = (ver, avoid) =>\n  avoid && semver.satisfies(ver, avoid, avoidSemverOpt)\n\nconst decorateAvoid = (result, avoid) =>\n  result && shouldAvoid(result.version, avoid)\n    ? { ...result, _shouldAvoid: true }\n    : result\n\nconst pickManifest = (packument, wanted, opts) => {\n  const {\n    defaultTag = 'latest',\n    before = null,\n    nodeVersion = process.version,\n    npmVersion = null,\n    includeStaged = false,\n    avoid = null,\n    avoidStrict = false,\n  } = opts\n\n  const { name, time: verTimes } = packument\n  const versions = packument.versions || {}\n\n  if (avoidStrict) {\n    const looseOpts = {\n      ...opts,\n      avoidStrict: false,\n    }\n\n    const result = pickManifest(packument, wanted, looseOpts)\n    if (!result || !result._shouldAvoid) {\n      return result\n    }\n\n    const caret = pickManifest(packument, `^${result.version}`, looseOpts)\n    if (!caret || !caret._shouldAvoid) {\n      return {\n        ...caret,\n        _outsideDependencyRange: true,\n        _isSemVerMajor: false,\n      }\n    }\n\n    const star = pickManifest(packument, '*', looseOpts)\n    if (!star || !star._shouldAvoid) {\n      return {\n        ...star,\n        _outsideDependencyRange: true,\n        _isSemVerMajor: true,\n      }\n    }\n\n    throw Object.assign(new Error(`No avoidable versions for ${name}`), {\n      code: 'ETARGET',\n      name,\n      wanted,\n      avoid,\n      before,\n      versions: Object.keys(versions),\n    })\n  }\n\n  const staged = (includeStaged && packument.stagedVersions &&\n    packument.stagedVersions.versions) || {}\n  const restricted = (packument.policyRestrictions &&\n    packument.policyRestrictions.versions) || {}\n\n  const time = before && verTimes ? +(new Date(before)) : Infinity\n  const spec = npa.resolve(name, wanted || defaultTag)\n  const type = spec.type\n  const distTags = packument['dist-tags'] || {}\n\n  if (type !== 'tag' && type !== 'version' && type !== 'range') {\n    throw new Error('Only tag, version, and range are supported')\n  }\n\n  // if the type is 'tag', and not just the implicit default, then it must\n  // be that exactly, or nothing else will do.\n  if (wanted && type === 'tag') {\n    const ver = distTags[wanted]\n    // if the version in the dist-tags is before the before date, then\n    // we use that.  Otherwise, we get the highest precedence version\n    // prior to the dist-tag.\n    if (isBefore(verTimes, ver, time)) {\n      return decorateAvoid(versions[ver] || staged[ver] || restricted[ver], avoid)\n    } else {\n      return pickManifest(packument, `<=${ver}`, opts)\n    }\n  }\n\n  // similarly, if a specific version, then only that version will do\n  if (wanted && type === 'version') {\n    const ver = semver.clean(wanted, { loose: true })\n    const mani = versions[ver] || staged[ver] || restricted[ver]\n    return isBefore(verTimes, ver, time) ? decorateAvoid(mani, avoid) : null\n  }\n\n  // ok, sort based on our heuristics, and pick the best fit\n  const range = type === 'range' ? wanted : '*'\n\n  // if the range is *, then we prefer the 'latest' if available\n  // but skip this if it should be avoided, in that case we have\n  // to try a little harder.\n  const defaultVer = distTags[defaultTag]\n  if (defaultVer &&\n      (range === '*' || semver.satisfies(defaultVer, range, { loose: true })) &&\n      !shouldAvoid(defaultVer, avoid)) {\n    const mani = versions[defaultVer]\n    if (mani && isBefore(verTimes, defaultVer, time)) {\n      return mani\n    }\n  }\n\n  // ok, actually have to sort the list and take the winner\n  const allEntries = Object.entries(versions)\n    .concat(Object.entries(staged))\n    .concat(Object.entries(restricted))\n    .filter(([ver, mani]) => isBefore(verTimes, ver, time))\n\n  if (!allEntries.length) {\n    throw Object.assign(new Error(`No versions available for ${name}`), {\n      code: 'ENOVERSIONS',\n      name,\n      type,\n      wanted,\n      before,\n      versions: Object.keys(versions),\n    })\n  }\n\n  const sortSemverOpt = { loose: true }\n  const entries = allEntries.filter(([ver, mani]) =>\n    semver.satisfies(ver, range, { loose: true }))\n    .sort((a, b) => {\n      const [vera, mania] = a\n      const [verb, manib] = b\n      const notavoida = !shouldAvoid(vera, avoid)\n      const notavoidb = !shouldAvoid(verb, avoid)\n      const notrestra = !restricted[a]\n      const notrestrb = !restricted[b]\n      const notstagea = !staged[a]\n      const notstageb = !staged[b]\n      const notdepra = !mania.deprecated\n      const notdeprb = !manib.deprecated\n      const enginea = engineOk(mania, npmVersion, nodeVersion)\n      const engineb = engineOk(manib, npmVersion, nodeVersion)\n      // sort by:\n      // - not an avoided version\n      // - not restricted\n      // - not staged\n      // - not deprecated and engine ok\n      // - engine ok\n      // - not deprecated\n      // - semver\n      return (notavoidb - notavoida) ||\n        (notrestrb - notrestra) ||\n        (notstageb - notstagea) ||\n        ((notdeprb && engineb) - (notdepra && enginea)) ||\n        (engineb - enginea) ||\n        (notdeprb - notdepra) ||\n        semver.rcompare(vera, verb, sortSemverOpt)\n    })\n\n  return decorateAvoid(entries[0] && entries[0][1], avoid)\n}\n\nmodule.exports = (packument, wanted, opts = {}) => {\n  const mani = pickManifest(packument, wanted, opts)\n  const picked = mani && normalizeBin(mani)\n  const policyRestrictions = packument.policyRestrictions\n  const restricted = (policyRestrictions && policyRestrictions.versions) || {}\n\n  if (picked && !restricted[picked.version]) {\n    return picked\n  }\n\n  const { before = null, defaultTag = 'latest' } = opts\n  const bstr = before ? new Date(before).toLocaleString() : ''\n  const { name } = packument\n  const pckg = `${name}@${wanted}` +\n    (before ? ` with a date before ${bstr}` : '')\n\n  const isForbidden = picked && !!restricted[picked.version]\n  const polMsg = isForbidden ? policyRestrictions.message : ''\n\n  const msg = !isForbidden ? `No matching version found for ${pckg}.`\n    : `Could not download ${pckg} due to policy violations:\\n${polMsg}`\n\n  const code = isForbidden ? 'E403' : 'ETARGET'\n  throw Object.assign(new Error(msg), {\n    code,\n    type: npa.resolve(packument.name, wanted).type,\n    wanted,\n    versions: Object.keys(packument.versions),\n    name,\n    distTags: packument['dist-tags'],\n    defaultTag,\n  })\n}\n"]}