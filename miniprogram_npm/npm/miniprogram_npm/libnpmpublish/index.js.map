{"version":3,"sources":["index.js","publish.js","unpublish.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = {\n  publish: require('./publish.js'),\n  unpublish: require('./unpublish.js'),\n}\n","const { fixer } = require('normalize-package-data')\nconst npmFetch = require('npm-registry-fetch')\nconst npa = require('npm-package-arg')\nconst semver = require('semver')\nconst { URL } = require('url')\nconst ssri = require('ssri')\n\nconst publish = async (manifest, tarballData, opts) => {\n  if (manifest.private) {\n    throw Object.assign(\n      new Error(`This package has been marked as private\nRemove the 'private' field from the package.json to publish it.`),\n      { code: 'EPRIVATE' }\n    )\n  }\n\n  // spec is used to pick the appropriate registry/auth combo\n  const spec = npa.resolve(manifest.name, manifest.version)\n  opts = {\n    defaultTag: 'latest',\n    // if scoped, restricted by default\n    access: spec.scope ? 'restricted' : 'public',\n    algorithms: ['sha512'],\n    ...opts,\n    spec,\n  }\n\n  const reg = npmFetch.pickRegistry(spec, opts)\n  const pubManifest = patchManifest(manifest, opts)\n\n  // registry-frontdoor cares about the access level,\n  // which is only configurable for scoped packages\n  if (!spec.scope && opts.access === 'restricted') {\n    throw Object.assign(\n      new Error(\"Can't restrict access to unscoped packages.\"),\n      { code: 'EUNSCOPED' }\n    )\n  }\n\n  const metadata = buildMetadata(reg, pubManifest, tarballData, opts)\n\n  try {\n    return await npmFetch(spec.escapedName, {\n      ...opts,\n      method: 'PUT',\n      body: metadata,\n      ignoreBody: true,\n    })\n  } catch (err) {\n    if (err.code !== 'E409') {\n      throw err\n    }\n    // if E409, we attempt exactly ONE retry, to protect us\n    // against malicious activity like trying to publish\n    // a bunch of new versions of a package at the same time\n    // and/or spamming the registry\n    const current = await npmFetch.json(spec.escapedName, {\n      ...opts,\n      query: { write: true },\n    })\n    const newMetadata = patchMetadata(current, metadata)\n    return npmFetch(spec.escapedName, {\n      ...opts,\n      method: 'PUT',\n      body: newMetadata,\n      ignoreBody: true,\n    })\n  }\n}\n\nconst patchManifest = (_manifest, opts) => {\n  const { npmVersion } = opts\n  // we only update top-level fields, so a shallow clone is fine\n  const manifest = { ..._manifest }\n\n  manifest._nodeVersion = process.versions.node\n  if (npmVersion) {\n    manifest._npmVersion = npmVersion\n  }\n\n  fixer.fixNameField(manifest, { strict: true, allowLegacyCase: true })\n  const version = semver.clean(manifest.version)\n  if (!version) {\n    throw Object.assign(\n      new Error('invalid semver: ' + manifest.version),\n      { code: 'EBADSEMVER' }\n    )\n  }\n  manifest.version = version\n  return manifest\n}\n\nconst buildMetadata = (registry, manifest, tarballData, opts) => {\n  const { access, defaultTag, algorithms } = opts\n  const root = {\n    _id: manifest.name,\n    name: manifest.name,\n    description: manifest.description,\n    'dist-tags': {},\n    versions: {},\n    access,\n  }\n\n  root.versions[manifest.version] = manifest\n  const tag = manifest.tag || defaultTag\n  root['dist-tags'][tag] = manifest.version\n\n  const tarballName = `${manifest.name}-${manifest.version}.tgz`\n  const tarballURI = `${manifest.name}/-/${tarballName}`\n  const integrity = ssri.fromData(tarballData, {\n    algorithms: [...new Set(['sha1'].concat(algorithms))],\n  })\n\n  manifest._id = `${manifest.name}@${manifest.version}`\n  manifest.dist = { ...manifest.dist }\n  // Don't bother having sha1 in the actual integrity field\n  manifest.dist.integrity = integrity.sha512[0].toString()\n  // Legacy shasum support\n  manifest.dist.shasum = integrity.sha1[0].hexDigest()\n\n  // NB: the CLI always fetches via HTTPS if the registry is HTTPS,\n  // regardless of what's here.  This makes it so that installing\n  // from an HTTP-only mirror doesn't cause problems, though.\n  manifest.dist.tarball = new URL(tarballURI, registry).href\n    .replace(/^https:\\/\\//, 'http://')\n\n  root._attachments = {}\n  root._attachments[tarballName] = {\n    content_type: 'application/octet-stream',\n    data: tarballData.toString('base64'),\n    length: tarballData.length,\n  }\n\n  return root\n}\n\nconst patchMetadata = (current, newData) => {\n  const curVers = Object.keys(current.versions || {})\n    .map(v => semver.clean(v, true))\n    .concat(Object.keys(current.time || {})\n      .map(v => semver.valid(v, true) && semver.clean(v, true))\n      .filter(v => v))\n\n  const newVersion = Object.keys(newData.versions)[0]\n\n  if (curVers.indexOf(newVersion) !== -1) {\n    const { name: pkgid, version } = newData\n    throw Object.assign(\n      new Error(\n        `Cannot publish ${pkgid}@${version} over existing version.`\n      ), {\n        code: 'EPUBLISHCONFLICT',\n        pkgid,\n        version,\n      })\n  }\n\n  current.versions = current.versions || {}\n  current.versions[newVersion] = newData.versions[newVersion]\n  for (const i in newData) {\n    switch (i) {\n      // objects that copy over the new stuffs\n      case 'dist-tags':\n      case 'versions':\n      case '_attachments':\n        for (const j in newData[i]) {\n          current[i] = current[i] || {}\n          current[i][j] = newData[i][j]\n        }\n        break\n\n      // copy\n      default:\n        current[i] = newData[i]\n        break\n    }\n  }\n\n  return current\n}\n\nmodule.exports = publish\n","\n\nconst npa = require('npm-package-arg')\nconst npmFetch = require('npm-registry-fetch')\nconst semver = require('semver')\nconst { URL } = require('url')\n\nconst unpublish = async (spec, opts) => {\n  spec = npa(spec)\n  // spec is used to pick the appropriate registry/auth combo.\n  opts = {\n    force: false,\n    ...opts,\n    spec,\n  }\n\n  try {\n    const pkgUri = spec.escapedName\n    const pkg = await npmFetch.json(pkgUri, {\n      ...opts,\n      query: { write: true },\n    })\n\n    const version = spec.rawSpec\n    const allVersions = pkg.versions || {}\n    const versionData = allVersions[version]\n\n    const rawSpecs = (!spec.rawSpec || spec.rawSpec === '*')\n    const onlyVersion = Object.keys(allVersions).length === 1\n    const noVersions = !Object.keys(allVersions).length\n\n    // if missing specific version,\n    // assumed unpublished\n    if (!versionData && !rawSpecs && !noVersions) {\n      return true\n    }\n\n    // unpublish all versions of a package:\n    // - no specs supplied \"npm unpublish foo\"\n    // - all specs (\"*\") \"npm unpublish foo@*\"\n    // - there was only one version\n    // - has no versions field on packument\n    if (rawSpecs || onlyVersion || noVersions) {\n      await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, {\n        ...opts,\n        method: 'DELETE',\n        ignoreBody: true,\n      })\n      return true\n    } else {\n      const dist = allVersions[version].dist\n      delete allVersions[version]\n\n      const latestVer = pkg['dist-tags'].latest\n\n      // deleting dist tags associated to version\n      Object.keys(pkg['dist-tags']).forEach(tag => {\n        if (pkg['dist-tags'][tag] === version) {\n          delete pkg['dist-tags'][tag]\n        }\n      })\n\n      if (latestVer === version) {\n        pkg['dist-tags'].latest = Object.keys(\n          allVersions\n        ).sort(semver.compareLoose).pop()\n      }\n\n      delete pkg._revisions\n      delete pkg._attachments\n\n      // Update packument with removed versions\n      await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, {\n        ...opts,\n        method: 'PUT',\n        body: pkg,\n        ignoreBody: true,\n      })\n\n      // Remove the tarball itself\n      const { _rev } = await npmFetch.json(pkgUri, {\n        ...opts,\n        query: { write: true },\n      })\n      const tarballUrl = new URL(dist.tarball).pathname.substr(1)\n      await npmFetch(`${tarballUrl}/-rev/${_rev}`, {\n        ...opts,\n        method: 'DELETE',\n        ignoreBody: true,\n      })\n      return true\n    }\n  } catch (err) {\n    if (err.code !== 'E404') {\n      throw err\n    }\n\n    return true\n  }\n}\n\nmodule.exports = unpublish\n"]}