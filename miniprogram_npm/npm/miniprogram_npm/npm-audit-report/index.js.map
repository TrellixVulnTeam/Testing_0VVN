{"version":3,"sources":["index.js","reporters/install.js","colors.js","reporters/detail.js","reporters/json.js","reporters/quiet.js","exit-code.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,AFMA,AGTA;AFOA,AFMA,AGTA,AFMA,AGTA;AFOA,AFMA,AGTA,AFMA;ACFA,AFMA,AGTA,AFMA,AIZA;AHUA,AFMA,AGTA,AFMA,AIZA;AHUA,AFMA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;ACFA,AIZA,ANkBA,AGTA,AFMA;AKdA,ANkBA,AGTA,AFMA;AKdA,ANkBA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;ADIA,AGTA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst reporters = {\n  install: require('./reporters/install'),\n  detail: require('./reporters/detail'),\n  json: require('./reporters/json'),\n  quiet: require('./reporters/quiet')\n}\n\nconst exitCode = require('./exit-code.js')\n\nmodule.exports = Object.assign((data, options = {}) => {\n  const {\n    reporter = 'install',\n    color = true,\n    unicode = true,\n    indent = 2,\n  } = options\n\n  // CLI defaults this to `null` so the defaulting method above doesn't work\n  const auditLevel = options.auditLevel || 'low'\n\n  if (!data)\n    throw Object.assign(\n      new TypeError('ENOAUDITDATA'),\n      {\n        code: 'ENOAUDITDATA',\n        message: 'missing audit data'\n      }\n    )\n\n  if (typeof data.toJSON === 'function')\n    data = data.toJSON()\n\n  return {\n    report: reporters[reporter](data, { color, unicode, indent }),\n    exitCode: exitCode(data, auditLevel)\n  }\n}, { reporters })\n","const colors = require('../colors.js')\n\nconst calculate = (data, { color }) => {\n  const c = colors(color)\n  const output = []\n  const { metadata: { vulnerabilities }} = data\n  const vulnCount = vulnerabilities.total\n\n  let someFixable = false\n  let someForceFixable = false\n  let forceFixSemVerMajor = false\n  let someUnfixable = false\n\n  if (vulnCount === 0) {\n    output.push(`found ${c.green('0')} vulnerabilities`)\n  } else {\n    for (const [name, vuln] of Object.entries(data.vulnerabilities)) {\n      const { fixAvailable } = vuln\n      someFixable = someFixable || fixAvailable === true\n      someUnfixable = someUnfixable || fixAvailable === false\n      if (typeof fixAvailable === 'object') {\n        someForceFixable = true\n        forceFixSemVerMajor = forceFixSemVerMajor || fixAvailable.isSemVerMajor\n      }\n    }\n    const total = vulnerabilities.total\n    const sevs = Object.entries(vulnerabilities).filter(([s, count]) => {\n      return (s === 'low' || s === 'moderate' || s === 'high' || s === 'critical') &&\n        count > 0\n    })\n\n    if (sevs.length > 1) {\n      const severities = sevs.map(([s, count]) => {\n        return `${count} ${c.severity(s)}`\n      }).join(', ')\n      output.push(`${c.red(total)} vulnerabilities (${severities})`)\n    } else {\n      const [sev, count] = sevs[0]\n      output.push(`${count} ${c.severity(sev)} severity vulnerabilit${count === 1 ? 'y' : 'ies'}`)\n    }\n\n    // XXX use a different footer line if some aren't fixable easily.\n    // just 'run `npm audit` for details' maybe?\n\n    if (someFixable) {\n      output.push('', 'To address ' +\n        (someForceFixable || someUnfixable ? 'issues that do not require attention'\n          : 'all issues') + ', run:\\n  npm audit fix')\n    }\n\n    if (someForceFixable) {\n      output.push('', 'To address all issues' +\n        (someUnfixable ? ' possible' : '') +\n        (forceFixSemVerMajor ? ' (including breaking changes)' : '') +\n        ', run:\\n  npm audit fix --force')\n    }\n\n    if (someUnfixable) {\n      output.push('',\n        'Some issues need review, and may require choosing',\n        'a different dependency.')\n    }\n  }\n\n  const summary = output.join('\\n')\n  return {\n    summary,\n    report: vulnCount > 0 ? `${summary}\\n\\nRun \\`npm audit\\` for details.`\n      : summary\n  }\n}\n\nmodule.exports = Object.assign((data, opt) => calculate(data, opt).report, {\n  summary: (data, opt) => calculate(data, opt).summary\n})\n","const chalk = require('chalk')\nmodule.exports = color => {\n  const identity = x => x\n  const green = color ? s => chalk.green.bold(s) : identity\n  const red = color ? s => chalk.red.bold(s) : identity\n  const magenta = color ? s => chalk.magenta.bold(s) : identity\n  const yellow = color ? s => chalk.yellow.bold(s) : identity\n  const white = color ? s => chalk.bold(s) : identity\n  const severity = (sev, s) => sev.toLowerCase() === 'moderate' ? yellow(s || sev)\n    : sev.toLowerCase() === 'high' ? red(s || sev)\n    : sev.toLowerCase() === 'critical' ? magenta(s || sev)\n    : white(s || sev)\n  const dim = color ? s => chalk.dim(s) : identity\n\n  return {\n    dim,\n    green,\n    red,\n    magenta,\n    yellow,\n    white,\n    severity\n  }\n}\n","\n\nconst colors = require('../colors.js')\nconst install = require('./install.js')\n\nmodule.exports = (data, { color }) => {\n  const summary = install.summary(data, { color })\n  const none = data.metadata.vulnerabilities.total === 0\n  return none ? summary : fullReport(data, {color, summary})\n}\n\nconst fullReport = (data, { color, summary }) => {\n  const c = colors(color)\n  const output = [c.white('# npm audit report'), '']\n\n  const printed = new Set()\n  for (const [name, vuln] of Object.entries(data.vulnerabilities)) {\n    // only print starting from the top-level advisories\n    if (vuln.via.filter(v => typeof v !== 'string').length !== 0)\n      output.push(printVuln(vuln, c, data.vulnerabilities))\n  }\n\n  output.push(summary)\n\n  return output.join('\\n')\n}\n\nconst printVuln = (vuln, c, vulnerabilities, printed = new Set(), indent = '') => {\n  if (printed.has(vuln))\n    return null\n\n  printed.add(vuln)\n  const output = []\n\n  output.push(c.white(vuln.name) + '  ' + vuln.range)\n\n  if (indent === '' && (vuln.severity !== 'low' || vuln.severity === 'info')) {\n    output.push(`Severity: ${c.severity(vuln.severity)}`)\n  }\n\n  for (const via of vuln.via) {\n    if (typeof via === 'string') {\n      output.push(`Depends on vulnerable versions of ${c.white(via)}`)\n    } else if (indent === '') {\n      output.push(`${c.white(via.title)} - ${via.url}`)\n    }\n  }\n\n  if (indent === '') {\n    const { fixAvailable: fa } = vuln\n    if (fa === false) {\n      output.push(c.red('No fix available'))\n    } else if (fa === true) {\n      output.push(c.green('fix available') + ' via `npm audit fix`')\n    } else {\n      /* istanbul ignore else - should be impossible, just being cautious */\n      if (typeof fa === 'object' && indent === '') {\n        output.push(\n          `${c.yellow('fix available')} via \\`npm audit fix --force\\``,\n          `Will install ${fa.name}@${fa.version}` +\n          `, which is ${fa.isSemVerMajor ? 'a breaking change' :\n            'outside the stated dependency range' }`\n        )\n      }\n    }\n  }\n\n  for (const path of vuln.nodes) {\n    output.push(c.dim(path))\n  }\n\n  for (const effect of vuln.effects) {\n    const vuln = vulnerabilities[effect]\n    const e = printVuln(vuln, c, vulnerabilities, printed, '  ')\n    if (e)\n      output.push(...e.split('\\n'))\n  }\n\n  if (indent === '') {\n    output.push('')\n  }\n\n  return output.map(l => `${indent}${l}`).join('\\n')\n}\n","module.exports = (data, { indent }) => JSON.stringify(data, null, indent)\n","module.exports = () => ''\n","// return 1 if any vulns in the set are at or above the specified severity\nconst severities = new Map(Object.entries([\n  'info',\n  'low',\n  'moderate',\n  'high',\n  'critical',\n  'none'\n]).map(s => s.reverse()))\n\nmodule.exports = (data, level) =>\n  Object.entries(data.metadata.vulnerabilities)\n    .some(([sev, count]) => count > 0 && severities.has(sev) &&\n      severities.get(sev) >= severities.get(level)) ? 1 : 0\n"]}